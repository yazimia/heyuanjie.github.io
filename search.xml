<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/11/29/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>开始写这篇博客时基础的命令学的差不多了，所以只打算记录一下一些比较有用而不算特别基础的，桀桀。</p>
<h5 id="sudo-dpkg-选项-deb软件包"><a href="#sudo-dpkg-选项-deb软件包" class="headerlink" title="sudo dpkg (选项) (deb软件包)"></a>sudo dpkg (选项) (deb软件包)</h5><p>选项:<br>-i:安装软件包<br>-r:删除软件包<br>-P:删除软件包的同时删除其配置文件</p>
<h5 id="sudo-apt-upgrade"><a href="#sudo-apt-upgrade" class="headerlink" title="sudo apt upgrade"></a>sudo apt upgrade</h5><p>升级软件包</p>
<p>#####sudo apt install &lt; package1 &gt; &lt; package2 &gt;…<br>安装多个软件包</p>
<p>####.sh使用</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/05/24/2024.5.24%E5%B0%8F%E7%BA%A2%E4%B9%A6C++%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AE%9E%E4%B9%A0%E7%94%9F-%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<p>Linux中mmap的底层实现，普通文件，匿名文件映射分别怎么实现，优点<br>讲了一堆后来他说还有，不会然后他说缺页中断后在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。<br>Linux中文件系统底层原理，怎么实现的<br>多级页表怎么实现<br>内存屏障，讲一下MESI<br>磁盘读写和内存读写的区别<br>讲一下LRU-K<br>然后让我手写一个lru，写了个unordered_map+链表，被问还能优化吗，说了数据小可以不用unordered_map,结果是写代码过程中全程写mp[key],可以用临时变量存下来<br>map底层原理<br>原子类型底层实现<br>锁有哪些，讲一下，怎么用</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/29/Linux%E5%AD%A6%E4%B9%A0&amp;bazel%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>搞了半天才能将windows下的文件直接复制进虚拟机Ubuntu</p>
<p>暂时先用Ubuntu作为学习Linux的工具，打算之后换笔记本,并且将Ubuntu用的比较熟练的时候再去搞manjaro或者Kubuntu</p>
<p>搞双系统和配Clash,vscode,bazel,qq,微信各种环境弄了两三天，还挺好玩的</p>
<p>暂时把虚拟机和双系统都搞完了，虽然还没搞懂bazel，但在叶老师的帮助下还是完成了全佬的任务（<del>尽管发现这些任务没啥实际意义</del>）</p>
<p>打算记录一下</p>
]]></content>
  </entry>
  <entry>
    <title>2024.2.23非凸科技面经</title>
    <url>/2024/02/23/2024.2.23%E9%9D%9E%E5%87%B8%E7%A7%91%E6%8A%80%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<span id="more"></span>
<p>已offer</p>
<p>一共只有一面</p>
<p>上来先是自我介绍</p>
<p>然后问为什么大二实习以及大二实习学校的学业怎么办</p>
<p>之后开始拷打项目，有点磕磕绊绊，但也勉强把该说的说了</p>
<p>然后就是智力题，1000杯水，1杯里有毒，10只小鼠，怎么找出有毒的水</p>
<p>然后让写了最长公共子序列，面试时大脑宕机了调了一会儿(还读错题了)</p>
<p>写完问了对量化的看法，以及为什么对量化感兴趣，对公司的理解，对金融的理解(一点不懂被面试官看出来了)</p>
<p>然后给我介绍了岗位和公司</p>
<p>然后给我看了一道挺大的情景题(当时还以为要当场写，懵了)，介绍了一下这个场景(没咋细听，讲完就忘得差不多了)，让我第二天晚上前提交给他</p>
<p>最后反问环节问了去公司能够学到什么</p>
<p>当天晚上开写，一晚上写的差不多了，想问面试官要输出文件参考被拒绝了</p>
<p>第二天早上小优化了一下就提交了</p>
<p>当晚回我说没问题，然后问了一些可优化点,都答上来了，自我感觉讲的还可以</p>
<p>之前给我讲的一个小细节我还以为没用，结果发现是我对金融的理解有问题</p>
<p>面试官人挺和善，总的来说对啥也不会的彩笔acmer还是友好的</p>
]]></content>
      <tags>
        <tag>面经</tag>
        <tag>非凸科技</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/26/2024.4.26%E8%85%BE%E8%AE%AFwxg%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>n! 结果中尾随零的数量</p>
<p>实现支持下列接口的「快照数组」- SnapshotArray：</p>
<ul>
<li>SnapshotArray(int length) &#x2F;&#x2F; 初始化一个与指定长度相等的 类数组 的数据结构。初始时，每个元素都等于 0。</li>
<li>void set(index, val) &#x2F;&#x2F; 会将指定索引 index 处的元素设置为 val。</li>
<li>int snap() &#x2F;&#x2F; 获取该数组的快照，并返回快照的编号 snap_id（快照号是调用 snap() 的总次数减去 1）。</li>
<li>int get(index, snap_id) &#x2F;&#x2F; 根据指定的 snap_id 选择快照，并返回该快照指定索引 index 的值。</li>
</ul>
<p>Bandy有一个根结点为 root 的二叉树模型，初始所有结点均为白色，可以用蓝色染料给模型结点染色。<br>模型的每个结点有一个 val 价值。Bandy出于美观考虑，希望最后二叉树上每个蓝色相连部分的结点个数不能超过 k 个，求所有染成蓝色的结点价值总和最大是多少？</p>
<p>3道题，限40min</p>
<p>结合我的代码问了几个变量(class里的vector，int* a&#x3D;new…)在内存哪个区上</p>
<p>一个进程能开多少空间</p>
<p>网址键入发生什么</p>
<p>ssl握手</p>
<p>感觉主要点都说了，但是面试官说不全，我也不知道从哪里开始补充</p>
<p>问了实习用的工具，内容，HDFS 和 Apache Arrow怎么用，实习处理的300G数据有几行，大概怎么处理的，用了多少资源去跑</p>
<p>没问项目</p>
<p>问了oi，acm经历，为什么去szu，什么时候能来，问我哪里人，读不读研</p>
<p>浙江人不是很看重学历吗，为什么不读研</p>
<p>反问</p>
<p>问了项目实习生和普通实习生工作有什么区别（没啥区别）</p>
]]></content>
  </entry>
  <entry>
    <title>极角排序</title>
    <url>/2019/06/08/%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法$1:$"></a>方法$1:$</h2><p>利用$atan2()$函数按极角从小到大排序。</p>
<p>$atan2(double<del>y,double</del>x)$其中$y$代表已知点的$Y$坐标，同理$x$ ,返回值见下图，它的值域相应的也就是$-\pi\sim \pi$了</p>
<p><img src="https://i.loli.net/2019/06/08/5cfb243024db668261.png" alt="2018070916220484.png"><br><img src="https://i.loli.net/2019/06/08/5cfb20c6d1fd746959.png" alt="frefefrferferftgtrgy.png"></p>
<p>$atan2$转换到$\left[0,2\pi\right)$表示的是与$x$轴正方向的逆时针夹角，这样转换的好处是便于计算两条线之间的夹角。</p>
<p>第二种转换是用于对<strong>直线</strong>进行极角排序的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">atan2</span>(a.y,a.x)!=<span class="built_in">atan2</span>(b.y,b.x))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atan2</span>(a.y,a.x)&lt;<span class="built_in">atan2</span>(b.y,b.x);</span><br><span class="line">     <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;<span class="comment">//不转换</span></span><br></pre></td></tr></table></figure>

<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法$2:$"></a>方法$2:$</h2><p>利用叉积。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="type">double</span> <span class="keyword">operator</span> ^(Point a,Point b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y-b.x*a.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若叉积$&gt;0$，则向量$a$在向量$b$的顺时针方向,叉积$&lt;0$，则向量$a$在向量$b$的逆时针方向</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((a^b)==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> (a^b)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序效果同单个$atan2()$</p>
<h2 id="方法比较"><a href="#方法比较" class="headerlink" title="方法比较"></a>方法比较</h2><p>一般情况下用叉积(精度高),但是$atan2()$更加灵活。</p>
]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流杂记(待填坑,可能咕咕)</title>
    <url>/2019/04/30/%E7%BD%91%E7%BB%9C%E6%B5%81%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="求二分图最大匹配方案时只需求出所有反向边中边权大于0的即可"><a href="#求二分图最大匹配方案时只需求出所有反向边中边权大于0的即可" class="headerlink" title="求二分图最大匹配方案时只需求出所有反向边中边权大于0的即可 "></a>求二分图最大匹配方案时只需求出所有反向边中边权大于0的即可 </h2><p>二分图匹配只需源点连向所有左侧的点，边权为inf，所有右侧的点连汇点，边权也为$inf$，两侧的点的连边即是原图上的连边，边权为$1$。求最大流即可</p>
<h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p>我们求最大流等于求最小割，因为两侧的点与源汇点的连边权都为$inf$，所以割边只能是</p>
<hr>
<h2 id="拆点"><a href="#拆点" class="headerlink" title="拆点"></a>拆点</h2><p>最大流模型的一般建模思路是运用流的容量限制，使得题目中的约束得以满足，有时还需使用一些特殊的方法（如拆点）来满足题目的特别约束。</p>
<h2 id="拆点的主要应用"><a href="#拆点的主要应用" class="headerlink" title="拆点的主要应用"></a>拆点的主要应用</h2><p>1.例如一件物品<strong>只能用有限次</strong>，但是如果不拆点普通建模跑网络流很可能会导致这个点被超过限制次数的流量经过，使答案出错，所以如果将这个点拆成两个，设为$i_1$ , $i_2$,原入边连 $i_1$，原出边连 $i_2$,$i_1$与$i_2$之间连边权为限制次数的边即可。正确性显然。</p>
<p>例题1:<a href="https://www.luogu.org/problemnew/show/P1231">P1231 教辅的组成</a></p>
<p>例题2:<a href="https://www.luogu.org/problemnew/show/P1345">P1345 [USACO5.4]奶牛的电信</a><br>(拆点解决最小割点问题)</p>
<p>例题:<a href="https://www.luogu.org/problemnew/show/P1402"> P1402 酒店之王</a></p>
<hr>
<h2 id="二分图最大匹配的三个定理"><a href="#二分图最大匹配的三个定理" class="headerlink" title="二分图最大匹配的三个定理"></a>二分图最大匹配的三个定理</h2><p>   1:最大匹配数 + 最大独立集 &#x3D;$n$(点数)</p>
<p>   2:二分图的最小覆盖数 &#x3D; 最大匹配数 </p>
<p>   3:最小路径覆盖 &#x3D; 最大独立集 </p>
<h2 id="最大独立集是指求一个二分图中最大的一个点集，该点集内的点互不相连。-最小顶点覆盖是指-在二分图中，用最少的点，让所有的边至少和一个点有关联。-最小路径覆盖是指一个不含圈的有向图G-中，G的一个路径覆盖是一个其结点不相交的路径集合P，图中的每一个结点仅包含于P-中的某一条路径。路径可以从任意结点开始和结束，且长度也为任意值，包括0-在二分图匹配时，如果有很多个条件都不满足才能连边，跑最大匹配是错误的，"><a href="#最大独立集是指求一个二分图中最大的一个点集，该点集内的点互不相连。-最小顶点覆盖是指-在二分图中，用最少的点，让所有的边至少和一个点有关联。-最小路径覆盖是指一个不含圈的有向图G-中，G的一个路径覆盖是一个其结点不相交的路径集合P，图中的每一个结点仅包含于P-中的某一条路径。路径可以从任意结点开始和结束，且长度也为任意值，包括0-在二分图匹配时，如果有很多个条件都不满足才能连边，跑最大匹配是错误的，" class="headerlink" title="　   最大独立集是指求一个二分图中最大的一个点集，该点集内的点互不相连。　   最小顶点覆盖是指 在二分图中，用最少的点，让所有的边至少和一个点有关联。     最小路径覆盖是指一个不含圈的有向图G 中，G的一个路径覆盖是一个其结点不相交的路径集合P，图中的每一个结点仅包含于P 中的某一条路径。路径可以从任意结点开始和结束，且长度也为任意值，包括0.    在二分图匹配时，如果有很多个条件都不满足才能连边，跑最大匹配是错误的，"></a>　   最大独立集是指求一个二分图中最大的一个点集，该点集内的点互不相连。<br><br>　   最小顶点覆盖是指 在二分图中，用最少的点，让所有的边至少和一个点有关联。<br><br>     最小路径覆盖是指一个不含圈的有向图G 中，G的一个路径覆盖是一个其结点不相交的路径集合P，图中的每一个结点仅包含于P 中的某一条路径。路径可以从任意结点开始和结束，且长度也为任意值，包括0.<br><br>    在二分图匹配时，如果有很多个条件都不满足才能连边，跑最大匹配是错误的，</h2>]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>奇技淫巧杂记</title>
    <url>/2019/05/04/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="奇技淫巧杂记"><a href="#奇技淫巧杂记" class="headerlink" title="奇技淫巧杂记"></a>奇技淫巧杂记</h2><span id="more"></span>

<p>$1.$描述<br>给定两个数$n,m,$其中$m$是一个素数。<br>将$n(0\leqslant n\leqslant 2^{31})$的阶乘分解质因数，求其中有多少个$m$。</p>
<p>做法：</p>
<p>$while(n&#x2F;m) ans+&#x3D;n&#x2F;m,n&#x2F;&#x3D;m;$</p>
<p>$ans$即为答案</p>
]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/11/29/%E6%95%B0%E8%AE%BA%E7%BB%93%E8%AE%BA/</url>
    <content><![CDATA[<p>狄利克雷卷积和莫比乌斯反演</p>
<p>狄利克雷卷积定义式</p>
<p>$(f * g)(n):&#x3D;\sum_{d \mid n} f(d) g\left(\frac{n}{d}\right) \quad(d \in \mathbb{N})$</p>
<p>这里提醒一个很明显的事实：在这个定义式中，右式的函数 $f$ 和 $g$ 括号中的参数是可以调换 的，即:</p>
<p>$(f * g)(n):&#x3D;\sum_{d \mid n} f\left(\frac{n}{d}\right) g(d) \quad(d \in \mathbb{N})$</p>
<p>单位函数 $\varepsilon(n)$</p>
<p>$\varepsilon(n):&#x3D; \begin{cases}1, &amp; n&#x3D;1 \ 0, &amp; \text { otherwise }\end{cases}$</p>
<p>幂函数 $\mathrm{Id}_k(n)$</p>
<p>$\operatorname{Id}_k(n):&#x3D;n^k$</p>
<p>特别地，有：</p>
<ul>
<li><p>当 $k&#x3D;1$ 时，为恒等函数 $\operatorname{Id}(n)$ ，即 $\operatorname{Id}(n):&#x3D;n$.</p>
</li>
<li><p>当 $k&#x3D;0$ 时，为常数函数 $\mathbf{1}(n)$ ，即 $\mathbf{1}(n):&#x3D;1$.</p>
</li>
</ul>
<p>$\sum_{d \mid n} \varphi(d)&#x3D;n$</p>
<p>$\sum_{d \mid n} \mu(d)&#x3D;[n&#x3D;1]$</p>
<p>$[\operatorname{gcd}(i, j)&#x3D;1]&#x3D;\sum_{d \mid \operatorname{gcd}(i, j)} \mu(d)$</p>
]]></content>
  </entry>
  <entry>
    <title>网络流——最小割求最大权闭合子图</title>
    <url>/2019/04/30/%E7%BD%91%E7%BB%9C%E6%B5%81%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E5%89%B2%E6%B1%82%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE/</url>
    <content><![CDATA[<span id="more"></span>

<p>有一个有向图，每一个点都有一个权值（可以为正或负或$0$），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。 </p>
<p>如下图：<br><img src="https://i.loli.net/2019/04/11/5caea63d229b3.png"></p>
<p>能选的子图有$Ø$(即不选),{$4$},{$3,4$},{$2,4$},{$1,2,3,4$},它们的权值分别为$0,-1,5,-6,4.$<br>所以最大权闭合子图为{$3,4$}，权值为$5$.</p>
<p>解法<br>这个问题可以转化为最小割问题，用网络流解决。 </p>
<p>从源点$s$向每个正权点连一条容量为权值的边，每个负权点向汇点$t$连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。 </p>
<p><img src="https://img-blog.csdn.net/20170826171031814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2FuOTE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>求它的最小割，割掉后，与源点s连通的点构成最大权闭合子图，权值为（正权值之和$-$最小割）。</p>
<h2 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h2><h3 id="割掉一条边的含义"><a href="#割掉一条边的含义" class="headerlink" title="割掉一条边的含义"></a>割掉一条边的含义</h3><p>由于原图的边都是无穷大，那么割边一定是与源点$s$或汇点$t$相连的。</p>
<p>割掉$s$与$i$的边，表示不选择$i$点作为子图的点；</p>
<p>割掉$i$与$t$的边，表示选择$i$点为子图的点。</p>
<p>如果$s$与$i$有边，表示$i$存在子图中； </p>
<p>如果$i$与$t$有边，表示$i$不存在于子图中。</p>
<h3 id="合法性"><a href="#合法性" class="headerlink" title="合法性"></a>合法性</h3><p>只有$s$与$t$不连通时，才能得到闭合子图。</p>
<p>如果$s$与$t$连通，则存在点$i,j$，使得$s$到$i$有边，$i$到$j$连通,$j$到$t$有边，所以$j$一定是$i$的后继，但选择了$i$，没有选择$j$，不是闭合子图。</p>
<p>如果$s$与$t$不连通，选择了正权点$i$，一定选择了$i$后继中的所有负权点。设$j$是$i$的后继中的正权点，则割掉$s$到$j$的边是没有意义的，最小割不会割掉它，则$j$一点被选中，所以$i$的所有后继都被选中，符合闭合图的定义。</p>
<h3 id="最优性"><a href="#最优性" class="headerlink" title="最优性"></a>最优性</h3><p>最小割&#x3D;(不选的正权之和+要选的负权绝对值之和） </p>
<p>最大权闭合子图&#x3D;（正权之和-不选的正权之和-要选的负权绝对值之和）&#x3D;正权值和-最小割 </p>
<p>因为正权值和，是定值，而最小割保证值最小，所以最大权闭合子图一定最优。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.org/problemnew/show/P3410">洛谷P3410 拍照</a></p>
<p><a href="http://poj.org/problem?id=2987">POJ2987_Firing</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P4174">P4174 [NOI2006]最大获利</a></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="要求输出方案"><a href="#要求输出方案" class="headerlink" title="要求输出方案"></a>要求输出方案</h3><p>枚举每个点的$dep$，如果$dep&lt;inf$，那么则是方案内的点</p>
<p>因为那种无论怎么买花费$&gt;$收入，这样的购买有一个特点，因为它不能供给需求，所以源点到它的残流一定是$0$，就是说不管是正向边还是反向边都是$0$，同样的那些可以供给的，源点到它的残留一定大于$0$，也就是正向边或者反向边大于$0$，说明做这个购买能赚钱。</p>
<p>所以在最后一遍$bfs$时，边权为$0$的边是不会走的，也就是说$bfs$时只会走边权大于$0$的边，所以走过的每一个点都是方案中的点，因为只有走过的点$dep$才会小于$inf$，所以只需要找出$dep&lt;inf$的点即可</p>
<p>例题<a href="https://www.luogu.org/problemnew/show/P2762">P2762 太空飞行计划问题</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>任意多边形的面积公式</title>
    <url>/2019/06/07/%E4%BB%BB%E6%84%8F%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>

<p>前置芝士$:$向量及其的基本运算，如叉积(叉积运算下面用符号^表示)。</p>
<p>对于一个已知三点坐标的三角形，其面积是可以算出来的。</p>
<p>设点$c$为原点$(0,0)$</p>
<p>$S_{\Delta}&#x3D;\frac{|\vec{a}|\times |\vec{b}|\times\sin (\theta)}{2}&#x3D;\frac{\vec{a}<del>\hat{}</del>\vec{b}}{2}&#x3D;\frac{\left|x_{1}\times y_{2}-x_{2}\times y_{1}\right|}{2}$</p>
<p>对于任意多边形</p>
<p>$S&#x3D;\frac{\left| \sum_{1}^{n-1}(x[i]\times y[i+1]-x[i+1]\times y[i])+x[n]\times y[1]-x[1]\times y[n]\right|}{2}$</p>
<p>$ps:$注意绝对值不要忘。</p>
<p>来张图</p>
<p><img src="https://i.loli.net/2019/06/07/5cf93ef03177f55454.png"></p>
<p>在网上并没有找到什么严格的证明，但是如果自己手玩过就会发现这样做是对的。</p>
<p>其中标出的$a$部分(不包括多边形本身)被重复算了两次，一次加，一次减，而多边形本身只被算了一次，符合题意。</p>
<p>如果点的坐标不是按顺序依次给出的又该怎么办呢？</p>
<p>$1.$所给多边形为凹包(或者不给说明，凸包和凹包都有可能)：</p>
<p>如果点不是按照顺序依次给出的，那么所构成的多边形一定不唯一（画画就明了），所以点一定是按顺序给出的</p>
<p>$2.$所给多边形为凸包：</p>
<p>我们可以先将点按极角排序，就可套用公式了,(凸包的点极角排序后多边形的顶点是依次有序的,且多边形一定是唯一的)</p>
<p>例题<a href="https://www.luogu.org/problemnew/show/P2785">P2785 物理1（phsic1）- 磁通量</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2000900</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="keyword">friend</span> point <span class="keyword">operator</span> -(point a,point b)&#123;</span><br><span class="line">    	<span class="keyword">return</span> (point)&#123;b.x-a.x,b.y-a.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">double</span> <span class="keyword">operator</span> ^(point a,point b)&#123;</span><br><span class="line">    	<span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N],s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a-s)^(b-s))&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> ans,b;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;b);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;p[<span class="number">0</span>].x,&amp;p[<span class="number">0</span>].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)ans+=(p[i]^p[i+<span class="number">1</span>]);</span><br><span class="line">    ans+=p[n<span class="number">-1</span>]^p[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>,ans*b*<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 AT2134 【Zigzag MST】</title>
    <url>/2019/09/22/%E9%A2%98%E8%A7%A3%20AT2134%20%E3%80%90Zigzag%20MST%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>对一张$n$个点的图做$Q$次加边操作,每次给定$A_i,B_i,C_i,$然后按顺序连边$(A_i,B_i,C_i),(B_i,A_i+1,C_i+1),(A_i+1,B_i+1,C_i+2)$等等，求给定图的最小生成树$.(A_i,B_i,C_i$等点编号均为对$n$取模的意义下$)$给定初始的$n,q,A_i,B_i,C_i;$</p>
<p>$(N,Q\leqslant 200000,0\leqslant A_i,B_i&lt;N,1\leqslant C_i\leqslant 10^9)$</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>经过简单思考，我们发现，对于一次加边操作，最多加入$2\times n$条边，因为第$2\times n+1$条边为$((A_i+n)%n,((B_i+n)%n,d+2\times n)$即$(A_i,B_i,d+2\times n),$由于求最小生成树，往后的边加入就没有意义了。</p>
<p>所以总边数为$N\times Q$,然而这个复杂度依然无法接受</p>
<p>对于一次连边,假设连$(A_i,B_i,C_i),$那么第二条边就要连$(B_i,A_i+1,C_i+1),$由于此时$A_i$和$B_i$已经联通$(B_i,A_i+1,C_i+1)$其实等价于$(A_i,A_i+1,C_i+1)$</p>
<p>于是我们可以发现，每次连边操作就相当于连$(A_i,B_i,C_i)$</p>
<p>$((A_i+d-1)%n+1,(A_i+d)%n+1,C_i+2\times d+1)$</p>
<p>$((B_i+d-1)%n+1,(B_i+d)%n+1,C_i+2\times d+2)(0\leqslant d&lt;n)$</p>
<p>虽然这并没有改变每次加边$O(n)$的复杂度</p>
<p>但是我们发现$(A_i+1,A_i+2)$的边权等于$(A_i,A_i+1)$的边权$+2$</p>
<p>于是我们设一个数组$g,$使得$g[i]$表示$(i,i%n+1)$这条边的最小边权$($开始时设为$inf),$接着对于一次连边我们连上$(A_i,B_i,C_i),$再将</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g[u]=<span class="built_in">min</span>(g[u],d+<span class="number">1</span>);g[v]=<span class="built_in">min</span>(g[v],d+<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们只需要再用$g[i]$更新$g[i%n+1]$即可，由于更新的节点顺序呈环形，所以需要更新两遍</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g[i%n+<span class="number">1</span>]=<span class="built_in">min</span>(g[i%n+<span class="number">1</span>],g[i]+<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>最后再连上$(i,i%n+1,g[i])$就可以将将边数降低到$O(n)$级别，然后直接跑$Kruskal$即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 301200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,d;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N],g[N],ans,n,Q,cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d&lt;b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> f[k]==k?k:f[k]=<span class="built_in">find</span>(f[k]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+cnt,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>,t=<span class="number">0</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(e[i].u),y=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span> (x==y)<span class="keyword">continue</span>;</span><br><span class="line">        f[x]=y;</span><br><span class="line">        ++t;ans+=e[i].d;</span><br><span class="line">        <span class="keyword">if</span> (t==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),Q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">while</span> (Q--)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>()+<span class="number">1</span>,v=<span class="built_in">read</span>()+<span class="number">1</span>,d=<span class="built_in">read</span>();</span><br><span class="line">        e[++cnt]=(edge)&#123;u,v,d&#125;;</span><br><span class="line">        g[u]=<span class="built_in">min</span>(g[u],d+<span class="number">1</span>);g[v]=<span class="built_in">min</span>(g[v],d+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        g[i%n+<span class="number">1</span>]=<span class="built_in">min</span>(g[i%n+<span class="number">1</span>],g[i]+<span class="number">2</span>),f[i]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        g[i%n+<span class="number">1</span>]=<span class="built_in">min</span>(g[i%n+<span class="number">1</span>],g[i]+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)e[++cnt]=(edge)&#123;i,i%n+<span class="number">1</span>,g[i]&#125;;</span><br><span class="line">    <span class="built_in">Kr</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>连边优化</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 AT2364 【Colorful Balls】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20AT2364%20%E3%80%90Colorful%20Balls%E3%80%91/</url>
    <content><![CDATA[<p>题意$:N$ 个球排成一排，第个$i$球的颜色为$c_i$，重量为 $w_i$。我们定义「一次操作」为：选择两个颜色<strong>相同</strong>，且重量之和不超过$X$的球，交换它们的位置；或选择两个颜色<strong>不同</strong>，且重量之和不超过$Y$的球，交换它们的位置。问进行任意次操作后，可以得到多少种不同的颜色序列。输出答案对 $10^9+7$ 取模的结果。</p>
<span id="more"></span>

<p>显然如果有三个球$a,b,c$,如果$a$与$b$能交换,$b$与$c$能交换，那$a$与$c$一定能通过$b$的“媒介”交换（$a$先于$b$交换，$b$与$c$交换，$a$与$b$交换）。</p>
<p>于是我们可以把$a,b,c$缩在同一个连通块里。</p>
<p>由于不同颜色与相同颜色交换条件是不一样的，我们先考虑相同颜色。</p>
<p>显然只需要用最小值做“媒介”即可。</p>
<p>然后我们考虑跨颜色交换。我们发现只需要用全局最小值做“媒介”，也就是说对于某个点，先通过该颜色最小值换到全局最小值，再通过全局最小值换到其他点。如果与全局最小值颜色相同，那我们就只能用次小值做媒介。</p>
<p>这样我们只需要记录某种颜色的最小值、全局最小值、全局次小值即可。</p>
<p>然后我们不难发现含有不同颜色的连通块只有一个，那就是全局最小值所在的连通块。</p>
<p>而只有一种颜色的连通块对答案没有影响。</p>
<p>于是我们只考虑最小值所在的连通块。首先我们找到全局最小值、全局次小值与每种颜色的最小值。如果他们都不能交换，那显然是凉了（答案为11）。我们对每种颜色数出能与该种颜色最小值交换的点数，然后用每种连通块的最小值与全局最小值（全局次小值）比较，求出这个联通块。我们发现就是求这个联通块排列方案数，其实就是可重集合排列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>)res=res*x%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mn[N],c[N],w[N],cnt[N],jc[N],inv[N],n,A,B,ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;keep.in&quot;, &quot;r&quot;, stdin); freopen(&quot;keep.out&quot;, &quot;w&quot;, stdout); </span></span><br><span class="line">    n=<span class="built_in">read</span>(),A=<span class="built_in">read</span>(),B=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">memset</span>(mn,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(mn));</span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n]=<span class="built_in">ksm</span>(jc[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        c[i]=<span class="built_in">read</span>(),w[i]=<span class="built_in">read</span>();</span><br><span class="line">        mn[c[i]]=<span class="built_in">min</span>(mn[c[i]],w[i]);<span class="comment">//颜色集合最小值 </span></span><br><span class="line">        ++cnt[c[i]];<span class="comment">//集合元素个数 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> Mn=<span class="number">1</span>,mnn=inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (mn[i]&lt;mn[Mn])</span><br><span class="line">            Mn=i;<span class="comment">//找出全局最小值的颜色 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (i!=Mn)</span><br><span class="line">            mnn=<span class="built_in">min</span>(mn[i],mnn);<span class="comment">//找出除全局最小值的集合以外的所有数的最小值 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (w[i]!=mn[c[i]]&amp;&amp;w[i]+mn[c[i]]&lt;=A)<span class="keyword">continue</span>;<span class="comment">//如果这个值不是所在集合的最小值但它与所在集合的最小值的和小于A，那么它是有意义的 </span></span><br><span class="line">        <span class="keyword">if</span> (c[i]!=Mn&amp;&amp;w[i]+mn[Mn]&lt;=B)<span class="keyword">continue</span>;<span class="comment">//如果这个值不在全局最小值所在的集合中 ，但它与全局最小值的和小于B，那么它是有意义的</span></span><br><span class="line">        <span class="keyword">if</span> (c[i]==Mn&amp;&amp;w[i]+mnn&lt;=B)<span class="keyword">continue</span>;<span class="comment">//如果它在全局最小值所在的集合中，且它与除全局最小值的集合以外的所有数的最小值的和小于B，那么它是有意义的 </span></span><br><span class="line">        --cnt[c[i]];<span class="comment">//如果它不符合以上条件，那么它的存在是没有意义的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=cnt[Mn];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (i!=Mn&amp;&amp;mn[Mn]+mn[i]&lt;=B)<span class="comment">//如果这种颜色存在且它不是全局最小值所在的集合 </span></span><br><span class="line">            num+=cnt[i];</span><br><span class="line">    ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(mn[i]!=inf&amp;&amp;(i==Mn||mn[i]+mn[Mn]&lt;=B))</span><br><span class="line">            ans=ans*inv[cnt[i]]%mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;++i)</span><br><span class="line">        ans=ans*i%mod;<span class="comment">//这里是求有重复元素的排列种数 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 4.21模拟赛T4</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%204.21%E6%A8%A1%E6%8B%9F%E8%B5%9BT4/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>$Ahri$得到了一个$(h+1) × (w+1)$的巧克力，这意味着她横着最多可以切$h$刀，竖着最多可以切$w$刀。</p>
<p>她想总共切$K$刀，每刀要么竖着切要么横着切，如果竖着切了$i$刀，横着切了$j$刀，会得到$(i+1) × (j+1)$个巧克力，定义一个切$K$刀的方案的代价是每一刀切完后巧克力个数之和，假设每刀切的位置是随机选择的（即剩余能切的位置等概率随机选一个），请你求出期望代价，对$1e9+7$取模</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution:$"></a>$Solution:$</h2><h3 id="做法一"><a href="#做法一" class="headerlink" title="做法一:"></a>做法一:</h3><p>参考<a href="https://xuxuxuxuxuxjh.github.io/2019/04/20/%E5%88%87%E8%9B%8B%E7%B3%95/">xjh大佬的博客</a></p>
<p>我们把答案的每一部分分开来考虑</p>
<p>每一部分对答案的贡献就是这一部分能算进答案里的方案数$×$这部分的价值</p>
<p>显然这里的每一部分就指的是横着切$i$刀，竖着切$j$刀</p>
<p>这一部分的价值横着切i刀，竖着切j刀的价值很好求，就是$(i+1)(j+1)$</p>
<p>无论怎么切，这一部分的价值都是$(i+1)(j+1)$</p>
<p>难点在于求这一部分能算进答案里的方案数</p>
<p>我们把所有方案都画出来，就会清楚的发现怎么求了</p>
<p>方案数就是<strong>能走到这个状态的方案数</strong>$×$<strong>这个状态走到结束状态的方案数</strong>(简称来的状态和去的状态)</p>
<p>来的状态就是$A^i_h\times A^j_w\times$(不同的切横切竖的顺序),$A^i_h\times A^j_w$比较好理解，但对(不同的切横切竖的顺序) 不知道怎么求</p>
<p>我们稍微转换一下：有$i$个$0$(相当于横切)，$j$个$1$(相当于纵切)，问用它们构成一个长为$i+j$的$01$串的方案数，答案就相当于有$i+j$个位置，选$i$个位置放$0$,剩余位置放$1$的方案数，即$C^{i}_{i+j}$。</p>
<p>去的状态就是$A^{k-i-j}_{n-i-j}$</p>
<p>贴上$xjh$大佬的代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10005</span>;</span><br><span class="line"><span class="type">int</span> h,w,k,n,ans,jc[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a+=b;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=mod)a-=mod;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kuai</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b=b/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;ahri.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;ahri.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>;inv[<span class="number">0</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10000</span>;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10000</span>;i++)inv[i]=inv[i]*inv[i<span class="number">-1</span>]%mod;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;h,&amp;w,&amp;k);</span><br><span class="line">    n=h+w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=h;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=w;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+j&gt;k)<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//ans=add(ans,a[h][i]*a[w][j]%mod*c[i+j][i]%mod*a[n-i-j][k-i-j]%mod*(i+1)%mod*(j+1)%mod);</span></span><br><span class="line">            ans=<span class="built_in">add</span>(ans,jc[h]*inv[h-i]%mod*jc[w]%mod*inv[w-j]%mod*jc[i+j]%mod*inv[i]%mod*inv[j]%mod*jc[n-i-j]%mod*inv[n-k]%mod*(i+<span class="number">1</span>)%mod*(j+<span class="number">1</span>)%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;(ans*<span class="built_in">kuai</span>(jc[n]%mod*inv[n-k]%mod,mod<span class="number">-2</span>)%mod+mod)%mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="做法二"><a href="#做法二" class="headerlink" title="做法二:"></a>做法二:</h3><p>概率期望$DP$(菜鸡我的做法)</p>
<p>下文中读入的$h,w$,分别设为$n,m$</p>
<p>设$g[i][j]$为切了$i$刀，有$j$刀是横向切的的期望,纵向切的刀数$k$显然$&#x3D;i-j$</p>
<p>显然$g[i][j]&#x3D;\sum f*val$,此处$f$表示其中一种切法的概率，$val$这种切法能得到的价值和。</p>
<p>我们去掉$val$,设$f[i][j]&#x3D;\sum f$</p>
<p>对于$f$数组的转移显然不难,$f[i][j]&#x3D;f[i-1][j]\times \dfrac{m-(k-1)}{n+m-i}+f[i-1][j]\times \dfrac{n-(j-1)}{n+m-i}$</p>
<p>但是$g$数组的转移就不简单了，我们考虑当前的$g[i][j]$如何从上一个状态转移过来。</p>
<p>之前说过$g[i][j]&#x3D;\sum f*val$</p>
<p>$\qquad \qquad \qquad $$&#x3D;f[i][j]\times (j+1)\times(k+1)$</p>
<p>我们假设</p>
<p><img src="https://i.loli.net/2019/04/23/5cbe6b2e5e418.png"></p>
<p>就这样，式子就推出来了</p>
<p>$ans&#x3D;\sum\limits_{i&#x3D;1}^{n} g[K][i]$</p>
<p>答案的寻找范围显然</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> g[<span class="number">2</span>][<span class="number">5005</span>],f[<span class="number">2</span>][<span class="number">5005</span>],ans,inv[<span class="number">10009</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;ahri.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="built_in">freopen</span>(<span class="string">&quot;ahri.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout); </span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();inv[<span class="number">0</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10007</span>;++i)inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>]=n*inv[n+m]%mod;f[<span class="number">1</span>][<span class="number">0</span>]=m*inv[n+m]%mod;<span class="comment">//概率 </span></span><br><span class="line">    g[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">2</span>*n%mod*inv[n+m]%mod;g[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">2</span>*m%mod*inv[n+m]%mod;<span class="comment">//期望 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="type">int</span> now=i&amp;<span class="number">1</span>;<span class="comment">//滚存 </span></span><br><span class="line">        <span class="built_in">memset</span>(f[now],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[now]));</span><br><span class="line">        <span class="built_in">memset</span>(g[now],<span class="number">0</span>,<span class="built_in">sizeof</span>(g[now]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(i,n);++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i-j&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> k=i-j;</span><br><span class="line">            <span class="comment">//考虑最后一刀横向切还是纵向切</span></span><br><span class="line">            <span class="type">int</span> A=<span class="number">0</span>,B=<span class="number">0</span>; </span><br><span class="line">            <span class="keyword">if</span> (k!=<span class="number">0</span>)&#123;<span class="comment">//最后一刀纵向切 </span></span><br><span class="line">                A=f[now^<span class="number">1</span>][j]*(m-(k<span class="number">-1</span>))%mod*inv[n+m-i+<span class="number">1</span>]%mod;</span><br><span class="line">                g[now][j]+=g[now^<span class="number">1</span>][j]*(m-(k<span class="number">-1</span>))%mod*inv[n+m-i+<span class="number">1</span>]%mod+(j+<span class="number">1</span>)*(k+<span class="number">1</span>)%mod*A%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            f[now][j]%=mod;g[now][j]%=mod;</span><br><span class="line">            <span class="keyword">if</span> (j!=<span class="number">0</span>)&#123;<span class="comment">//最后一刀横向切 </span></span><br><span class="line">                B=f[now^<span class="number">1</span>][j<span class="number">-1</span>]*(n-(j<span class="number">-1</span>))%mod*inv[n+m-i+<span class="number">1</span>]%mod;</span><br><span class="line">                g[now][j]+=g[now^<span class="number">1</span>][j<span class="number">-1</span>]*(n-(j<span class="number">-1</span>))%mod*inv[n+m-i+<span class="number">1</span>]%mod+(j+<span class="number">1</span>)*(k+<span class="number">1</span>)%mod*B%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            f[now][j]=A+B;<span class="comment">//概率相加 </span></span><br><span class="line">            f[now][j]%=mod;g[now][j]%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        ans=(ans+g[k&amp;<span class="number">1</span>][i])%mod;<span class="comment">//统计答案 </span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h3><p>此外还有复杂度跟我的做法一样，但实现更简单一些的$DP$;</p>
<p>并且用$FFT$优化$xjh$大佬的$O(nlogn)$做法和一种$O(logK+logn+logm)$的神奇做法。</p>
]]></content>
      <tags>
        <tag>思维题</tag>
        <tag>概率期望$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 AT2164 【Rabbit Exercise】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20AT2164%20%E3%80%90Rabbit%20Exercise%E3%80%91/</url>
    <content><![CDATA[<p>有$n$只兔子在一个数轴上，兔子为了方便起见从$ 1 $到$n $标号，第$ i $只兔子的初始坐标为$x_i$。兔子会以以下的方式在数轴上锻炼：一轮包含$m$个跳跃，第 $j$ 个是兔子$a[j] (2 \leqslant a[j] \leqslant N−1)$，$a$是给出的长度为$m$的数组跳一下，这一下从 兔子$a[j]− 1 $和 兔子$a[j] + 1$中等概率的选一个$（$假设选了$ x）$，那么$a[j]$号兔子 会跳到它当前坐标关于$x$的坐标的对称点。（注意，即使兔子的位置顺序变化了，但是编号仍保持不变，这里按兔子编号算）兔子会进行$k$轮跳跃，对每个兔子，请你求出它最后坐标的期望值。</p>
<span id="more"></span>

<p>当$k&#x3D;1$时，$a[i]&#x3D;\frac{1}{2}[a[i-1]-(a[i]-a[i-1])]+\frac{1}{2}[a[i+1]+(a[i+1]-a[i])]$</p>
<p>经过化简后$a[i]&#x3D;a[i+1]+a[i-1]-a[i]$,用差分数组表示就是:</p>
<p>$c[i]&#x3D;a[i]-a[i-1]$</p>
<p>$c[i]&#x3D;(a[i+1]+a[i-1]-a[i])-a[i-1]$</p>
<p>$c[i]&#x3D;a[i+1]-a[i]$</p>
<p>$c[i]&#x3D;c[i+1]$</p>
<hr>
<p>$c[i+1]&#x3D;a[i+1]-a[i]$</p>
<p>$c[i+1]&#x3D;a[i+1]-(a[i+1]+a[i-1]-a[i])$</p>
<p>$c[i+1]&#x3D;a[i]-a[i-1]$</p>
<p>$c[i+1]&#x3D;c[i]$</p>
<hr>
<p>然后我们发现一次运算就是把$c[i]$与$c[i+1]$交换，于是$k$轮跳转就相当于$k$次交换，然后利用类似快速幂的方法求解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100007</span>],c[<span class="number">100007</span>],v[<span class="number">100007</span>],t[<span class="number">100007</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)t[i]=c[v[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)c[i]=t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)t[i]=v[v[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)v[i]=t[i];</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">read</span>(),c[i]=a[i]-a[i<span class="number">-1</span>],v[i]=i;</span><br><span class="line">    <span class="type">int</span> m=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">swap</span>(v[x],v[x+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ksm</span>(k);</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        sum+=c[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 BZOJ2238 Mst</title>
    <url>/2019/06/08/%E9%A2%98%E8%A7%A3%20BZOJ2238%20Mst/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给出一个$N$个点$M$条边的无向带权图，以及$Q$个询问，每次询问在图中删掉一条边后图的最小生成树。(各询问间独立，每次询问不对之后的询问产生影响，即被删掉的边在下一条询问中依然存在)</p>
<span id="more"></span>


<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>我们先做好图的最小生成树。</p>
<p>如果删除的边不在最小生成树上，那答案就是最小生成树，直接输出即可。</p>
<p>此时要找能够代替删去的边的一条权值最小的边。用这条边代替删去的边后就是新的最小生成树了。</p>
<p>那怎么代替呢？</p>
<p>我们把最小生成树的样子画个图看看</p>
<p><img src="https://i.loli.net/2019/06/10/5cfe71d6bc3e227290.png"></p>
<p>再删去一条边</p>
<p><img src="https://i.loli.net/2019/06/10/5cfe71d6ac71c24500.png"></p>
<p>是不是就变成了两个部分</p>
<p>我们要找的就是所有能使两个连通块连通的非树边。这样的非树边就能够代替删去的边重新使树连通。</p>
<p>那怎么找一条权值最小的边$?$</p>
<p>现在反过来想，一条非树边可以代替哪些边$?$</p>
<p>一条非树边可以代替其两端点在树上的简单路径之间的所有边</p>
<p>画一下图即可，如果删去边不在简单路径上，那么删去边的两端一定在同一个部分(即无法在异侧)</p>
<p>然后对于每条非树边，用它的值去更新它两端点构成的简单路径上的边，用树链剖分优化复杂度</p>
<p>先预处理出最小生成树，然后将这棵最小生成树进行树链剖分，每一条边记录能够代替它的、权值最小的非树边的长度。对于每条非树边，利用树剖更新其两端点在树上的简单路径之间的所有边记录的最小值。查询时直接查询删除的边上存储的最小值即可。</p>
<p>实际代码可以将边的信息存在其儿子节点上，简化代码复杂度</p>
<p>有两种情况要特判$Not connected:$</p>
<p>   原图不连通，对于所有询问都输出$Not connected($树链剖分只是维护用其它边替换一条边的情况，如果原图不连通的话，不但生成树会建错，而且替换了边树也不连通$);$</p>
<p>   原图连通，但删去这条边后没有边能替它连通两个块，此时树链剖分上询问这条边所得到的值应该是没更新过的初值，即$inf$。因此判断这个询问值如果是$inf$就输出$Not connected$即可。</p>
<p>还有一些细节代码中有注释</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(k) (k&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(k) (k&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000600</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,d,id;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N],vis[N],num[N];</span><br><span class="line"><span class="type">int</span> cnt,head[N];</span><br><span class="line"><span class="type">int</span> mn[N],tag[N];</span><br><span class="line"><span class="type">int</span> size[N],fa[N],top[N],son[N],dep[N],id[N],a[N],tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[k]==k?k:f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d&lt;b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    mn[k]=<span class="built_in">min</span>(mn[<span class="built_in">ls</span>(k)],mn[<span class="built_in">rs</span>(k)]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    tag[k]=<span class="built_in">min</span>(tag[k],d);</span><br><span class="line">    mn[k]=<span class="built_in">min</span>(mn[k],d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">ls</span>(k),tag[k]);</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">rs</span>(k),tag[k]);</span><br><span class="line">    tag[k]=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tag[k]=mn[k]=inf;</span><br><span class="line">    <span class="keyword">if</span> (l==r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(k),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        <span class="built_in">add</span>(k,d);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tag[k]!=inf)<span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid)<span class="built_in">change</span>(<span class="built_in">ls</span>(k),l,mid,x,y,d);</span><br><span class="line">    <span class="keyword">if</span> (mid&lt;y) <span class="built_in">change</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r,x,y,d);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=l&amp;&amp;r&lt;=y)</span><br><span class="line">        <span class="keyword">return</span> mn[k];</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=inf;</span><br><span class="line">    <span class="keyword">if</span> (tag[k]!=inf)<span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid)res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(k),l,mid,x,y));</span><br><span class="line">    <span class="keyword">if</span> (mid&lt;y) res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r,x,y));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i]=i;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;cnt&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(p[i].u),y=<span class="built_in">find</span>(p[i].v);</span><br><span class="line">        <span class="keyword">if</span> (x==y)<span class="keyword">continue</span>;</span><br><span class="line">        f[x]=y;</span><br><span class="line">        <span class="built_in">Add</span>(p[i].u,p[i].v);</span><br><span class="line">        <span class="built_in">Add</span>(p[i].v,p[i].u);</span><br><span class="line">        ++cnt;res+=p[i].d;vis[p[i].id]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt!=n<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa[u])<span class="keyword">continue</span>;</span><br><span class="line">        dep[v]=dep[u]+<span class="number">1</span>;fa[v]=u;</span><br><span class="line">        <span class="built_in">dfs1</span>(v);</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">        <span class="keyword">if</span> (!son[u]||size[v]&gt;size[son[u]])son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u]=tp;</span><br><span class="line">    id[u]=++tot;</span><br><span class="line">    a[tot]=u;</span><br><span class="line">    <span class="keyword">if</span> (son[u])<span class="built_in">dfs2</span>(son[u],tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa[u]||v==son[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]]&lt;dep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x],d);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x]+<span class="number">1</span>,id[y],d);<span class="comment">//当前的x即使原先x,y两点的lca，由于边的权值存在子节点上，所以lca是不能取的 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=inf;</span><br><span class="line">    <span class="keyword">while</span> (top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]]&lt;dep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        res=<span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[x]],id[x]));</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x]+<span class="number">1</span>,id[y]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)p[i].u=<span class="built_in">read</span>(),p[i].v=<span class="built_in">read</span>(),p[i].d=<span class="built_in">read</span>(),p[i].id=i;</span><br><span class="line">    <span class="type">int</span> q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)num[p[i].id]=i;</span><br><span class="line">    <span class="type">int</span> res=<span class="built_in">Kr</span>();</span><br><span class="line">    <span class="keyword">if</span> (res==<span class="number">-1</span>)&#123;<span class="keyword">while</span> (q--)&#123;<span class="built_in">puts</span>(<span class="string">&quot;Not connected&quot;</span>);&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[p[i].id])</span><br><span class="line">            <span class="built_in">updata</span>(p[i].u,p[i].v,p[i].d);</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (!vis[k])&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="type">int</span> ans=<span class="built_in">query1</span>(p[num[k]].u,p[num[k]].v);</span><br><span class="line">        <span class="keyword">if</span> (ans==inf)<span class="built_in">puts</span>(<span class="string">&quot;Not connected&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res-p[num[k]].d+ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 51nod有限背包计数问题</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%2051nod%E6%9C%89%E9%99%90%E8%83%8C%E5%8C%85%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="http://www.51nod.com/Challenge/Problem.html#!#problemId=1597">题目链接</a></p>
<span id="more"></span>

<p>很考验对背包的理解</p>
<p>对于$1$<del>$sqrt(n)$与$(sqrt(n)+$$1)$</del>$n,$我们可以用NOIP2001数的划分的类似做法，分别处理，显然$1$<del>$sqrt(n)$是个多重背包问题，$(sqrt(n)+$$1)$</del>$n$是个完全背包问题</p>
<p>对于$1$~$sqrt(n)$，我们可以用总方案数减去不合法的方案数(具体见代码注释)，并利用滚存优化空间</p>
<p>对于$(sqrt(n)+$$1)$~$n,$我们可以用<a href="https://www.luogu.org/problemnew/show/P1025">NOIP2001数的划分</a>的类似做法，将划分分成两种类型，进行$dp$转移</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][<span class="number">393939</span>],g[<span class="number">319</span>][<span class="number">100007</span>],ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;game.in&quot;, &quot;r&quot;, stdin); freopen(&quot;game.out&quot;, &quot;w&quot;, stdout); </span></span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),mod=<span class="built_in">read</span>();</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//选0个的方案数为1 </span></span><br><span class="line">    <span class="type">int</span> sq=<span class="built_in">sqrt</span>(n),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sq;++i)&#123;</span><br><span class="line">        now^=<span class="number">1</span>;<span class="comment">//滚存 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            f[now][j]=f[now^<span class="number">1</span>][j];<span class="comment">//加上i-1的方案种数 </span></span><br><span class="line">            <span class="keyword">if</span> (j&gt;=i)f[now][j]+=f[now][j-i];<span class="comment">//完全背包方案数的递推式 </span></span><br><span class="line">            <span class="keyword">if</span> (f[now][j]&gt;=mod)f[now][j]-=mod;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;=i*(i+<span class="number">1</span>))f[now][j]=f[now][j]-f[now^<span class="number">1</span>][j-i*(i+<span class="number">1</span>)]+mod;<span class="comment">//减去不符合的方案数，即不在j-i*i到j范围内的方案数 </span></span><br><span class="line">            <span class="keyword">if</span> (f[now][j]&gt;=mod)f[now][j]-=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//前sqrt(n)个数进行多重背包计算方案 </span></span><br><span class="line"><span class="comment">//g[i][j]表示选了i个,而不是选到第i种，和为j的方案数，注意i的含义与f[i][j]中的i的含义不一样 </span></span><br><span class="line"><span class="comment">//类似NOIP2001数的划分的做法,所有划分成两种：</span></span><br><span class="line"><span class="comment">//1.包含sqrt(n)+1(即最小的数)</span></span><br><span class="line"><span class="comment">//2.不包含sqrt(n)+1的</span></span><br><span class="line"><span class="comment">//一个dp状态的方案数就是由这两种划分构成的</span></span><br><span class="line"><span class="comment">//对于第一种划分，只需要单独加上一份sqrt(n)+1即可，所以划分数等于f[i-1][j-(sqrt(n)+1)];</span></span><br><span class="line"><span class="comment">//对于第二种划分，只需要给当前每份都加上1，每份就不可能等于sqrt(n)+1了，因为最小就是sqrt(n)+1,所以划分数就等于f[i][j+i];</span></span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//选0个，和为0的方案数为1 </span></span><br><span class="line">    <span class="keyword">if</span> (sq+<span class="number">1</span>&lt;=n)g[<span class="number">1</span>][sq+<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//选1个sqrt(n)+1(最小值) </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sq;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j+sq+<span class="number">1</span>&lt;=n)g[i+<span class="number">1</span>][j+sq+<span class="number">1</span>]+=g[i][j];<span class="comment">//第一种划分 </span></span><br><span class="line">            <span class="keyword">if</span> (g[i+<span class="number">1</span>][j+sq+<span class="number">1</span>]&gt;=mod)g[i+<span class="number">1</span>][j+sq+<span class="number">1</span>]-=mod; </span><br><span class="line">            <span class="keyword">if</span> (j+i&lt;=n)g[i][j+i]+=g[i][j];<span class="comment">//第二种划分 </span></span><br><span class="line">            <span class="keyword">if</span> (g[i][j+i]&gt;=mod)g[i][j+i]-=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sq;++j)&#123;</span><br><span class="line">            ans+=<span class="number">1ll</span>*f[now][i]*g[j][n-i]%mod;<span class="comment">// 最后枚举多少空间给前sqrt(n)个物品(剩下空间给其它物品)</span></span><br><span class="line">            <span class="keyword">if</span> (ans&gt;=mod)ans-=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1073F Choosing Two Paths</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20CF1073F%20Choosing%20Two%20Paths/</url>
    <content><![CDATA[<p>题目大意：有一棵树，从中选取$2$条链，其中任何一条链的端点不能被另一条链包含，求这两条链，使这两条链的公共的点的部分最长，若相同，使得总长度最长。</p>
<span id="more"></span>

<p>因为其中任何一条链的端点不能被另一条链包含，所以重合线段的两个端点的度一定$\geqslant3($两条链的端点在这个节点处分开),在一棵树上要求公共部分最长，有点像求树的直径的做法，两遍$dfs$，特殊的是在更新答案时只有这个点度$\geqslant3$时才更新。</p>
<p>这道题还有个要求，在求公共部分最长的情况下还要使总长度最长</p>
<p>那我们就在$u$和$v$的子树中，找离根最远和次远的点即可。</p>
<p>为了保证求出的两个端点的子树中，“离根最远和次远的点到根距离之和”是最长的，所以在dfs的时候若两个点距离根同样远，则根据它们“离根最远和次远的点到根距离之和”的大小来判断即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,dis,next;</span><br><span class="line">&#125;e[<span class="number">500000</span>],e1[<span class="number">500000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wln</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> loc,ans,head[<span class="number">500000</span>],head1[<span class="number">500000</span>],dep[<span class="number">500000</span>],ind[<span class="number">500000</span>],f[<span class="number">500000</span>],g[<span class="number">500000</span>],cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,sum;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(node y,node z)&#123;</span><br><span class="line">        <span class="keyword">if</span> (z.x!=y.x)<span class="keyword">return</span> y.x&lt;z.x;</span><br><span class="line">        <span class="keyword">return</span> y.sum&lt;z.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mx;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    dep[u]=dep[fa]+<span class="number">1</span>;g[u]=f[u]=<span class="number">0</span>;<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;++cnt;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">if</span> (dep[f[v]]&gt;dep[f[u]])&#123;</span><br><span class="line">            g[u]=f[u];</span><br><span class="line">            f[u]=f[v];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (dep[f[v]]&gt;dep[g[u]])&#123;</span><br><span class="line">            g[u]=f[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cnt)f[u]=u;</span><br><span class="line">    <span class="keyword">if</span> (cnt&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        node x=&#123;dep[u],dep[f[u]]+dep[g[u]]-dep[u]*<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (mx&lt;x)&#123;</span><br><span class="line">            mx=x;</span><br><span class="line">            loc=u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    mx=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> a1=f[loc],b1=g[loc];</span><br><span class="line">    mx=&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(loc,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> a2=f[loc],b2=g[loc];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n%d %d\n&quot;</span>,a1,a2,b1,b2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1082G 【Petya and Graph】</title>
    <url>/2019/05/30/%E9%A2%98%E8%A7%A3%20CF1082G%20%E3%80%90Petya%20and%20Graph%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>定义图权$&#x3D;$图中边权总和$-$图中点权总和(空图的图权 $&#x3D;0$)，求$n$个点 $m$条边的无向图最大权子图。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>显然，你选了一条边就必须选它两端的两个点，想到了什么$?$</p>
<p>最大权闭合子图</p>
<p>有一个有向图，每一个点都有一个权值（可以为正或负或$0$），选择一个权值和最大的子图，使得每个点的后继都在子图里面，这个子图就叫最大权闭合子图。</p>
<p>这类问题如何解决$?$</p>
<p>从源点$s$向每个正权点连一条容量为权值的边，每个负权点向汇点$t$连一条容量为权值的绝对值的边，有向图原来的边容量全部为无限大。 </p>
<p>这道题同理，$s$向(每条边的编号)连上权值为(这条边的贡献)的边</p>
<p>每条边$e$的编号向$e$两端的节点编号连边权为$inf$的边</p>
<p>每个节点向$t$连边权为节点贡献的边</p>
<p>跑一遍最大流即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,w,to,next;</span><br><span class="line">&#125;e[<span class="number">1000067</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,cur[N],head[N],dep[N],vis[N],inque[N],cost,n,m,s,t,a[N],b[N],c[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;!dep[v])&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (e[i].dis&amp;&amp;dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                <span class="keyword">if</span> (mn==used)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">        res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),s=<span class="number">0</span>,t=n+m+<span class="number">1</span>;<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(i+m,t,<span class="built_in">read</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),d=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(i,u+m,inf);<span class="built_in">add</span>(i,v+m,inf);</span><br><span class="line">        <span class="built_in">add</span>(s,i,d);sum+=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum-<span class="built_in">Dinic</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最大权闭合子图</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 BZOJ4401</title>
    <url>/2019/10/09/%E9%A2%98%E8%A7%A3%20BZOJ4401/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>把一棵树分成几块，使得每个块中的点数都相同，问有多少种块的大小能满足该条件</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>考虑一个性质$:$对于一个块的大小$s,$当且仅当有$\frac{n}{s}$个节点的$size($即子树大小$)$为$s$ 的倍数。</p>
<p>证明$:$</p>
<p>假设$size$为$s$的倍数的节点为$a$节点</p>
<p>先证明一棵树中$a$节点的个数不会超过$\frac{n}{s}$个。采取反证法，假设一棵树中$a$节点有$\frac{n}{s}+1$个，那么我们可以先构造出一颗有$\frac{n}{s}+1($大于$\frac{n}{s}+1$个节点的情况可以以此类推$)$个节点的树，假设这些点都是$a$节点，然后通过加入$n-(\frac{n}{s}+1)$个点$($可以加在边上$)$来满足条件，不断找叶子节点，在它下面连一颗大小为$s-1$的树,然后我们可以删去这个节点和它的子树，因为它对上面的祖先$%s$的余数已经没有影响了。我们发现，对于每一个$a$节点，我们都需要$s-1$个新增节点。那么总的新增节点数就是$(\frac{n}{s}+1)\times (s-1)&#x3D;n-s-(\frac{n}{s}+1),$再加上原先的$a$节点数即总节点数为$n+s&gt;n$，所以一棵树中$a$节点的个数不会超过$\frac{n}{s}$个。</p>
<p>再证明为什么有$\frac{n}{s}$个$a$节点就可以构造，我们只需要每次找到一个$size&#x3D;&#x3D;s$的$a$节点然后将它和它的子树分成一个块然后在树上删除这个块即可。每次至少能找出一个$size&#x3D;&#x3D;s$的$a$节点。因为如果每个$a$节点的$size$都至少为$2\times s,$那么假设$a$节点的$size$最小为$2\times s($大于$2\times s$的可以以此类推$),$那么删去这个$size&#x3D;&#x3D;2\times s$的节点和它的子树，那么剩下的树的$a$节点数不会超过$\frac{n-2\times s}{s}$个，再加上这个删去的节点，$a$节点的数量只有$\frac{n}{s}-1$个所以每次至少能找出一个$size&#x3D;&#x3D;s$的$a$节点，也就可以顺利构造了。</p>
<p>小于$\frac{n}{s}$个$a$节点用上面的构造方法模拟一下就知道显然不可行$($没有$size&#x3D;&#x3D;s$的$a$节点你是没办法继续分块的$)$。</p>
<p>然后就很无脑了，先$dfs$求出每个点的$size,$然后全扔桶里面，然后从$1\sim n$枚举块的大小，$O(\frac{n}{i})$计算$a$节点的个数。</p>
<p>复杂度就是调和级数$O(nlogn)$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1002302</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,head[N],size[N],n,ma[N],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)++ma[size[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=n;j+=i)</span><br><span class="line">                res+=ma[j];</span><br><span class="line">            ans+=(res==n/i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>调和级数</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1009E 【Intercity Travelling】</title>
    <url>/2019/10/13/%E9%A2%98%E8%A7%A3%20CF1009E%20%E3%80%90Intercity%20Travelling%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>你要从$A$到$B$，需要走$n$步。若你已走了$s$步，那么你再走一步的代价将为$a[s+1]$。</p>
<p>在走完每一步后有$\frac{1}{2}$的概率休息，休息后$s$将变为$0$。</p>
<p>求出你从$A$到$B$的代价的期望$p$乘上$2^{n-1}$对$998244353$取模的结果。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>由于乘了$2^{n-1},$所以答案即是所有情况走的代价之和</p>
<p>考虑一个复杂度为$O(n^2)$的$dp,$设$f[i]$表示走了$i$步后的答案。</p>
<p>显然，$f[i]&#x3D;\sum\limits_{i&#x3D;1}^{i-1}(f[j]+2^{j-1}\times sum_{i-j})+sum_i$</p>
<p>然后发现这个式子很难优化所以对它进行推导</p>
<p>$f[i]&#x3D;\sum\limits_{j&#x3D;1}^{i-1}(f[j]+2^{j-1}\times sum[i-j])+sum[i]$</p>
<p>$f[i]&#x3D;(\sum\limits_{j&#x3D;1}^{i-1}f[j])+[\sum\limits_{j&#x3D;1}^{i-1}(2^{j-1}\times sum_[i-j])]+sum[i]$</p>
<p>$f[i]&#x3D;(\sum\limits_{j&#x3D;1}^{i-1}f[j])+[\sum\limits_{j&#x3D;1}^{i-1}(sum[j]\times2^{i-1-j})]+sum[i]$</p>
<p>$f[i]&#x3D;(\sum\limits_{j&#x3D;1}^{i-1}f[j])+[\sum\limits_{j&#x3D;1}^{i-1}(a[i]\times\sum\limits_{k&#x3D;0}^{i-1-j}2^k)]+sum[i]$</p>
<p>$f[i]&#x3D;(\sum\limits_{j&#x3D;1}^{i-1}f[j])+\sum\limits_{j&#x3D;1}^{i-1}[a[i]\times (2^{i-j}-1)]+sum[i]$</p>
<p>$f[i]&#x3D;(\sum\limits_{j&#x3D;1}^{i-1}f[j])+\sum\limits_{j&#x3D;1}^{i-1}[a[i]\times 2^{i-j}]-sum[i-1]+sum[i]$</p>
<p>$f[i]&#x3D;(\sum\limits_{j&#x3D;1}^{i-1}f[j])+\sum\limits_{j&#x3D;1}^{i-1}[a[i]\times 2^{i-j}]+a[i]$</p>
<p>$f[i]&#x3D;(\sum\limits_{j&#x3D;1}^{i-1}f[j])+\sum\limits_{j&#x3D;1}^{i}[a[i]\times 2^{i-j}]$</p>
<p>设$g[i]&#x3D;\sum\limits_{j&#x3D;1}^{i-1}f[j],h[i]&#x3D;\sum\limits_{j&#x3D;1}^{i}[a[i]\times 2^{i-j}]$</p>
<p>$g[i]&#x3D;g[i-1]+f[i],h[i]&#x3D;h[i-1]\times 2+a[i]$</p>
<p>然后就可以无脑递推了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,x,h,f,g;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        x=<span class="built_in">read</span>();</span><br><span class="line">        h=((h&lt;&lt;<span class="number">1</span>)+x)%mod;f=(g+h)%mod;g=(g+f)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1085D Minimum Diameter Tree</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20CF1085D%20Minimum%20Diameter%20Tree/</url>
    <content><![CDATA[<p>题意:给你一棵$N$个点的树，和一个正整数$s$。</p>
<p>现在让你在这棵树上给$N-1$条边分配边权，使得这棵树的直径最小。</p>
<p>输出最小的直径。</p>
<p>保证$2\leqslant n\leqslant 100000,1\leqslant s\leqslant10^9$。</p>
<p>你的答案是正确的当且仅当与标准答案的绝对误差或相对误差不超过$10^{-6}$。</p>
<span id="more"></span>

<p>树的直径的两个端点一定是叶子节点(当边权都为正时)，这个结论显然；</p>
<p>将每一条边分成两类，一类为叶子节点连接的边，设为$a$，另一类为没有叶子节点连接的边，设为$b$；</p>
<p>对于$b$，我们希望每条$b$对直径贡献尽量小，因为两条可能成为直径的边可能同时包含了$b$。所以将所有$b$的值设为$0$；</p>
<p>根据这个结论，我们将所有$s$均摊给每条$a$；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,r[<span class="number">300000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        ++r[u];++r[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (r[i]==<span class="number">1</span>)</span><br><span class="line">            ++cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.18lf&quot;</span>,<span class="number">2</span>*m*<span class="number">1.0</span>/(cnt*<span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树相关</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1019D 【Large Triangle】</title>
    <url>/2019/06/13/%E9%A2%98%E8%A7%A3%20CF1019D%20%E3%80%90Large%20Triangle%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给出$N$个点，是否存在$3$个点，它们组成的三角形面积为$S$。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>如果确定了三角形的一条边，我们可以将整个坐标系旋转一下，使这条边成为新的$y$轴，这时候我们只要分别对$y$轴的两边分别进行二分即可</p>
<p>我们发现：可以先预处理一下每两个点之间的直线，记录一下起点终点和斜率。</p>
<p>首先所有点按$x$坐标从小到大排序。然后对直线进行极角排序。</p>
<p>当我们处理到直线$AB$时,$AB$就成为了$y$轴，且$A,B$是相邻的(它们距离$y$轴距离都为$0)($假设$A$位置在$B$的上面）.然后到下一条直线时，由于斜率从小到大，所以是把整个图顺时针旋转了一点点，直到下一条直线成为$y$轴。那么这个时候把$A,B$在序列中的位置交换一下就行了。因为如果有别的点对相对顺序改变，那么这个点对的斜率一定介于这两条直线之间。下面口胡一下。</p>
<p><img src="https://img-blog.csdn.net/20181019081202296?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2cyMXdjcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>假设现在我们以$l_1$为$y$轴。有一组点对，$P$和$Q$，它们相对于$l_1$的横坐标分别是$a$和$b$，其中$a&lt;b$。</p>
<p>然后我们看到比$l_1$斜率更小的第一条直线$l_2$。首先，可以保证，$A$和$B$一定在直线$l_2$的同侧。因为如果$A$和$B$在$l_2$的异侧，那$ABCD$这四个点一定可以生成一条斜率介于$l_1$和$l_2$之间的直线(画一画就知道了)，而我们是把斜率排了序，保证了不会有这种情况出现。现在，将整个图再顺时针旋转一点点，使$l_2$成为新的y轴。那么可以保证，$A$和$B$的相对顺序一定是改变了的，而且是把$A$和$B$的排位交换了一下。(可以脑补一下$AB$在$CD$下侧的情况，是同理的).这时候，我们看到$PQ$，在新的y轴下，$P$的横坐标是$c,Q$的横坐标是$d$，假设$c&gt;d$，那么$PQ$的斜率一定比$l_2$的斜率要大，因为$PQ$逆时针旋转一点点就与$l_2$平行。</p>
<p>对于旋转过后排位会变化的点对(除$AB$外)，一定会满足$PQ$的条件$:a&lt;b$且$c&gt;d$。但是我们发现它的斜率介于$l_1$和$l_2$之间，然鹅比$l_1$斜率更小的第一条直线是$l_2$，不是$PQ$，与前提矛盾，所以不存在这样的$PQ$。</p>
<p>那么就可以保证从$l_1$旋转到$l_2$时，受影响的就只有$l_1$上的两个点。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 40000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 4000500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-4</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">friend</span> point <span class="keyword">operator</span> -(point a,point b)&#123;</span><br><span class="line">        <span class="keyword">return</span> (point)&#123;a.x-b.x,a.y-b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">int</span> <span class="keyword">operator</span> ^(point a,point b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(a.x*b.y-b.x*a.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;a[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x!=b.x)<span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d&lt;b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">area</span><span class="params">(point a,point b,point c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(((b-a)^(c-a)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,id[N],pos[N],tot,S;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();S=<span class="built_in">read</span>()*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)p[i].x=<span class="built_in">read</span>(),p[i].y=<span class="built_in">read</span>(),id[i]=pos[i]=i;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>+i;j&lt;=n;++j)</span><br><span class="line">            a[++tot]=(node)&#123;i,j,<span class="built_in">atan2</span>((<span class="type">double</span>)(p[j]-p[i]).y,(<span class="type">double</span>)(p[j]-p[i]).x)&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+tot,cmp1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=a[i].u,y=a[i].v;</span><br><span class="line">        <span class="keyword">if</span> (pos[x]&gt;pos[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=pos[x]<span class="number">-1</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">area</span>(p[id[mid]],p[x],p[y])&gt;=S)ans=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">area</span>(p[id[ans]],p[x],p[y])==S)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n%lld %lld\n%lld %lld\n&quot;</span>,p[id[ans]].x,p[id[ans]].y,p[x].x,p[x].y,p[y].x,p[y].y);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l=pos[y]+<span class="number">1</span>,r=n,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">area</span>(p[id[mid]],p[x],p[y])&gt;=S)ans=mid,r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">area</span>(p[id[ans]],p[x],p[y])==S)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n%lld %lld\n%lld %lld\n&quot;</span>,p[id[ans]].x,p[id[ans]].y,p[x].x,p[x].y,p[y].x,p[y].y);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(pos[x],pos[y]);</span><br><span class="line">        <span class="built_in">swap</span>(id[pos[x]],id[pos[y]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>极角排序</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF24D 【Broken robot】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20CF24D%20%E3%80%90Broken%20robot%E3%80%91/</url>
    <content><![CDATA[<span id="more"></span>

<p>设状态$f[i][j]$为从坐标$(i,j)$走到最后一行的期望</p>
<p>此时需要分类讨论,由于$f[n]<a href="1%3C=j%3C=m">j</a>&#x3D;0$，所以我们倒着枚举行,也可感性理解为从最后一行走到第x行</p>
<p>当$j&#x3D;1$时，$f[i][1]&#x3D;\frac{1}{3}f[i][1]+\frac{1}{3}f[i][2]+\frac{1}{3}f[i+1][1]+1$</p>
<p>当$j&#x3D;m$时，$f[i][m]&#x3D;\frac{1}{3}f[i][m]+\frac{1}{3}f[i][m-1]+\frac{1}{3}f[i+1][m]+1$</p>
<p>当$1&lt;j&lt;m$时，$f[i][j]&#x3D;\frac{1}{4}f[i][j-1]+\frac{1}{4}f[i][j]+\frac{1}{4}f[i][j+1]+\frac{1}{4}f[i+1][j]+1$</p>
<p>然后我们发现这个式子是有后效性的，所以要$dp+$高斯消元。</p>
<p>为了更好高斯消元，我们可以压掉第一维，式子中的$f[i+1]$计为数组$last$。(但我实现上还是用了两维)</p>
<p>经过移项化简后得到：</p>
<p>当$j&#x3D;1$时，$2f[1]-f[2]&#x3D;last[i] + 3$</p>
<p>当$j&#x3D;m$时，$-f[m-1]+2f[m]&#x3D;last[m]+3$</p>
<p>当$1&lt;j&lt;m$时，$-f[j-1]+3f[j]-f[j+1]&#x3D;last[j]+4$</p>
<p>由于是倒着枚举，所以$last$数组在转移前已经知道了，这就完全是个高斯消元的式子了，用矩阵表示就会变成下面这个样子</p>
<p>$\begin{bmatrix}2\ &amp;-1\ &amp;0\ &amp;0\ &amp;0\-1\ &amp;3\ &amp;-1\ &amp;0\ &amp;0\0 &amp;-1\ &amp;3\ &amp;-1\ &amp; 0\0\ &amp;0\ &amp;-1\ &amp;3\ &amp;-1\0\ &amp;0\ &amp;0\ &amp;-1\ &amp;2\end{bmatrix}$ </p>
<p>用高斯消元显然会T，但是我们发现每行最多只有$3$个非$0$元素,所以我们可以暴力模拟高斯消元求解,最后答案就是$f[x][y]$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> f[<span class="number">1007</span>][<span class="number">1007</span>],a1[<span class="number">1007</span>],a2[<span class="number">1007</span>],a3[<span class="number">1007</span>],c[<span class="number">1007</span>];</span><br><span class="line"><span class="comment">//c数组为方程组&#x27;=&#x27;右边的值，a1,a2,a3分别表示一行中三个元素的值，f数组即为转移数组</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span> (m==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,<span class="number">2.0</span>*(n-x));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=x;--i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)c[j]=f[i+<span class="number">1</span>][j]+<span class="number">4.0</span>;</span><br><span class="line">        c[<span class="number">1</span>]-=<span class="number">1.0</span>;c[m]-=<span class="number">1.0</span>;</span><br><span class="line">        a1[<span class="number">1</span>]=<span class="number">0</span>;a2[<span class="number">1</span>]=<span class="number">2.0</span>;a3[<span class="number">1</span>]=<span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m<span class="number">-1</span>;++j)a1[j]=<span class="number">-1</span>,a2[j]=<span class="number">3</span>,a3[j]=<span class="number">-1</span>;</span><br><span class="line">        a1[m]=<span class="number">-1</span>;a2[m]=<span class="number">2</span>;a3[m]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m;++j)&#123;</span><br><span class="line">            <span class="type">double</span> z=a1[j]/a2[j<span class="number">-1</span>];</span><br><span class="line">            a2[j]-=z*a3[j<span class="number">-1</span>];</span><br><span class="line">            c[j]-=c[j<span class="number">-1</span>]*z;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i][m]=c[m]/a2[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=m<span class="number">-1</span>;j;--j)f[i][j]=(f[i][j+<span class="number">1</span>]+c[j])/a2[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,f[x][y]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>概率期望$DP$</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1155D 【Beautiful Array】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20CF1155D%20%E3%80%90Beautiful%20Array%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给定一个值$x$,一个长度为$n$的数组$a$，你可以选择一段区间，让这段区间每个数都乘上$x$,求最大连续子段和</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution:$"></a>$Solution:$</h2><p>三个数组,$f_{i}$表示以$i$结尾的最大子段和,$g_{i}$表示选定区间还未完结($a_{i}$乘上$x$)的最大子段和，$h_{i}$表示已经选定区间已经在$1$~$(i-1)$中一处结尾$(a_{i}$不乘$x)$</p>
<p> $f_{i}&#x3D;max(f_{i-1},0)+a_{i}$</p>
<p> $g_{i}&#x3D;max(g_{i-1},f_{i-1},0)+a_{i}\times x$</p>
<p> $h_{i}&#x3D;max(h_{i-1},g_{i-1},0)+a_{i}$</p>
<p> $ans&#x3D;max(h_{i},g_{i})$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),ans=<span class="number">0</span>,a,f=<span class="number">0</span>,g=<span class="number">0</span>,h=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        a=<span class="built_in">read</span>(),h=<span class="built_in">max</span>(h,<span class="built_in">max</span>(g,<span class="number">0ll</span>))+a,g=<span class="built_in">max</span>(g,<span class="built_in">max</span>(<span class="number">0ll</span>,f))+a*m,f=<span class="built_in">max</span>(f,<span class="number">0ll</span>)+a,ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(h,<span class="built_in">max</span>(f,g)));</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1132E 【Knapsack】</title>
    <url>/2019/06/11/%E9%A2%98%E8%A7%A3%20CF1132E%20%E3%80%90Knapsack%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>你有一个容量为$W$的背包，和$8$种物品，重量分别为$1\sim 8$的整数，分别有$cnt_1,cnt_2\cdots cnt_8$ 个。<br>求背包中最多能装上多大的重量。</p>
<span id="more"></span>


<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>由于$W$很大，我们首先可以选出一些肯定会放在最终背包里面的物品，我们假设把背包分成很多个容量为$840$的背包，我们可以知道的是，每种物品都可以单独装满这个背包，因为$840$是$1\sim 8$的最小公倍数，之后我们只要把所有能凑成的$840$的物品丢进最终的答案，最后每种物品剩余的个数肯定是$&lt;840$的，最后这些物品的总重量是小于$840\times8$的，我们只需要用一个容量为$840\times8$的背包对剩下的这些物品进行背包就可以了。</p>
<p>若要对第$i$种物品选$c_i$个，那么把$c_i$分解成$\frac{L}{i}\times p_i+q_i(0\leqslant q_i &lt;\frac{L}{i})$</p>
<p>具体实现时把最后剩下的物品当作容量，把$p_i$当成价值</p>
<p>最后统计取$max$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 600600</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">840</span>,n=<span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[N],f[<span class="number">10</span>][N],ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> W=<span class="built_in">read</span>(),res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		c[i]=<span class="built_in">read</span>();</span><br><span class="line">		res+=c[i]*i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (res&lt;=W)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> mx=<span class="built_in">min</span>(c[i],L/i);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=L*n;++j)</span><br><span class="line">			<span class="keyword">if</span> (f[i<span class="number">-1</span>][j]!=<span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;=mx;++k)</span><br><span class="line">					f[i][j+k*i]=<span class="built_in">max</span>(f[i][j+k*i],f[i<span class="number">-1</span>][j]+(c[i]-k)/(L/i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="built_in">min</span>(W,L*n);++i)</span><br><span class="line">		<span class="keyword">if</span> (f[n][i]!=<span class="number">-1</span>)</span><br><span class="line">			ans=<span class="built_in">max</span>(ans,i+L*<span class="built_in">min</span>(f[n][i],(W-i)/L));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF117C Cycle</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20CF117C%20Cycle/</url>
    <content><![CDATA[<p>题目大意：给定一个竞赛图(有向完全图，从数据保证$map[i][i]&#x3D;0$，$map[i][j]≠map[j][i]$。可以看出)，找出一个长度为$3$的环。</p>
<span id="more"></span>

<p>竞赛图的重要性质：</p>
<p><strong>竞赛图没有自环，没有二元环；若竞赛图存在环，则一定存在三元环。</strong></p>
<p>前半句话浅显易懂，后半句话的意思就是说：竞赛图要么没有环，如果存在一个环大于三元，那么一定存在另一个三元的小环。</p>
<p>简单证明：<br>假设一个竞赛图存在一个$N$元环(大于三元),环上有连续三点$A,B,C$(存在有向边$AB,BC)$</p>
<p>根据竞赛图的定义，一定存在有向边$CA$或$AC$中的一者。</p>
<p>情况$1:$若存在$CA,$则$A,B,C$构成三元环；</p>
<p>情况$2:$若存在$AC$，不考虑$B$点，剩下的点构成一个$(N-1)$元环。显然，如果一直不存在情况$1$的话，最终也会形成一个三元环。</p>
<p>下面用类似$dfs$的$tanjan$寻找</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="type">char</span> s[<span class="number">5005</span>];</span><br><span class="line"><span class="type">int</span> n,low[<span class="number">39393</span>],col,flag,in[<span class="number">39393</span>],dfn[<span class="number">39393</span>],st[<span class="number">39393</span>],w[<span class="number">39393</span>],t[<span class="number">39393</span>],tot,vis[<span class="number">39393</span>],top,num;</span><br><span class="line"><span class="type">bool</span> a[<span class="number">5005</span>][<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (in[u]&amp;&amp;st[top]!=u)&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (st[top]!=u)t[++tot]=st[top--];</span><br><span class="line">        t[++tot]=u;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vis[u])<span class="keyword">return</span>;</span><br><span class="line">    st[++top]=u;in[u]=vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;++v)</span><br><span class="line">        <span class="keyword">if</span> (a[u][v])</span><br><span class="line">            <span class="built_in">Tarjan</span>(v);</span><br><span class="line">    --top;</span><br><span class="line">    in[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">           <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">               <span class="keyword">if</span> (s[j]==<span class="string">&#x27;1&#x27;</span>)a[i][j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])<span class="built_in">Tarjan</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (!flag)&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">3</span>;j&lt;=tot;++j)</span><br><span class="line">        <span class="keyword">if</span> (a[t[<span class="number">1</span>]][t[j]])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,t[<span class="number">1</span>],t[j],t[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="comment">//如果枚举到j，说明之前有一条j-1到1的有向边，因为如果有1到j-1的有向边，之前程序就该结束了，不可能循环到j</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,t[<span class="number">1</span>],t[tot],t[tot<span class="number">-1</span>]);<span class="comment">//单独特判</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>竞赛图</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF366C 【Dima and Salad】</title>
    <url>/2019/05/25/%E9%A2%98%E8%A7%A3%20CF366C%20%E3%80%90Dima%20and%20Salad%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有$n$个水果,每个水果有两个属性：美味值和卡路里值。现在选用若干个（至少$1$个）水果制作一份特殊的沙拉，沙拉的美味值为所选的水果的美味值的和，沙拉的卡路里值为所选水果的卡路里值的和。要保证沙拉的美味值恰好是卡路里值的$K$倍。请计算该沙拉美味值最大为多少。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>根据题意可得$\sum a_{i}-k\times\sum b_{i}&#x3D;0$</p>
<p>所以我们考虑将$a_{i}$作为价值，$a_{i}-k\times b_{i}$作为重量，进行背包转移即可，由于重量有可能是负数，所以应用$map$存储转移数组或是将下标强行加上一个大数。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 30007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N],v[N],f[<span class="number">200</span>][N],g[<span class="number">200</span>][N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>(),m=<span class="number">100</span>*n;<span class="built_in">memset</span>(f,<span class="number">-0x7f</span>,<span class="built_in">sizeof</span>(f));<span class="built_in">memset</span>(g,<span class="number">-0x7f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)v[i]=a[i]-<span class="built_in">read</span>()*k;</span><br><span class="line">    f[<span class="number">0</span>][m]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>*m;++j)</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-v[i]]+a[i]);</span><br><span class="line">    cout&lt;&lt;(f[n][m]!=<span class="number">0</span>?f[n][m]:<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>背包</tag>
        <tag>巧妙转化</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1175E 【Minimal Segment Cover】</title>
    <url>/2019/06/20/%E9%A2%98%E8%A7%A3%20CF1175E%20%E3%80%90Minimal%20Segment%20Cover%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给出$n$个形如$[l,r]$的线段。$m$次询问，每次询问区间$[x,y],$问至少选出几条线段，使得区间$[x,y]$的任何一个部位都被至少一条线段覆盖。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>考虑贪心，首先设询问区间为$[x,y],$你选的所有$[l,r]$中最左边的一个$l$必然$\leqslant x($有且仅有一个$),$所以对于这个区间，它对答案的贡献取决于它的$r,$所以我们希望它在满足$l\leqslant x$的情况下$~r$更大，那么取完第一个这个问题就变成了一个$[r+1,y]$的子问题了，直到选取的$r\geqslant y$为止。</p>
<p>但是这个复杂度是$O(nm),$考虑倍增，每次向右跳$2^i$条线段，那么复杂度就变成$O(n<del>log</del>m)$了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 560000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,to[N],f[N][<span class="number">22</span>],mx;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        to[x]=<span class="built_in">max</span>(to[x],y); </span><br><span class="line">        mx=<span class="built_in">max</span>(mx,y); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=mx;++i)f[i][<span class="number">0</span>]=to[i]=<span class="built_in">max</span>(to[i],to[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=mx;++i)</span><br><span class="line">            f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (f[x][i]&lt;y&amp;&amp;f[x][i]&gt;x)</span><br><span class="line">                x=f[x][i],ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (to[x]&gt;=y)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF453C 【Little Pony and Summer Sun Celebration】</title>
    <url>/2019/07/31/%E9%A2%98%E8%A7%A3%20CF453C%20%E3%80%90Little%20Pony%20and%20Summer%20Sun%20Celebration%E3%80%91/</url>
    <content><![CDATA[<h2 id="Desciption"><a href="#Desciption" class="headerlink" title="$Desciption$"></a>$Desciption$</h2><p>给一个无向图$,n$个点$m$条边，给定一个$01$序列，如果$a[i]&#x3D;1,$要求走到这个点奇数次$,$否则，要求走到这个点偶数次$,$请你任选起点$,$输出满足要求的经过点的序列和序列长度$,$序列长度不能超过$4n$</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>先判断是否有解，如果图不连通，且两个块中都有要求走过奇数次的点，就无解。</p>
<p>我们可以将$a$序列作为初始状态，每经过一次$i$号点，相当于$a[i]~\hat{}&#x3D;1,$目标是使$a$序列全部变成$0$</p>
<p>选定一个要求走过奇数次的点作为$root,$每个点只走一次，最后回到$root,$那么走过的就是一棵树。</p>
<p>走的路程就相当于对这棵树进行$dfs$遍历，注意:回溯的过程也算一次经过.<br>所以叶子节点只经过一次，其它节点经过$($儿子数量$+1)$次,</p>
<p>对于一个点，在回溯时，如果$a[i]$还是1，就要进行震荡操作，震荡操作是指对于点$i$回溯到$fa[i]$时，从$fa[i]$走到$i$再走回$fa[i]$的过程，经过这一操作，效果是$a[i]<del>\hat{}&#x3D;1,a[fa[i]]</del>\hat{}&#x3D;1$</p>
<p>如果$root$需要震荡,我们可以不回溯到$root$，这样就相当于$a[root]^&#x3D;1$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 405400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s,ans[N],vis[N],tot,d[N],n,m,head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    ans[++tot]=u;vis[u]=<span class="number">1</span>;d[u]^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);ans[++tot]=u;d[u]^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[u])&#123;</span><br><span class="line">        ans[++tot]=fa;ans[++tot]=u;d[fa]^=<span class="number">1</span>;d[u]^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        d[i]=<span class="built_in">read</span>();<span class="keyword">if</span> (d[i])s=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (d[i])&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (tot&gt;<span class="number">1</span>&amp;&amp;!ans[tot<span class="number">-1</span>])tot-=<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树相关</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF519E A and B and Lecture Rooms</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20CF519E%20A%20and%20B%20and%20Lecture%20Rooms/</url>
    <content><![CDATA[<p>题意：有棵大小为$n$的树，再给出m次询问，每次询问中包含$A,B$两点，我们要找到离$A,B$两点距离相等的点一共有多少个。</p>
<span id="more"></span>

<p>需要对$A,B$之间的距离进行分类讨论：</p>
<p>一.如果询问的两个点之间的距离为奇数(或者之间的点为偶数)，那么无论怎样，它们之间必然有偶数个点，不可能有点到它们的距离相等。</p>
<p>二.如果询问的两个点之间的距离为偶数时，我们要找到$A,B$之间的中点，这个时候又需要分几个情况</p>
<p>{</p>
<p>$1.A,B$两点到他们的$LCA$的距离不相等（包括$A,B$两点中其中一个点为另一个点的$LCA$的情况），那么我们需要找到$A,B$两点所在链上的中点，中点与它不包含所询问点的子树上的点都是满足条件的点</p>
<p>$2.A,B$两点到他们的$LCA$之间距离相等时，满足条件的点的个数即是整棵树的上节点的总数减去$LCA$包含所询问两点的子树的节点个数</p>
<p>}</p>
<p>三.$A,B$两点重合时，整颗树上的点到这两个点的距离都可以看做相等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[<span class="number">300000</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wln</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot,size[<span class="number">300000</span>],head[<span class="number">300000</span>],cnt,fa[<span class="number">300000</span>],dep[<span class="number">300000</span>],son[<span class="number">300000</span>],top[<span class="number">300000</span>],w[<span class="number">300000</span>],p[<span class="number">3000000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (fa[u]==v)<span class="keyword">continue</span>;</span><br><span class="line">        fa[v]=u;dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v);</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">        <span class="keyword">if</span> (!son[u]||size[v]&gt;size[son[u]])</span><br><span class="line">            son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u]=tp;w[u]=++tot;p[tot]=u;</span><br><span class="line">    <span class="keyword">if</span> (son[u])<span class="built_in">dfs2</span>(son[u],tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa[u]||v==son[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]]&gt;dep[top[y]])</span><br><span class="line">            x=fa[top[x]];</span><br><span class="line">        <span class="keyword">else</span> y=fa[top[y]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&gt;dep[y]?y:x;</span><br><span class="line">&#125;<span class="comment">//以上是树剖求LCA板子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_mid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> lca,<span class="type">int</span> len,<span class="type">int</span> far)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x]-dep[lca]&lt;len)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(x,y);</span><br><span class="line">        len=far-len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x!=lca&amp;&amp;len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="type">int</span> net=top[x];</span><br><span class="line">         <span class="keyword">if</span> (w[x]-w[net]+<span class="number">1</span>&lt;=len)len-=w[x]-w[net]+<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">return</span> p[w[x]-len];</span><br><span class="line">         x=fa[net];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;<span class="comment">//找mid这里应该用倍增，但是写了一种自己都看不懂的算法qwq</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();<span class="type">int</span> m=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> lca=<span class="built_in">LCA</span>(x,y);</span><br><span class="line">        <span class="type">int</span> far=(dep[x]+dep[y]-dep[lca]*<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> mid=<span class="built_in">find_mid</span>(x,y,lca,far/<span class="number">2</span>,far);</span><br><span class="line">        <span class="type">int</span> midl=<span class="built_in">find_mid</span>(x,y,lca,far/<span class="number">2</span><span class="number">-1</span>,far);</span><br><span class="line">        <span class="type">int</span> midr=<span class="built_in">find_mid</span>(y,x,lca,far/<span class="number">2</span><span class="number">-1</span>,far);</span><br><span class="line">        <span class="keyword">if</span> (far&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x==y)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (dep[midl]==dep[midr])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-size[midl]-size[midr]);    </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,size[mid]-(dep[midl]&gt;dep[midr]?size[midl]:size[midr]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>树相关</tag>
        <tag>$LCA$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF292D 【Connected Components】</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20CF292D%20%E3%80%90Connected%20Components%E3%80%91/</url>
    <content><![CDATA[<p>题意<br>一个无向图，给出$m$条边，有$k$次询问，每次询问将第$l_{i}$到$r_{i}$条边<strong>暂时</strong>删去，求这时候有多少个连通分量.$N\leqslant500,1\leqslant M,K\leqslant10000$</p>
<span id="more"></span>

<p>每次暴力建边(即建$1$ ~ $(l_{i}-1),(r_{i}+1)$ ~ $m$这些边)，用并查集维护的思路很好想，复杂度为$O(mk)$, 在卡常或是手动$O3$的情况下可以跑过，但并不是最优解。</p>
<p>我们发现很多边重复建了很多次，没有意义，于是我们只需要预处理出$1$ ~ $l_{i}$这些边连起来得到的并查集与$r_{i}$~$n$这些边连起来得到的并查集，将其合并，求出联通快即可。</p>
<hr>
<p>难点：如何合并？</p>
<p>我们可以将左边i条边所得的并查集$l_{i}$直接复制到现在一个的并查集$f$中，然后，我们将现在正在处理的并查集中的每个元素和连右边$j$条边的并查集$r_{j}$的元素一一合并，得到一个新的并查集，这个新的并查集中集合的元素就是答案(统计有多少$f_{i}&#x3D;i$即可)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">10005</span>],l[<span class="number">10005</span>][<span class="number">505</span>],r[<span class="number">10005</span>][<span class="number">505</span>],x[<span class="number">10005</span>],y[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find1</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l[i][k]==k)<span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> l[i][k]=<span class="built_in">find1</span>(i,l[i][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find2</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r[i][k]==k)<span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> r[i][k]=<span class="built_in">find2</span>(i,r[i][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k)<span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;<span class="comment">//三个数组的并查集操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">        l[<span class="number">0</span>][j]=j,r[m+<span class="number">1</span>][j]=j;<span class="comment">//预处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        x[i]=<span class="built_in">read</span>(),y[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)l[i][j]=l[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find1</span>(i,x[i]),w=<span class="built_in">find1</span>(i,y[i]);</span><br><span class="line">        <span class="keyword">if</span> (u!=w)l[i][u]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=m;i;--i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)r[i][j]=r[i+<span class="number">1</span>][j];</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">find2</span>(i,x[i]),w=<span class="built_in">find2</span>(i,y[i]);</span><br><span class="line">        <span class="keyword">if</span> (u!=w)r[i][u]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="type">int</span> l1=<span class="built_in">read</span>(),r1=<span class="built_in">read</span>(),cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i]=l[l1<span class="number">-1</span>][i];<span class="comment">//将l数组[l1-1]数组复制给f数组        </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)f[<span class="built_in">find</span>(l[l1<span class="number">-1</span>][j])]=<span class="built_in">find</span>(r[r1+<span class="number">1</span>][j]);<span class="comment">//合并两个并查集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (f[j]==j)</span><br><span class="line">                ++cnt;<span class="comment">//统计答案</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF490F 【Treeland Tour】</title>
    <url>/2019/07/31/%E9%A2%98%E8%A7%A3%20CF490F%20%E3%80%90Treeland%20Tour%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给定一棵带点权树，求树上最长上升子序列的长度</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>以下的$lis$和$lds$均表示从当前点$u$的某个子树节点权值为开头$,w_u$为结尾的$lis$或$lds,m$表示所有节点中最大的权值</p>
<p>对于每个点维护一棵动态开点权值线段树，线段树中下标$i$存储以$<del>i</del>$这个数为结尾的$lis$和$~lds($最长上升子序列和最长下降子序列$),$利用线段树合并更新</p>
<p>那么如何更新答案呢$?$</p>
<p>$1.$在$dfs$时 ，假设当前$dfs$到的点是$u,$在$u$的儿子中找两个儿子$v_1,v_2$。在$v_1$的线段树下标$(1\sim (w_{u}-1))$范围内找最长的$lis$,在$v_2$的线段树下标$((w_{u}+1)\sim m)$范围内找最长的$lds$,将两者相加并$+1$更新答案$(+1$是为了加上当前点$u),$</p>
<p>$2.$在$dfs$时，还有一种情况没有被算到，就是当前节点$u$的权值$w_{u}$不在答案序列中，由$u$的两棵子树中选取，这种情况需要在线段树合并时更新答案。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 801200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,w[N],a[N],tot,lc[N],rc[N],mx[<span class="number">2</span>][N],ans,rt[N],head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> &amp;k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> d,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k)k=++tot;</span><br><span class="line">    <span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">        mx[id][k]=<span class="built_in">max</span>(mx[id][k],d);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid)<span class="built_in">change</span>(lc[k],l,mid,x,d,id);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(rc[k],mid+<span class="number">1</span>,r,x,d,id);</span><br><span class="line">    mx[id][k]=<span class="built_in">max</span>(mx[id][lc[k]],mx[id][rc[k]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=l&amp;&amp;r&lt;=y)</span><br><span class="line">        <span class="keyword">return</span> mx[id][k];</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid&amp;&amp;mid&lt;y)<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(lc[k],l,mid,x,y,id),<span class="built_in">query</span>(rc[k],mid+<span class="number">1</span>,r,x,y,id));</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(lc[k],l,mid,x,y,id);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(rc[k],mid+<span class="number">1</span>,r,x,y,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x||!y)<span class="keyword">return</span> x|y;</span><br><span class="line">    mx[<span class="number">0</span>][x]=<span class="built_in">max</span>(mx[<span class="number">0</span>][x],mx[<span class="number">0</span>][y]);</span><br><span class="line">    mx[<span class="number">1</span>][x]=<span class="built_in">max</span>(mx[<span class="number">1</span>][x],mx[<span class="number">1</span>][y]);</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(mx[<span class="number">0</span>][lc[x]]+mx[<span class="number">1</span>][rc[y]],mx[<span class="number">1</span>][rc[x]]+mx[<span class="number">0</span>][lc[y]]));</span><br><span class="line">    lc[x]=<span class="built_in">merge</span>(lc[x],lc[y]);rc[x]=<span class="built_in">merge</span>(rc[x],rc[y]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mxlis=<span class="number">0</span>,mxlds=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="type">int</span> vlis=<span class="built_in">query</span>(rt[v],<span class="number">1</span>,m,<span class="number">1</span>,w[u]<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> vlds=<span class="built_in">query</span>(rt[v],<span class="number">1</span>,m,w[u]+<span class="number">1</span>,m,<span class="number">1</span>);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(mxlis+vlds,vlis+mxlds)+<span class="number">1</span>);</span><br><span class="line">        mxlis=<span class="built_in">max</span>(mxlis,vlis);mxlds=<span class="built_in">max</span>(mxlds,vlds);</span><br><span class="line">        rt[u]=<span class="built_in">merge</span>(rt[u],rt[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">change</span>(rt[u],<span class="number">1</span>,m,w[u],mxlis+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">change</span>(rt[u],<span class="number">1</span>,m,w[u],mxlds+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=w[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);m=<span class="built_in">unique</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n)-a<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+m,w[i])-a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>线段树合并</tag>
        <tag>$lis$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF538F 【A Heap of Heaps】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20CF538F%20%E3%80%90A%20Heap%20of%20Heaps%E3%80%91/</url>
    <content><![CDATA[<h3 id="神仙题"><a href="#神仙题" class="headerlink" title="神仙题"></a>神仙题</h3><p>题意：给一个数组建完全$k$叉树，$k$范围$[1,n-1]$，问每个$k$对应的不满足最小堆性质的结点个数</p>
<span id="more"></span>

<p>暴力$n^2$肯定要$T$飞，这里先引入几个性质：</p>
<p>$1.\frac{n}{1}+\frac{n}{2}+\frac{n}{3}+…+\frac{n}{n-1}+\frac{n}{n}&#x3D;nlogn$(调和级数)</p>
<p>2.在$i$叉树中，一个节点$j$的儿子的范围一定是一段区间$(j×i-i+2)$~$(j×i+1)$</p>
<p>接下来是正解，我们发现对于一个节点$x$，它儿子中所有不合法的节点数即是它儿子中权值小于$x$的权值的数量，这显然可以联想到树状数组求逆序对的思想。</p>
<p>先排一遍序，记录下第i小的数在原先序列中的位置。然后从小的数开始处理，小的数后面肯定是大的数，不可能会出现非法节点，然后处理完小的数之后维护树状数组，对小的数对应的权值单点修改$+1$，这样在后面处理大的数的时候询问就会算上这些更新后的权值了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">&#125;a[<span class="number">400000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,c[<span class="number">400000</span>],ans[<span class="number">400000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.a!=b.a)<span class="keyword">return</span> a.a&lt;b.a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.b&lt;b.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        ++c[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x-=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        res+=c[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        a[i].a=<span class="built_in">read</span>(),a[i].b=i;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">change</span>(a[i].b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;n&amp;&amp;a[i].b*j-j+<span class="number">2</span>&lt;=n;++j)</span><br><span class="line">            ans[j]+=<span class="built_in">sum</span>(<span class="built_in">min</span>(n,a[i].b*j+<span class="number">1</span>))-<span class="built_in">sum</span>(a[i].b*j-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF596D 【Wilbur and Trees】</title>
    <url>/2019/05/24/%E9%A2%98%E8%A7%A3%20CF596D%20%E3%80%90Wilbur%20and%20Trees%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有$n$课树并排排列，每棵树高$h$。每次从剩余的树中选最左边的或最右边的（概率相等为$0.5$），砍掉一棵树，树倒向左边的概率为$p$，倒向右边的概率为$1-p$。如果树和相邻树的距离小于$h$，树倒时会把相邻的树撞倒，倒的方向和撞到它的树一致。问，砍完所有树，树干覆盖的草地长度的期望值。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution:$"></a>$Solution:$</h2><p>容易发现,砍树是从两端开始砍的，因此两端会影响中间，而中间则不会影响到两端的树，因为砍到中间的时候，两端的树都已经砍过了.所以做$dp$的时候，例如正在处理区间$i$到$j$，我们不需要关注区间内的树是向哪边倒的，因为中间的树不会影响两端的，我们需要关注的是$i-1$和$j+1$位的地方的树，因为只有这些地方会对中间的树有影响，所以我们用$dp[i][j][0&#x2F;1][0&#x2F;1]$来表式$i-1$和$j+1$这两棵树的状态时，$i$到$j$之间的答案。若状态若为$0$，则表示向左侧倒，若为$1$，则表示向右侧倒。</p>
<p>接下来分类讨论:</p>
<p>$1.$第$i$颗树向左倒，不会影响别的树</p>
<p>$2.$第$j$棵树向右倒，不会影响别的树</p>
<p>$3.$第$i$棵树向右倒，会影响到第$i$棵树右边的树</p>
<p>$(1)$第$i$棵树能把$(i+1)$~$j$之间的所有树都压倒</p>
<p>$(2)$第$i$棵树不能把$(i+1)$~$j$之间的所有树都压倒</p>
<p>$4.$第$j$棵树向左倒，会影响到前面的树</p>
<p>$(1)$第$j$棵树能把$i$~$(j-1)$之间的所有树都压倒</p>
<p>$(2)$第$j$棵树不能把$i$~$(j-1)$之间的所有树都压倒</p>
<p>采用记搜实现</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> loc[N],dl[N],dr[N],h,n;</span><br><span class="line"><span class="type">double</span> f[N][N][<span class="number">2</span>][<span class="number">2</span>],p,q;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;r)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[l][r][x][y]!=<span class="number">-1</span>)<span class="keyword">return</span> f[l][r][x][y];</span><br><span class="line">    <span class="type">double</span> res=<span class="number">0</span>,L=<span class="built_in">min</span>(h,loc[l]-loc[l<span class="number">-1</span>]-x*h),R=<span class="built_in">min</span>(h,loc[r+<span class="number">1</span>]-loc[r]-(!y)*h);</span><br><span class="line">    res+=<span class="number">0.5</span>*p*(<span class="built_in">dfs</span>(l+<span class="number">1</span>,r,<span class="number">0</span>,y)+L);<span class="comment">//最左边向左倒</span></span><br><span class="line">    res+=<span class="number">0.5</span>*q*(<span class="built_in">dfs</span>(l,r<span class="number">-1</span>,x,<span class="number">1</span>)+R);<span class="comment">//最右边向右倒</span></span><br><span class="line">    <span class="keyword">if</span> (dl[r]&lt;=l)res+=<span class="number">0.5</span>*p*(loc[r]-loc[l]+L);</span><br><span class="line">    <span class="keyword">else</span> res+=<span class="number">0.5</span>*p*(<span class="built_in">dfs</span>(l,dl[r]<span class="number">-1</span>,x,<span class="number">0</span>)+loc[r]-loc[dl[r]]+h);<span class="comment">// 最右边的向左倒，且能覆盖整个区间的树</span></span><br><span class="line">    <span class="keyword">if</span> (dr[l]&gt;=r)res+=<span class="number">0.5</span>*q*(loc[r]-loc[l]+R);</span><br><span class="line">    <span class="keyword">else</span> res+=<span class="number">0.5</span>*q*(<span class="built_in">dfs</span>(dr[l]+<span class="number">1</span>,r,<span class="number">1</span>,y)+loc[dr[l]]-loc[l]+h);<span class="comment">// 最左边的向右倒，且能覆盖整个区间的树</span></span><br><span class="line">    <span class="keyword">return</span> f[l][r][x][y]=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();cin&gt;&gt;h&gt;&gt;p;q=<span class="number">1</span>-p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x=<span class="number">0</span>;x&lt;<span class="number">2</span>;++x)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y=<span class="number">0</span>;y&lt;<span class="number">2</span>;++y)</span><br><span class="line">                    f[i][j][x][y]=<span class="number">-1.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)loc[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(loc+<span class="number">1</span>,loc+<span class="number">1</span>+n);loc[<span class="number">0</span>]=-inf;loc[n+<span class="number">1</span>]=inf;</span><br><span class="line">    dl[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (loc[i]-loc[i<span class="number">-1</span>]&lt;h)dl[i]=dl[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> dl[i]=i;</span><br><span class="line">    dr[n]=n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>;i;--i)</span><br><span class="line">        <span class="keyword">if</span> (loc[i+<span class="number">1</span>]-loc[i]&lt;h)dr[i]=dr[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> dr[i]=i;</span><br><span class="line">    <span class="comment">//dl[i],dr[i]分别表示从i这棵树开始向左/右最多能覆盖到第dl[i]/dr[i]棵树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>,n,<span class="number">0</span>,<span class="number">1</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>概率期望$DP$</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF570E 【Pig and Palindromes】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20CF570E%20%E3%80%90Pig%20and%20Palindromes%E3%80%91/</url>
    <content><![CDATA[<p>题意:给定一个由小写字母组成的$n \times m$的矩阵 $A$，求从$A_{1, 1}$到$A_{n, m}$的所有路径中，回文串的个数。途中只能向下或向右走一格。</p>
<span id="more"></span>

<p>感觉有点像传纸条，传纸条是是维护两个点同时从起点出发，保证步数相同，转移到终点，这道题是一个点从起点，另一个点从终点出发，保证步数相同$f[step][i][j][k][p]$表示走了$step$步，一个点走到$(i,j),$另一个点走到$(k,p)$，但是这样的状态在时空复杂度上都过不去，所以我们要优化，于是我们发现$j$和$p$都可以通过$step$算出来，并且我们可以滚动数组存储$step$这一位，并且在细节处理上这道题还是挺麻烦的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> base 131</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[]&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,f[<span class="number">2</span>][<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)    </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">1</span>][<span class="number">1</span>]!=s[n][m])&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][n]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> st=<span class="number">2</span>;st&lt;=(n+m)&gt;&gt;<span class="number">1</span>;++st)&#123;</span><br><span class="line">        now^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f[now],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[now]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(st,n);++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=n;k&gt;=<span class="built_in">max</span>(n-st,i);--k)&#123;</span><br><span class="line">                <span class="type">int</span> j=st-i+<span class="number">1</span>,p=m-(st-(n-k))+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j]==s[k][p])</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> t=<span class="number">0</span>;t&lt;<span class="number">4</span>;++t)</span><br><span class="line">                        f[now][i][k]=(f[now][i][k]+f[now^<span class="number">1</span>][i+dx[t]][k+dy[t]])%mod;<span class="comment">//左边的点可以由左与上转移过来，右边的点可以由右与下转移过来</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((n+m)&amp;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            ans=(ans+f[now][i][i]+f[now][i][i+<span class="number">1</span>])%mod;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            ans=(ans+f[now][i][i])%mod;<span class="comment">//n与m的奇偶性需要特判</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF632F 【Magic Matrix】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20CF632F%20%E3%80%90Magic%20Matrix%E3%80%91/</url>
    <content><![CDATA[<p>定义一个大小为 $n\times n$ 矩阵 $a$ 为魔法矩阵，当且仅当 $a$ 满足以下条件:</p>
<p>以下 $i,j,k\in \mathbb{Z^+}$</p>
<ul>
<li><p>$\forall i\in[1,n],a_{i,i}&#x3D;0$</p>
</li>
<li><p>$\forall i,j\in[1,n],a_{i,j}&#x3D;a_{j,i}$</p>
</li>
<li><p>$\forall i,j,k\in[1,n],a_{i,j}\le\max(a_{i,k},a_{j,k})$</p>
</li>
</ul>
<p>给你一个矩阵，问它是不是魔法矩阵。</p>
<p>如果 $a$ 是魔法矩阵输出 $\texttt{MAGIC}$，否则输出 $\texttt{NOT MAGIC}$，可以参见样例。</p>
<p>$1\leq n\leq 2500,\forall i,j\in[1,n],0\le a_{i,j}\le 10^9$</p>
<span id="more"></span>

<p>最小生成树：</p>
<p>咋一看和最小生成树一点关系都没有，但是我们设$a_{i,j}$表示$i$到$j$的边的边权为$a_{i,j}$,然后观察本题的三个条件：</p>
<p>$1.$对于每一个$i,j,a_{i,j}&#x3D;a_{j,i}$(说明是无向图)</p>
<p>$2.$对于每个$i,a_{i,i}&#x3D;0$(表示没有自环)</p>
<p>$3.$对于每个$i,j,k$,都有$a_{i,j}\leqslant max(a_{i,k},a_{k,j})$</p>
<p>第三个条件说明的就是最小生成树</p>
<p>我们可以设$f_{i,j}$为$i$到$j$的任意路径的最长边的最小值，可得$a_{i,j}\geqslant f_{i,j}.$</p>
<p>假设一个矩阵满足条件,则$a_{i,j}\leqslant max(a_{i,k_1}<del>,</del>a_{k_1,k_2}),a_{k_1,j}\leqslant max(a_{k_1,k_2},a_{k_2,j})\cdots\cdots$</p>
<p>$∴a_{i,j}\leqslant max(a_{i,k_1},a_{k_1,k_2},a_{k_2,k_3},\cdots,a_{k_m,j})$</p>
<p>$&#x3D;f_{i,j}$</p>
<p>判断矩阵是否合法，就是判断图上的$i$到$j$的任意路径的最长边的最小值是否等于$a_{i,j}$.</p>
<p>这可以用最小生成树实现,模拟一遍$Kruskal$会更好理解，从最小的边开始加，形成环显然走已经形成的路更优，加边到形成树就保证图联通了就没必要加边了</p>
<p>判断合法即判断完全图中是不是任意一个生成树都是最小生成树</p>
<p>具体实现就是以任意一个节点(我使用$1$)为根，记录每个节点的父节点$fa$,然后找一个$y$,如下图，如果$max(a,b)&lt;c$,那么就不符合最小生成树和题目给定条件了。</p>
<p><img src="https://i.loli.net/2019/04/30/5cc84029053ec.png"></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">2555</span>][<span class="number">2555</span>],vis[<span class="number">2555</span>],dis[<span class="number">2555</span>],fa[<span class="number">2555</span>],dep[<span class="number">2555</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(re <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(re <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i][i])&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NOT MAGIC\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (re <span class="type">int</span> j=<span class="number">1</span>+i;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j]!=a[j][i])&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;NOT MAGIC&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">                &#125;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)fa[i]=i,dis[i]=<span class="number">1e9</span>+<span class="number">1e8</span>;dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">           re <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (re <span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)    </span><br><span class="line">               <span class="keyword">if</span> (!vis[j]&amp;&amp;dis[pos]&gt;dis[j])</span><br><span class="line">                   pos=j;</span><br><span class="line">           vis[pos]=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span> (re <span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">               <span class="keyword">if</span> (!vis[j]&amp;&amp;a[pos][j]&lt;dis[j])</span><br><span class="line">                   dis[j]=a[pos][j],fa[j]=pos,dep[j]=dep[pos]+<span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (re <span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            re <span class="type">int</span> x=i,y=j;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">max</span>(a[x][fa[x]],a[fa[x]][y])&lt;a[x][y])</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NOT MAGIC&quot;</span>),<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">max</span>(a[x][fa[y]],a[fa[y]][y])&lt;a[x][y])</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NOT MAGIC&quot;</span>),<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;MAGIC&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>思维题</tag>
        <tag>神仙题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF555E 【Case of Computer Network】</title>
    <url>/2019/07/30/%E9%A2%98%E8%A7%A3%20CF555E%20%E3%80%90Case%20of%20Computer%20Network%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给定一个$n$个点$,m$条边的无向图。有$q$条有向路线分别从$s_i$到达$t_i$。 现在你要给无向图的每条边分配一个方向。问是否存在一种分配答案使得每条路线的$s_i$和$t_i$都满足能够从$s_i$走到$~t_i$。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>很容易想到将这个无向图进行边双缩点</p>
<p>考虑边双性质:同一边双联通分量的任意两点至少存在两条不存在同一条边的路径。 </p>
<p>所有每对于一个边双，它内部的边一定可以通过分配方向来使得每对点之间都可以互相走到。</p>
<p>缩点后原图就变成了一个森林(原图可能不是一个连通图)。</p>
<p>对于森林中的每一个点，把在同一个树上的所有点用并查集并起来，最后查询时如果有一条线路中的$s_i$和$t_i$不在一棵树上，那么就输出$No$</p>
<p>我们可以对每个点$u$维护两个标记$up$和$down,$表示$u-fa$这条边的方向是$u\rightarrow fa(up)$还是$u\leftarrow fa(down)(fa$是$u$的父亲$)$如果一个节点同时拥有两个标记则无解。</p>
<p>先考虑暴力实现$:$将$s_i$到$lca$的路径上$($不包括$lca)$的点打上一个$up$的标记,将$lca$到$t_i$的点打上一个$down$的标记$($不包括$lca)$</p>
<p>我们发现这个东西显然是可以用树上差分优化的</p>
<p>关于树上差分的实现$:$将$s_i$的$up$标记打上一个$+1$,$t_i$的$down$标记上打上一个$+1$标记,在$lca$的$up$和$down$的标记分别打上一个$-1$标记。最后只需在树遍历回溯时加上子节点的标记并判断是否有一个点同时拥有两个标记即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 400203</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,to,next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[N],dep[N],fa[N],f[N][<span class="number">23</span>],num,n,m,c[N],col,up[N],dn[N],q,u[N],v[N],cnt=<span class="number">1</span>,head[N],dfn[N],low[N],st[N],top;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[k]==k?k:fa[k]=<span class="built_in">find</span>(fa[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;</span><br><span class="line">    st[++top]=u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;        </span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        vis[i]=vis[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!c[v])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u]==low[u])&#123;</span><br><span class="line">        ++col;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            c[st[top--]]=col;</span><br><span class="line">        &#125;<span class="keyword">while</span> (st[top+<span class="number">1</span>]!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=fa;dep[u]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;++i)</span><br><span class="line">        f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        up[u]+=up[v];dn[u]+=dn[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (up[u]&amp;&amp;dn[u])&#123;<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x]&lt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]]&gt;=dep[y])x=f[x][i];</span><br><span class="line">        <span class="keyword">if</span> (x==y)<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i]!=f[y][i])</span><br><span class="line">            x=f[x][i],y=f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        u[i]=<span class="built_in">read</span>(),v[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u[i],v[i]);<span class="built_in">add</span>(v[i],u[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            <span class="built_in">Tarjan</span>(i);</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=col;++i)fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="keyword">if</span> (c[u[i]]!=c[v[i]])</span><br><span class="line">            <span class="built_in">add</span>(c[u[i]],c[v[i]]),<span class="built_in">add</span>(c[v[i]],c[u[i]]),fa[<span class="built_in">find</span>(c[u[i]])]=<span class="built_in">find</span>(c[v[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=col;++i)</span><br><span class="line">        <span class="keyword">if</span> (!dep[i])</span><br><span class="line">            <span class="built_in">dfs1</span>(i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="type">int</span> s=c[<span class="built_in">read</span>()],t=c[<span class="built_in">read</span>()],lca=<span class="built_in">LCA</span>(s,t);</span><br><span class="line">        <span class="keyword">if</span> (s==t)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(s)!=<span class="built_in">find</span>(t))&#123;<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        --up[lca];++up[s];--dn[lca];++dn[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=col;++i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i)==i)</span><br><span class="line">            <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>$Tarjan$</tag>
        <tag>边双联通分量</tag>
        <tag>树上差分</tag>
        <tag>$lca$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF718C 【Sasha and Array】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20CF718C%20%E3%80%90Sasha%20and%20Array%E3%80%91/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul>
<li><p>在本题中，我们用 $f_i$ 来表示第 $i$ 个斐波那契数（$f_1&#x3D;f_2&#x3D;1,f_i&#x3D;f_{i-1}+f_{i-2}(i\ge 3)$）。</p>
</li>
<li><p>给定一个 $n$ 个数的序列 $a$。有 $m$ 次操作，操作有两种：</p>
<ol>
<li>将 $a_l\sim a_r$ 加上 $x$。</li>
<li>求 $\displaystyle\left(\sum_{i&#x3D;l}^r f_{a_i}\right)\bmod (10^9+7)$。</li>
</ol>
</li>
<li><p>$1\le n,m\le 10^5$，$1\le a_i\le 10^9$。</p>
  <span id="more"></span></li>
</ul>
<p>快速求$Fibonacci$第$n$项的方法是用矩阵乘法，即原始矩阵$\begin{pmatrix} 2\ 1 \end{pmatrix}$*$Fibonacci$矩阵$^{(n-2)}$,所以我们可以想到将$n$加上$k$相当于给$f[n]$乘上$Fibonacci$矩阵^$k$，所以我们可以想到线段树维护矩阵</p>
<p>对于第一个问题：由于矩阵具有分配律，即$a×b+a×c&#x3D;a×(b+c)$，所以对于一段区间的矩阵可以相加维护。</p>
<p>对于第二个问题，显然将$[l,r]$的矩阵乘上转移矩阵的$x$次方即可。</p>
<p>用线段树维护即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(k) (k&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(k) (k&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">21</span>], *p1 = buf, *p2 = buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;a[<span class="number">1</span>][<span class="number">2</span>]=a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init0</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">2</span>][<span class="number">2</span>]=a[<span class="number">1</span>][<span class="number">2</span>]=a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">2</span>][<span class="number">1</span>]=a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span> + (node aa,node bb)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1</span>;j++)&#123;</span><br><span class="line">                aa.a[i][j]=(aa.a[i][j]+bb.a[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (aa.a[i][j]&gt;mod)aa.a[i][j]-=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> aa;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span> * (node a,node b)&#123;</span><br><span class="line">        node c;c.<span class="built_in">init0</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;++j)&#123;</span><br><span class="line">                    c.a[i][j]+=<span class="number">1ll</span>*a.a[i][k]*b.a[k][j]%mod;</span><br><span class="line">                    <span class="keyword">if</span> (c.a[i][j]&gt;mod)c.a[i][j]-=mod;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span> ^ (node a,<span class="type">int</span> p)&#123;</span><br><span class="line">        node res;</span><br><span class="line">        res.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">            p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            a=a*a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f[<span class="number">100005</span>],p,jz[<span class="number">500005</span>],tag[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>); x = -x; &#125;</span><br><span class="line">    T y = <span class="number">10</span>, len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y &lt;= x) &#123; y *= <span class="number">10</span>; ++len; &#125;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123; y /= <span class="number">10</span>; <span class="built_in">putchar</span>(x / y + <span class="number">48</span>); x %= y; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(node tag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tag.a[<span class="number">1</span>][<span class="number">1</span>]!=<span class="number">1</span>||!tag.a[<span class="number">2</span>][<span class="number">2</span>]!=<span class="number">1</span>||tag.a[<span class="number">1</span>][<span class="number">2</span>]!=<span class="number">0</span>||tag.a[<span class="number">2</span>][<span class="number">1</span>]!=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    jz[k]=jz[<span class="built_in">ls</span>(k)]+jz[<span class="built_in">rs</span>(k)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tag[k].<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">        jz[k]=f[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(k),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    node sq=tag[k];</span><br><span class="line">    jz[<span class="built_in">ls</span>(k)]=sq*jz[<span class="built_in">ls</span>(k)];</span><br><span class="line">    tag[<span class="built_in">ls</span>(k)]=tag[<span class="built_in">ls</span>(k)]*sq;</span><br><span class="line">    jz[<span class="built_in">rs</span>(k)]=sq*jz[<span class="built_in">rs</span>(k)];</span><br><span class="line">    tag[<span class="built_in">rs</span>(k)]=tag[<span class="built_in">rs</span>(k)]*sq;</span><br><span class="line">    tag[k].<span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,node sq)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        jz[k]=sq*jz[k];</span><br><span class="line">        tag[k]=tag[k]*sq;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(tag[k]))<span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid)<span class="built_in">change</span>(<span class="built_in">ls</span>(k),l,mid,x,y,sq);</span><br><span class="line">    <span class="keyword">if</span> (mid&lt;y) <span class="built_in">change</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r,x,y,sq);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=l&amp;&amp;r&lt;=y)</span><br><span class="line">        <span class="keyword">return</span> jz[k];</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(tag[k]))<span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid&amp;&amp;mid&lt;y)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(k),l,mid,x,y)+<span class="built_in">query</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">ls</span>(k),l,mid,x,y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    p.<span class="built_in">init1</span>();</span><br><span class="line">    node ttt;</span><br><span class="line">    ttt.a[<span class="number">1</span>][<span class="number">1</span>]=ttt.a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>()<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">-1</span>)f[i].a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>,f[i].a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i]=(p^x)*ttt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="type">int</span> opt=<span class="built_in">read</span>(),x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> d=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,p^d);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node ans=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">            <span class="built_in">write</span>(ans.a[<span class="number">1</span>][<span class="number">1</span>]);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF685B 【Kay and Snowflake】</title>
    <url>/2019/07/31/%E9%A2%98%E8%A7%A3%20CF685B%20%E3%80%90Kay%20and%20Snowflake%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给出一棵树$($根是$1$$号节点 )$和$q$个询问,对于每个询问$v_i,$要求回答以$v_i$为根的子树的重心</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>先预处理出每个点$u$作为根时的答案，记为$ans[u],$最后$O(1)$回答。</p>
<p>记$u$的重儿子$($即$size$最大的儿子$)$为$son[u]$</p>
<p>考虑一个性质:如果以当前节点$u$为根$,size[son[u]]&lt;&#x3D;\frac{size[u]}{2},$所以$,ans[u]$只有可能是$u$自己或者在$son[u]$的子树中。</p>
<p>是$u$自己的情况根据$size[son[u]]$判断一下即可。</p>
<p>在$son[u]$的子树中的情况。因为$size[u]&gt;size[son[u]],$所以$ans[u]$一定在$ans[son[u]]$的上方，因此我们只需要每次从以$son[u]$为根的子树的重心向上跳即可。</p>
<p>由于重心只会向上跳，所以跳的次数就是树高,所以总复杂度为$O(n)$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 405400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N],fa[N],mx,loc,size[N],son[N],n,q,head[N],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    size[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">        <span class="keyword">if</span> (size[v]&gt;size[son[u]])son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((size[son[u]]&lt;&lt;<span class="number">1</span>)&gt;size[u])&#123;</span><br><span class="line">        <span class="type">int</span> x=ans[son[u]];</span><br><span class="line">        <span class="keyword">while</span> (((size[u]-size[x])&lt;&lt;<span class="number">1</span>)&gt;size[u])x=fa[x];</span><br><span class="line">        ans[u]=x;</span><br><span class="line">    &#125;<span class="keyword">else</span> ans[u]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)fa[i]=<span class="built_in">read</span>(),<span class="built_in">add</span>(fa[i],i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树相关</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF700B Connecting Universities</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20CF700B%20Connecting%20Universities/</url>
    <content><![CDATA[<p>题意：给出一棵树上的$2\times k$个节点，给他们配对，使得他们之间的距离和最大。</p>
<span id="more"></span>

<p>显然，如果对于每条边，它被经过的次数越多越好，那么它被经过的次数最多是多少呢，假设在它两侧分别有$x,y$个端点，那么它被经过的次数最多是$min(x,y)$;</p>
<p>所以$ans$就是$\sum min(x,y)$；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll to,next;</span><br><span class="line">&#125;e[<span class="number">500000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ll s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">ll n,k,head[<span class="number">500000</span>],cnt,t[<span class="number">500000</span>],b[<span class="number">500000</span>],a[<span class="number">500000</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(ll u,ll v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u,ll fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b[u])t[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        ll v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        t[u]+=t[v];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=<span class="built_in">min</span>(t[u],<span class="number">2</span>*k-t[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (ll i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*k;++i)</span><br><span class="line">        a[i]=<span class="built_in">read</span>(),b[a[i]]=<span class="number">1</span>;;</span><br><span class="line">    <span class="keyword">for</span> (ll i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        ll u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF746G New Roads</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20CF746G%20New%20Roads/</url>
    <content><![CDATA[<p>题意：给你$3$个数字$n,t,k;$分别表示一棵树有$n$个点; 这棵树的深度$t$,以及叶子节点的个数$k;$给你树的每层节点个数; 让你画出这么一棵树; 输出它的$n-1$条边; </p>
<span id="more"></span>

<p>首先计算这样的树最多与最少能有几个叶子节点，如果$k$不在这个范围内，则输出$-1,return 0;$</p>
<p>然后我们钦定同一深度的点都指向同一个父亲 这样叶子节点最多，并且计算一下我们需要消除的叶子节点数量$&#x3D;n-t-k$。</p>
<p>然后从下到上进行调整,每次将当前层节点指向的父亲转移成上一层每个节点(如果当前层节点数大于上一层节点数，则多余的挤在一起)枚举用两个指针，一个指针指向当前层，另一个指针指向上一层，同时$+1$，如果一个指针指向了尽头就跳到上一层，如果消除的叶子节点数$&#x3D;$我们需要消除的叶子节点数量则退出。</p>
<p>然后输出即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">300000</span>],mx,mn,tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),t=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;++i)&#123;</span><br><span class="line">        a[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (a[i]&gt;a[i<span class="number">-1</span>])mn+=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    mx=n-t;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;mn||k&gt;mx)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=a[<span class="number">1</span>]+<span class="number">1</span>;++i)<span class="built_in">printf</span>(<span class="string">&quot;1 %d\n&quot;</span>,i);<span class="comment">//根节点与其子节点特殊处理</span></span><br><span class="line">    <span class="type">int</span> T=mx-k;tot=a[<span class="number">1</span>]+<span class="number">2</span>;<span class="comment">//T为我们需要消除的叶子节点数量，tot为初始指针指向第三层的第一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=t;++i)&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="built_in">min</span>(a[i],a[i<span class="number">-1</span>]),q=<span class="number">0</span>;<span class="comment">//p表示当前层可以消除的叶子节点数，q是指针</span></span><br><span class="line">        <span class="keyword">while</span> (p&amp;&amp;T)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q)--T;<span class="comment">//第一个点是下一层多余节点的连接处，所以T不能--;</span></span><br><span class="line">            --p;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,tot+q-a[i<span class="number">-1</span>],tot+q);</span><br><span class="line">            ++q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q&lt;a[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,tot-a[i<span class="number">-1</span>],tot+q);</span><br><span class="line">            ++q;</span><br><span class="line">        &#125;<span class="comment">//处理多余节点</span></span><br><span class="line">        tot+=a[i];<span class="comment">//指针指向下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF765E Tree Folding</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20CF765E%20Tree%20Folding/</url>
    <content><![CDATA[<p>题意：给你一棵树，可以把树上父亲相同的两条长度相同的链合并。（如图）问你最后能不能变成一条链，能的话求链的最短长度。</p>
<span id="more"></span>

<p>显然如果可以合并，那么合并后长度一定$\leqslant$直径的一半，所以，我们找到直径的中点作为根(若有两个中点则随便选一个)</p>
<p>对于每个点(除根以外)，如果它有两条或以上长度为不同的子节点形成的链，那么这棵树是无法合并的，输出$-1$，否则用一个$set$维护子节点形成的链长度情况，向上个节点传递$set$中链的长度$+1$</p>
<p>特别的，对于根，因为它没有父亲节点，所以即使它有两条子节点形成的链，也是合法的(但是如果有三条及以上就不合法了)，如果有一条链，返回这条链的长度$+1$，如果有两条链，返回两条链长度之和$+2$；</p>
<p>最后，对于答案，如果$ans$是$2$的倍数，将它不停地除以$2$，直到$ans$是奇数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[<span class="number">700000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wln</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,head[<span class="number">500000</span>],dep[<span class="number">400005</span>][<span class="number">3</span>],mx,loc,mid;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    dep[u][t]=dep[fa][t]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[u][t]&gt;mx)&#123;</span><br><span class="line">        mx=dep[u][t];</span><br><span class="line">        loc=u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;lxy666;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v!=fa) lxy666.<span class="built_in">insert</span>(<span class="built_in">dfs1</span>(v,u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u==fa)&#123;<span class="comment">//根特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> (!lxy666.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lxy666.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="keyword">return</span> *lxy666.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lxy666.<span class="built_in">size</span>()==<span class="number">2</span>)<span class="keyword">return</span> *lxy666.<span class="built_in">begin</span>()+*--lxy666.<span class="built_in">end</span>()+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lxy666.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lxy666.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="keyword">return</span> *lxy666.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    mx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    mx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(loc,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> len=mx<span class="number">-1</span>;mx=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(loc,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (dep[i][<span class="number">1</span>]+dep[i][<span class="number">0</span>]<span class="number">-2</span>==len)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(dep[i][<span class="number">0</span>]-dep[i][<span class="number">1</span>])==<span class="number">0</span>||<span class="built_in">abs</span>(dep[i][<span class="number">0</span>]-dep[i][<span class="number">1</span>])==<span class="number">1</span>)&#123;</span><br><span class="line">                mid=i;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//以上为找直径中点</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">dfs1</span>(mid,mid);<span class="keyword">while</span>(!(ans&amp;<span class="number">1</span>))ans&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>思维题</tag>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF773DPerishable Roads</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20CF773DPerishable%20Roads/</url>
    <content><![CDATA[<p>题意：一个$n$个点的完全图，定义$d_x$为生成树上点$x$到根路径上的最小边权。问图$G$的生成树$\sum d_x$最小是多少？</p>
<span id="more"></span>

<p>人性化题意:给出$n$个点的完全图，对于完全图中的每个点$i,i$作为终点时，要使其他每个点到点$i$的“距离”和最小，对于每个点都输出这个最小值。 这里的“距离”是指对于其他每个点，那个点到点$i$路径上的最小值。且对于每个点$i$，计算答案时应保证图内每条边的方向一定。</p>
<p>首先可以发现这个路标建出来是一颗树，对于每一个点的贡献是这个点到终点的路径上的最小值。然后有一个十分机智的想法就是对于所有终点，把所有点都连在最短的边的一端，然后另一端连向终点。</p>
<p>然后这个东西显然是假的</p>
<p>不过我们可以考虑对它进行一些微小的修改让它成为正确的。</p>
<p>考虑这个想法的错误之处在于最短边的一端到终点的距离可能很长，所以我们考虑对这个进行计算，最短边的一边到终点路径显然是一条链。</p>
<p>显然这条链的边权只有单调递增时才有意义，因为任意一个破坏单调性的点都可以跟最短边不连接的一端连接，这样显然会更优。</p>
<p>这个过程有点难理解，也比较难实现，所以我们把这个过程想象成一个连边的过程，一开始最短路的一端直接跟终点连接。如下图<br><img src="https://i.loli.net/2019/03/05/5c7e8c51b7f01.png" alt="松弛前"></p>
<p>如果要去更新图$1$中的$a$，那么我们必须找到另一个点来松弛它，如图$2$，我们假设$c&lt;b$(因为如果$c&gt;b$,后面最短路操作会更新)，那么这些点的总贡献就变成了$2\times c$(显然)，因为是一条链，所以我们可以就此跑一遍最短路找出终点到最短边的最小总长度。</p>
<p><img src="https://i.loli.net/2019/03/05/5c7e8c51d4312.png" alt="松弛后"></p>
<p>由于过程中维护最短边两端的点各自的个数，我们先将每条边减去最短边的权值，最后在加上最短边权值$\times (n-1)$</p>
<p>怎么计算答案呢？我们设那条链上除终点外有$x$个点，那么那棵树上就有$n-1-x$个点，设最小边长度为$minn$，那么答案为$dis[t]+minn*(n-1-x)$。这个$x$很难计算，考虑消去。即计算$dis[t]$前先对所有边权减去一个$minn$，设新链答案为$dis[t]$，那么答案会变成$(dis[t]+minn\times x)+minn\times(n-1-x)$，即$dis[t]+minn\times(n-1)$,于是$x$就消去了。所以我们计算$dis[t]$即可。</p>
<p>因为要求最优解，我们跑最短路求$dis$(定义见上) 。即向终点直接连边，所以赋为终点与最小点的边权。还有一种状态，即是图$2$的情况，考虑那条链上有$3$个点。设加入的为点$j$，那么链的答案可能为最小点到终点的答案加上$j$到终点的答案，即$a[i][j]\times 2$($a$数组为邻接矩阵,$i$是终点) 最后$dijkstra$松弛即可 (模板) 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s,n,a[<span class="number">3005</span>][<span class="number">3005</span>],mn=<span class="number">21000000000000</span>,dis[<span class="number">400000</span>],vis[<span class="number">400000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        dis[i]=a[s][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (i!=j)</span><br><span class="line">                dis[i]=<span class="built_in">min</span>(dis[i],a[i][j]*<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="comment">//边权如此赋值的原因就是上述的图2情况</span></span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> mn=<span class="number">210000000000000</span>,k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j]&amp;&amp;mn&gt;dis[j])</span><br><span class="line">                mn=dis[j],k=j;</span><br><span class="line">        vis[k]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j]&amp;&amp;dis[j]&gt;dis[k]+a[k][j])</span><br><span class="line">                dis[j]=dis[k]+a[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//不堆优化的dijkstra</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            a[i][j]=a[j][i]=<span class="built_in">read</span>();    </span><br><span class="line">            <span class="keyword">if</span> (mn&gt;a[i][j])&#123;</span><br><span class="line">                mn=a[i][j];s=i;<span class="comment">//s即最短边靠终点的那个端点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            a[i][j]=a[j][i]=a[i][j]-mn;</span><br><span class="line">    <span class="built_in">dijkstra</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,dis[i]+mn*(n<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>思维题</tag>
        <tag>神仙题</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF780F 【Axel and Marston in Bitland】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20CF780F%20%E3%80%90Axel%20and%20Marston%20in%20Bitland%E3%80%91/</url>
    <content><![CDATA[<p>给定一张有向图(可能有自环，保证没有重边)，每条边有两种类型，分别为$1$或者$0 $从$1$开始走，要求走过的路径类型成如下方式</p>
<p>$0$</p>
<p>$01$</p>
<p>$0110$</p>
<p>$01101001$</p>
<p>第$i$个是由第$i -1$个和第$i - 1$个取反拼在后面。 求最长路。</p>
<span id="more"></span>

<p>题目要求第$i$个是由第$i-1$个和（第$i-1$个取反）拼在后面。 求最长路。</p>
<p>因此可以用倍增的思想进行$dp$，$dp$思路在代码中。可以用$bitset$优化</p>
<p>最后选取时从长的往短的枚举，在加的过程中大于$1e18$就退出</p>
<p>听说好像可以用矩乘优化，<del>但蒟蒻我不会</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">bitset&lt;505&gt;f[<span class="number">2</span>][<span class="number">65</span>][<span class="number">505</span>],t,pre;<span class="comment">//f[p][s][x][y]表示第一条边为p类型，x与y之间有2的s次方的路径存不存在</span></span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),t=<span class="built_in">read</span>();</span><br><span class="line">        f[t][<span class="number">0</span>][x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 转移方程:f[p][s][x][y]|=(f[p][s][x][k]&amp;f[p^1][s][k][y])     k为枚举的中转点 </span></span><br><span class="line"><span class="comment">//最后一位可以用bitset压掉，即if (f[p][s-1][x][k]) f[p][s][x]|=f[p^1][s-1][k]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s=<span class="number">1</span>;s&lt;=<span class="number">60</span>;++s)<span class="comment">//s为路径长度是2的多少幂次 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p=<span class="number">0</span>;p&lt;=<span class="number">1</span>;++p)<span class="comment">//p为第一条边的类型 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;++x)<span class="comment">//x为起点 </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)<span class="comment">//k为枚举的中转点 </span></span><br><span class="line">                    <span class="keyword">if</span> (f[p][s<span class="number">-1</span>][x][k])    </span><br><span class="line">                        f[p][s][x]|=f[p^<span class="number">1</span>][s<span class="number">-1</span>][k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">0</span>][<span class="number">60</span>][<span class="number">1</span>][i])&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;pre[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//一开始只有节点1可以作为起点 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s=<span class="number">59</span>;s&gt;=<span class="number">0</span>;--s)&#123;<span class="comment">// 贪心得选，能选长的就选长的 </span></span><br><span class="line">        t.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">if</span> (pre[i])<span class="comment">//pre数组表示当前可不可以选为起点 </span></span><br><span class="line">                t|=f[now][s][i];<span class="comment">//t数组表示从当前可选的起点走接下来能到达的点</span></span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">count</span>())&#123;</span><br><span class="line">            pre=t;</span><br><span class="line">            now^=<span class="number">1</span>;</span><br><span class="line">            ans+=(<span class="number">1ll</span>&lt;&lt;s);</span><br><span class="line">            <span class="keyword">if</span> (ans&gt;<span class="number">1e18</span>)&#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%I64d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>$DP$</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF878C Tournament</title>
    <url>/2019/05/01/%E9%A2%98%E8%A7%A3%20CF878C%20Tournament/</url>
    <content><![CDATA[<p>题意:最近Berland开始了一场有k种运动的比赛。瓦萨亚希望在赌场上赚钱。 比赛的计划非常神秘，并没有完全公开。比赛选手背靠背举行，每场比赛都涉及两名尚未淘汰的运动员。每场比赛都可以举行k种运动里的任意一种，失败者则遭到淘汰。最后剩下的运动员成为冠军。除此之外，该方案可以是任意的，不提前公开。 瓦西亚了解各种运动中的运动员的力量。他认为，拥有更高力量的运动员总能获胜。 比赛每年举行一次，每年都有一名新参赛者加入比赛。在第一场比赛中，只有一名运动员参加，第二场比赛有两名运动员，依此类推。 请你帮助他找到每一年可能获得冠军的人数。</p>
<span id="more"></span>

<p>我们考虑两个选手之间的关系，如果一个选手能在任何一项运动中战胜对手，那么就从他自身向对手连一条有向边。这样显然会出现很多环，于是可以大力缩点，将整张图缩成一个$DAG$（实际实现中会变为一条链）。那么显然入度为零的环中包含的点数即为最后可能成为冠军的人数。</p>
<p>这里缩点的技巧就是这道题的关键，由于题目要求动态插入点，那么$tarjan$就不再适合了。于是我们可以选择$set$作为容器，把上述判断的条件重载成小于号，在$set$中用$find$查找（这里的$find$查找完全是根据$”&lt;”$来的,即对于两个参数$a,b$,判断$&#x3D;&#x3D;$的操作相当于判断$(!(a&lt;b))$&amp;&amp;$(!(b&lt;a)),)$是否有与当前选手可以合并的，并进行合并操作。合并后，我们的节点（即一个环）记录的是环中每项运动所有选手中的最大值和最小值，这样可以方便地进行环与环之间的比较。</p>
<p>将所有点插入后，答案即为$set$中的最后一个元素的大小，因为我们重载了小于号，所以最后一个节点都是“大于”之前的点的，在缩点后的图中一定是入度为$0$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> mx[<span class="number">15</span>],mn[<span class="number">15</span>],size;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">            <span class="keyword">if</span> (a.mx[i]&gt;b.mn[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;lxy;</span><br><span class="line">set&lt;node&gt;s;</span><br><span class="line">set&lt;node&gt;::iterator it;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        lxy.size=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;++j)lxy.mx[j]=lxy.mn[j]=<span class="built_in">read</span>();</span><br><span class="line">        it=s.<span class="built_in">find</span>(lxy);</span><br><span class="line">        <span class="keyword">while</span> (it!=s.<span class="built_in">end</span>())&#123;</span><br><span class="line">            lxy.size+=(*it).size;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;++j)</span><br><span class="line">                lxy.mx[j]=<span class="built_in">max</span>(lxy.mx[j],(*it).mx[j]),lxy.mn[j]=<span class="built_in">min</span>(lxy.mn[j],(*it).mn[j]);</span><br><span class="line">            s.<span class="built_in">erase</span>(it);it=s.<span class="built_in">find</span>(lxy);</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(lxy);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(*--s.<span class="built_in">end</span>()).size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>$STL$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 Codeforces Round</title>
    <url>/2019/08/17/%E9%A2%98%E8%A7%A3%20Codeforces%20Round%20#579%20(Div.%203)/</url>
    <content><![CDATA[<p>比赛链接$:$<a href="https://codeforces.com/contest/1203">点击进入</a></p>
<span id="more"></span>

<h2 id="A-Circle-of-Students"><a href="#A-Circle-of-Students" class="headerlink" title="A Circle of Students"></a>A <a href="https://codeforces.com/contest/1203/problem/A">Circle of Students</a></h2><h3 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h3><p>$T$组询问，每组询问给出$n$个数字，问这$n$个数字能否顺时针或逆时针围成圆环。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h3><p>直接模拟即可$,$但是我是用计算差分数组$($假设第$n$个数字的下一个数字为第$1$个数字$)$</p>
<p>如果差分数组中$n$个数含有$n-1$个$1$或者$-1,$那么输出$YES,$否则输出$NO.$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 101800</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N],n,c[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[n+<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)c[i]=a[i+<span class="number">1</span>]-a[i];</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cnt+=(c[i]==<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (cnt==n<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cnt+=(c[i]==<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (cnt==n<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        n=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">check</span>()?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Equal-Rectangles"><a href="#B-Equal-Rectangles" class="headerlink" title="B Equal Rectangles"></a>B <a href="https://codeforces.com/contest/1203/problem/B">Equal Rectangles</a></h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="$Description$"></a>$Description$</h3><p>$q$组输入，每组输入给出一个整数$n$，然后输入$4\times n$个木棍长度。判断这些木棍能否构成$n$个面积相同的矩形。</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="$Solution$"></a>$Solution$</h3><p>把这些木棍长度先映射到桶里去，如果有一个桶中木棍的个数是奇数，那么直接退出输出$NO$。由于一对长度相同的木棍是成对出现的，所以要把两个相同的木棍长度只保留一个，然后确定矩形的面积，显然是这些木棍长度的最小值乘最大值。然后一一判断即可</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="$Code$"></a>$Code$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 101800</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N],n,c[N],b[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n&lt;&lt;<span class="number">2</span>;++i)++b[a[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1e4</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i]&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;b[i];b[i]-=<span class="number">2</span>)&#123;</span><br><span class="line">            c[++tot]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> v=c[<span class="number">1</span>]*c[n&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (c[i]*c[(n&lt;&lt;<span class="number">1</span>)-i+<span class="number">1</span>]!=v)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        n=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n&lt;&lt;<span class="number">2</span>;++i)a[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">check</span>()?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Common-Divisors"><a href="#C-Common-Divisors" class="headerlink" title="C Common Divisors"></a>C <a href="https://codeforces.com/contest/1203/problem/C">Common Divisors</a></h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="$Description$"></a>$Description$</h3><p>给出$n$个正整数，找出能整除这$n$个数的正整数个数。</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="$Solution$"></a>$Solution$</h3><p>即求最大公约数的因子个数</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="$Code$"></a>$Code$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1001800</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N],n,c[N],b[N],v,ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        v=<span class="built_in">gcd</span>(v,<span class="built_in">read</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1e6</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (v%i==<span class="number">0</span>)&#123;</span><br><span class="line">            ++c[i];v/=i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans*=c[i]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v!=<span class="number">1</span>)ans*=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D1-Remove-the-Substring-easy-version"><a href="#D1-Remove-the-Substring-easy-version" class="headerlink" title="D1 Remove the Substring (easy version)"></a>D1 <a href="https://codeforces.com/contest/1203/problem/D1">Remove the Substring (easy version)</a></h2><h3 id="Description-3"><a href="#Description-3" class="headerlink" title="$Description$"></a>$Description$</h3><p>给出两个字符串$s$和t，求最大可以在在字符串s中删除连续几个字符后t仍然可以为s的子串$($不要求连续$)$。</p>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="$Solution$"></a>$Solution$</h3><p>不会，用$D2$代码交的</p>
<h3 id="Code-3"><a href="#Code-3" class="headerlink" title="$Code$"></a>$Code$</h3><p>见$D2$代码</p>
<h2 id="D2-Remove-the-Substring-hard-version"><a href="#D2-Remove-the-Substring-hard-version" class="headerlink" title="D2 Remove the Substring (hard version)"></a>D2 <a href="https://codeforces.com/contest/1203/problem/D2">Remove the Substring (hard version)</a></h2><h3 id="Description-4"><a href="#Description-4" class="headerlink" title="$Description$"></a>$Description$</h3><p>见$D1$题面</p>
<h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="$Solution$"></a>$Solution$</h3><p>先预处理出$c[i]$表示$s$中第一个能匹配到$,t[i]$的位置</p>
<p>再把$s$和$t$反转,再计算一遍$c[i],$记为$f[i]$</p>
<p>答案即是$\max\limits_{i&#x3D;0}^{m}(n-f[i]-c[m-i])$</p>
<h3 id="Code-4"><a href="#Code-4" class="headerlink" title="$Code$"></a>$Code$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 301800</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N],t[N];</span><br><span class="line"><span class="type">int</span> ans,p[N],q[N],c[N],f[N],d[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>),m=<span class="built_in">strlen</span>(t+<span class="number">1</span>);d[t[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        p[i]=d[s[i]];</span><br><span class="line">        d[t[p[i]+<span class="number">1</span>]]=<span class="built_in">max</span>(d[t[p[i]+<span class="number">1</span>]],p[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p[i]&amp;&amp;!c[p[i]])c[p[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n);<span class="built_in">reverse</span>(t+<span class="number">1</span>,t+<span class="number">1</span>+m);</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));d[t[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        q[i]=d[s[i]];</span><br><span class="line">        d[t[q[i]+<span class="number">1</span>]]=<span class="built_in">max</span>(d[t[q[i]+<span class="number">1</span>]],q[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (q[i]&amp;&amp;!f[q[i]])f[q[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(n-f[i]-c[m-i],ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Boxers"><a href="#E-Boxers" class="headerlink" title="E Boxers"></a>E <a href="https://codeforces.com/contest/1203/problem/E">Boxers</a></h2><h3 id="Description-5"><a href="#Description-5" class="headerlink" title="$Description$"></a>$Description$</h3><p>有$n$个拳击手，给出他们的体重$a_i$，每个拳击手的体重可以$+1$或$-1($体重必须是正整数$)，$询问最多能选出几个体重不同的拳击手。</p>
<h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="$Solution$"></a>$Solution$</h3><p>先从大到小排序.如果$a_i+1$未选则选,然后如果$a_i$未选则选,最后如果$a_i-1$未选则选.很显然的贪心</p>
<h3 id="Code-5"><a href="#Code-5" class="headerlink" title="$Code$"></a>$Code$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 301800</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a[N],vis[N],ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n;i;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[a[i]+<span class="number">1</span>])&#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            vis[a[i]+<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!vis[a[i]])&#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            vis[a[i]]=<span class="number">1</span>;<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!vis[a[i]<span class="number">-1</span>]&amp;&amp;a[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            vis[a[i]<span class="number">-1</span>]=<span class="number">1</span>;<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F1-Complete-the-Projects-easy-version"><a href="#F1-Complete-the-Projects-easy-version" class="headerlink" title="F1 Complete the Projects (easy version)"></a>F1 <a href="https://codeforces.com/contest/1203/problem/F1">Complete the Projects (easy version)</a></h2><h3 id="Description-6"><a href="#Description-6" class="headerlink" title="$Description$"></a>$Description$</h3><p>给定$n$个项目，和一个初始权值$r$。每个项目有两个数值构成，$a$表示要进行这个项目的最低权值需求，$b$表示进行完这个项目后权值将会变化的数值。询问能否通过调整项目顺序完成所有的项目。</p>
<h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="$Solution$"></a>$Solution$</h3><p>将项目分成两类.一类为$b$是非负的,另一类$b$是负的.</p>
<p>对于第一类,按照$a$从小到大排序即可.这个贪心很显然</p>
<p>对于第二类,按照$a+b$从大到小排序即可</p>
<p>证明$:$</p>
<p>显然,只需证明当$a_1+b_1&gt;a_2+b_2$时,如果①②顺序不行的话②①也不行.</p>
<p>①②不行只有两种情况</p>
<p>$1.$①时不行,那么$r&lt;a_1$</p>
<p>∵$b_2&lt;0$</p>
<p>∴②①顺序到①时$r+b_2&lt;a_1$</p>
<p>∴这种情况下如果①②顺序不行的话②①也不行</p>
<p>$2.$②时不行,那么$r+b_1&lt;a_2$</p>
<p>由$a_1+b_1&gt;a_2+b_2$得$b_2&lt;b_1+a_1-a_2$</p>
<p>∴$r+b_2&lt;r+b_1+a_1-a_2&lt;a_2-a_2+a_1&#x3D;a_1$</p>
<p>∴这种情况下如果①②顺序不行的话②①也不行</p>
<h3 id="Code-6"><a href="#Code-6" class="headerlink" title="$Code$"></a>$Code$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 301800</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.b&gt;b.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a&lt;b.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp3</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a+a.b&gt;b.a+b.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,loc;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)p[i].a=<span class="built_in">read</span>(),p[i].b=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n;i;--i)</span><br><span class="line">        <span class="keyword">if</span> (p[i].b&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            loc=i;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+loc+<span class="number">1</span>,cmp2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=loc+<span class="number">1</span>;i&lt;=n;++i)p[i].a=<span class="built_in">max</span>(p[i].a,-p[i].b);</span><br><span class="line">    <span class="built_in">sort</span>(p+loc+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m&lt;p[i].a)&#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        m+=p[i].b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="F2-Complete-the-Projects-hard-version"><a href="#F2-Complete-the-Projects-hard-version" class="headerlink" title="F2 Complete the Projects (hard version)"></a>F2 <a href="https://codeforces.com/contest/1203/problem/F2">Complete the Projects (hard version)</a></h2><h3 id="Description-7"><a href="#Description-7" class="headerlink" title="$Description$"></a>$Description$</h3><p>和$F1$基本一样，就是询问变成了通过调整最多能做几个项目。</p>
<h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="$Solution$"></a>$Solution$</h3><p>和$F1$一样分成$b&gt;&#x3D;0$和$b&lt;0$的项目讨论</p>
<p>对于$b&gt;&#x3D;0$的情况,按照$a$排序.能取多少取多少</p>
<p>对于$b&lt;0$的情况用类似$01$背包的方法.</p>
<p>将$r$看成背包容量,单个项目的体积是$b$,价值为$1$,$f[i][j]$表示到第$i$个项目,当前$r$为$j$最多可以做几个项目.</p>
<p>但是还有一个问题,$01$背包对于物品的顺序是没有关系的,但是在这个问题中显然是有关系的,所以在$DP$前需要先对项目按照$a+b$从大到小排序.$($原因见$F1$题解$)$</p>
<h3 id="Code-7"><a href="#Code-7" class="headerlink" title="$Code$"></a>$Code$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 301800</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.b&gt;b.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a&lt;b.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp3</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a+a.b&gt;b.a+b.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,loc,ans1=<span class="number">-1</span>,ans2,f[<span class="number">102</span>][<span class="number">60300</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)p[i].a=<span class="built_in">read</span>(),p[i].b=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n;i;--i)</span><br><span class="line">        <span class="keyword">if</span> (p[i].b&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            loc=i;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+loc+<span class="number">1</span>,cmp2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=loc+<span class="number">1</span>;i&lt;=n;++i)p[i].a=<span class="built_in">max</span>(p[i].a,-p[i].b);</span><br><span class="line">    <span class="built_in">sort</span>(p+loc+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=loc;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (m&lt;p[i].a)&#123;</span><br><span class="line">            ans1=i<span class="number">-1</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m+=p[i].b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans1==<span class="number">-1</span>)ans1=loc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>+loc;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(f[i+<span class="number">1</span>],f[i],<span class="built_in">sizeof</span>(f[i+<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=p[i].a;j&lt;=m;++j)&#123;</span><br><span class="line">            f[i+<span class="number">1</span>][j+p[i].b]=<span class="built_in">max</span>(f[i+<span class="number">1</span>][j+p[i].b],f[i][j]+<span class="number">1</span>);</span><br><span class="line">            ans2=<span class="built_in">max</span>(ans2,f[i+<span class="number">1</span>][j+p[i].b]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans1+ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>背包</tag>
        <tag>$DP$</tag>
        <tag>贪心</tag>
        <tag>模拟</tag>
        <tag>差分</tag>
        <tag>排序</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1251 【餐巾计划问题】</title>
    <url>/2019/05/31/%E9%A2%98%E8%A7%A3%20P1251%20%E3%80%90%E9%A4%90%E5%B7%BE%E8%AE%A1%E5%88%92%E9%97%AE%E9%A2%98%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>一个餐厅在相继的$N$天里,每天需用的餐巾数不尽相同。假设第$i$天需要 $r_i$块餐巾$(i&#x3D;1,2,\cdots ,N)$。餐厅可以购买新的餐巾,每块餐巾的费用为$p$分;或者把旧餐巾送到快洗部,洗一块需$m$天,其费用为$f$分;或者送到慢洗部,洗一块需$n$天$(n&gt;m)$,其费用为$s$分$(s&lt;f)$。</p>
<p>每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和,要满足当天的需求量。</p>
<p>试设计一个算法为餐厅合理地安排好$N$天中餐巾使用计划,使总的花费最小。编程找出一个最佳餐巾使用计划。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>考虑费用流</p>
<p>其中$x \xrightarrow{a, b} y$代表从$u$向$v$连接一条流量为$x$，费用为$y$的有向边。</p>
<p>首先，我们将每天进行拆点，将一天拆成早上$a_1$和晚上$a_2$，每天晚上会收到脏餐巾（来源：当天早上用完的餐巾，在这道题中可理解为从源点$s$获得），每天早上又会受到干净的餐巾（来源：购买、快洗店、慢洗店）。</p>
<p>从源点$s$向每一天晚上连一条流量为当天所用餐巾$r_i$，费用为$0$的边，表示每天晚上$a_2$从源点$s$获得条脏餐巾。(由于我们把脏毛巾和干净毛巾看作不同的东西，所以不能从$a_1$转移过来),即$S \xrightarrow{r_i, 0} a_2$</p>
<p>每天早上要使用$r_i$块干净餐巾。所以连接$a_1 \xrightarrow{r_i, 0} T$</p>
<p>每天早上可以买任意多块餐巾。所以连接$S \xrightarrow{+\infty, p}$</p>
<p>快洗部用$m$天将任意多块餐巾洗干净。所以连接$i \xrightarrow{+\infty, f} (i + m)$</p>
<p>慢洗部用$n$天将任意多块餐巾洗干净。所以连接$i \xrightarrow{+\infty, s} (i + n)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 20000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,w,to,next;</span><br><span class="line">&#125;e[<span class="number">1000067</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,cur[NN],head[NN],dis[NN],vis[NN],inque[NN],cost,n,m,s,t,w[NN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].w=-w;</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                cost+=mi*e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (mn==used)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        vis[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (vis[t])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">            res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//     freopen(&quot;kkk.cpp&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();s=<span class="number">0</span>,t=n+n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> P=<span class="built_in">read</span>(),M=<span class="built_in">read</span>(),F=<span class="built_in">read</span>(),N=<span class="built_in">read</span>(),S=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(s,i+n,w[i],<span class="number">0</span>);<span class="comment">//每天晚上得到早上用剩的w[i]块脏餐巾</span></span><br><span class="line">         <span class="built_in">add</span>(i,t,w[i],<span class="number">0</span>);<span class="comment">//每天早上需要w[i]块干净餐巾</span></span><br><span class="line">        <span class="keyword">if</span> (i+M&lt;=n)<span class="built_in">add</span>(i+n,i+M,inf,F);<span class="comment">//第i天晚上送快洗部，第i+M天早上拿到干净餐巾 </span></span><br><span class="line">        <span class="keyword">if</span> (i+N&lt;=n)<span class="built_in">add</span>(i+n,i+N,inf,S);<span class="comment">//第i天晚上送慢洗部，第i+N天早上拿到干净餐巾 </span></span><br><span class="line">        <span class="keyword">if</span> (i!=n)<span class="built_in">add</span>(i+n,i+<span class="number">1</span>+n,inf,<span class="number">0</span>);<span class="comment">//保存到下一天 </span></span><br><span class="line">        <span class="built_in">add</span>(s,i,inf,P);<span class="comment">//购买新餐巾</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dinic</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>网络流$24$题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1268 树的重量</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P1268%20%E6%A0%91%E7%9A%84%E9%87%8D%E9%87%8F/</url>
    <content><![CDATA[<p>题意:给出一个树的叶子节点间的距离，求树的边权和</p>
<span id="more"></span>

<p>由于所有点均为叶子节点，很显然点$3$是从点$1$到点$2$的路径上分叉出来的</p>
<p>设蓝色部分长度为$len$，那么答案就是$g(1,2)+len$。$len$怎么求呢？显然，$len &#x3D;\frac{g(1,3)+g(2,3)-g(1,2)}{2}$。</p>
<p>$n&gt;3$的情况也同理。枚举$i$，看看点$n$是不是从点$1$~$i$的路径上分叉出来的，求出的最小$len$就是要加到答案里面去的。</p>
<p><img src="https://cdn.luogu.org/upload/pic/1522.png"></p>
<p><img src="https://cdn.luogu.org/upload/pic/1523.png"></p>
<p>如果认为点$4$是从$1$<del>$2$的路径上分叉出来的，答案就会加上红色部分的长度。但是红色部分长度显然有一部分是多余的。只有认为点$4$是从$1$</del>$3$的路径上分叉出来的，才能加上正确答案（也就是蓝色部分）。所以对于当前点我们要枚举是从那一条路径中分叉出来的，取最小值。</p>
<p>证明：因为在最小的情况下，不会有任何冲突的地方，这样加点，可以保证时时刻刻没有冲突，而没有冲突的情况下答案是唯一的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wln</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3000</span>][<span class="number">3000</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                a[i][j]=a[j][i]=<span class="built_in">read</span>();</span><br><span class="line">        ans=a[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="type">int</span> mn=<span class="number">2100000000</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;++j)&#123;</span><br><span class="line">                mn=<span class="built_in">min</span>(mn,(a[<span class="number">1</span>][i]+a[i][j]-a[<span class="number">1</span>][j])/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=mn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树相关</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1357 花园</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P1357%20%E8%8A%B1%E5%9B%AD/</url>
    <content><![CDATA[<p>题意:小$ L $有一座环形花园，沿花园的顺时针方向，他把各个花圃编号为 $1 \sim n$。花园 $1$ 和 $n$ 是相邻的。</p>
<p>他的环形花园每天都会换一个新花样，但他的花园都不外乎一个规则：任意相邻 $m$ 个花圃中都只有不超过 $k$ 个 C 形的花圃，其余花圃均为 P 形的花圃。</p>
<p>例如，若 $n&#x3D;10$ , $m&#x3D;5$ , $k&#x3D;3$ ，则</p>
<ul>
<li><code>CCPCPPPPCC</code> 是一种不符合规则的花圃。</li>
<li><code>CCPPPPCPCP</code> 是一种符合规则的花圃。</li>
</ul>
<p>请帮小 L 求出符合规则的花园种数对 $10^9+7$ 取模的结果。</p>
<p> $2 \leq n \le 10^{15}$，$2 \leq m \leq \min(n, 5)$，$1 \leq k \lt m$。</p>
<p>&lt;<span id="more"></span></p>
<p>我们用一个$m$位二进制数表示后$m$个花圃的状态，$1$表示为$M$.</p>
<p>那么令$f[i][j]$表示由状态$i$转移到状态$j$的方案数（$i$和$j$都合法，即1的个数不超过$k$）。($Floyd$矩阵)</p>
<p>所谓转移，是指如果$i$表示第$1$～$m$个花圃的状态，那么$j$代表第$2$～第$m+1$个花圃的状态。</p>
<p>那么怎么求得$f[i][j]$呢？</p>
<p>枚举一个长度为$m-1$的状态，在它前面加$0&#x2F;1$即是$i$，在它后面加$0&#x2F;1$即是$j$，在过程中判断$1$的个数会不会超过$k$即可。</p>
<p>由于是个环，所以实质上有$n+m$个花圃，第$n+1~n+m$个花圃就相当于第$1～m$个花圃，所以我们求的答案就是一个合法状态转移$n$次，转移回原状态的方案数之和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,k,t,o[<span class="number">39</span>+<span class="number">39</span>],ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">39</span>+<span class="number">39</span>][<span class="number">39</span>+<span class="number">39</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=t;++j)</span><br><span class="line">                <span class="keyword">if</span> (i==j)</span><br><span class="line">                    a[i][i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> a[i][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init0</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span> * (node a,node b)&#123;</span><br><span class="line">        node c;c.<span class="built_in">init0</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;=t;++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=t;++j)&#123;</span><br><span class="line">                    c.a[i][j]+=<span class="number">1ll</span>*a.a[i][k]*b.a[k][j]%mod;</span><br><span class="line">                    <span class="keyword">if</span> (c.a[i][j]&gt;mod)c.a[i][j]-=mod;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span> ^ (node a,<span class="type">int</span> p)&#123;</span><br><span class="line">        node res;</span><br><span class="line">        res.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">            p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            a=a*a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)&#123;</span><br><span class="line">        res+=x&amp;<span class="number">1</span>;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">    t=(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t&gt;&gt;<span class="number">1</span>;++i)&#123;</span><br><span class="line">        <span class="type">int</span> num=<span class="built_in">count</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (num&lt;=k)&#123;</span><br><span class="line">            o[i]=<span class="number">1</span>,o[i&lt;&lt;<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            f.a[i][i&lt;&lt;<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num+<span class="number">1</span>&lt;=k)&#123;</span><br><span class="line">            o[i|(<span class="number">1</span>&lt;&lt;m<span class="number">-1</span>)]=<span class="number">1</span>,o[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            f.a[i][i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            f.a[i|(<span class="number">1</span>&lt;&lt;m<span class="number">-1</span>)][i&lt;&lt;<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            f.a[i|(<span class="number">1</span>&lt;&lt;m<span class="number">-1</span>)][i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f=f^n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;++i)</span><br><span class="line">        <span class="keyword">if</span> (o[i])</span><br><span class="line">            ans=(ans+f.a[i][i])&gt;=mod?ans+f.a[i][i]-mod:ans+f.a[i][i];</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
        <tag>状压$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1858 【多人背包】</title>
    <url>/2019/06/08/%E9%A2%98%E8%A7%A3%20P1858%20%E3%80%90%E5%A4%9A%E4%BA%BA%E8%83%8C%E5%8C%85%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>求$01$背包前$k$优解的价值和</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>简单的背包问题。我们知道$01$背包的转移条件是$f_{j}&#x3D;max(f_{j},f_{j-v_{i}}+w_{i})$，也就是说$f_{j}$只会由$f_{j}$与$f_{j-v_{i}}$转移过来，我们考虑多加一维$k$优解，那么显然，$f_{j,k}$优解依然从$f_{j,p}(1\leqslant p\leqslant k)$与$f_{j-v_{i},p}(1\leqslant p\leqslant k)$转移过来。由于$k$很小，我们只需要用$f_{j,p}$与$f_{j-v_{i},p}$暴力判断第$k$优解更新答案即可。值得注意的是，这里的背包必须装满</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 60000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> v[N],f[N][<span class="number">50</span>],w[N],t[N],ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">read</span>(),V=<span class="built_in">read</span>(),n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)v[i]=<span class="built_in">read</span>(),w[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=V;++j)</span><br><span class="line">            f[i][j]=-inf;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=V;j&gt;=v[i];--j)&#123;</span><br><span class="line">            <span class="type">int</span> l1=<span class="number">1</span>,l2=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt&lt;=k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (f[j][l1]&gt;f[j-v[i]][l2]+w[i])</span><br><span class="line">                    t[++cnt]=f[j][l1++];</span><br><span class="line">                <span class="keyword">else</span> t[++cnt]=f[j-v[i]][l2++]+w[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p=<span class="number">1</span>;p&lt;=k;++p)f[j][p]=t[p];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)ans+=f[V][i];</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1453 【城市环路】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P1453%20%E3%80%90%E5%9F%8E%E5%B8%82%E7%8E%AF%E8%B7%AF%E3%80%91/</url>
    <content><![CDATA[<p>基环树上$dp$</p>
<span id="more"></span>

<p>会了这道题就可以顺便$A$了<a href="https://www.luogu.org/problemnew/show/P2607">P2607 [ZJOI2008]骑士</a></p>
<p>由于只有$n$条边，每个点之间互通，所以图就是一颗基环树</p>
<p>所以只需要$dfs$找环，在环上找任意一条边，枚举这条边的两端中其中一端不选(因为两端不能同时选，所以至少有一端不选)，然后进行树形$dp$即可，由于然后这道题就和<a href="https://www.luogu.org/problemnew/show/P1352">没有上司的舞会</a>一样了。</p>
<h3 id="dfs找环："><a href="#dfs找环：" class="headerlink" title="dfs找环："></a>dfs找环：</h3><p>一边走一边用一个$vis$数组标记，回溯时$vis$清零，如果当前点的儿子上有$vis$标记,那么这个点和它的儿子就在环上。</p>
<h3 id="树形-dp"><a href="#树形-dp" class="headerlink" title="树形$dp$:"></a>树形$dp$:</h3><p>设$f[u][0&#x2F;1]$表示u这个节点选$(0)$或不选$(1)$的最大价值（这里$v$表示u的所有子节点)</p>
<p>$f[u][1]&#x3D;\sum f[v][0]$</p>
<p>$f[u][0]&#x3D;\sum max(f[v][0],f[v][1])$</p>
<p>答案就是$f[root][0]$,这里的$root$就是枚举的一端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 393939*7</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now,la,n,ans,cnt,head[N],f[N][<span class="number">2</span>],vis[N],fa[N],v[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> rt,<span class="type">int</span> unrt)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>]=<span class="number">0</span>;f[u][<span class="number">1</span>]=v[u];vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa||(u==rt&amp;&amp;v==unrt))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (v!=rt)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v,u,rt,unrt);</span><br><span class="line">            f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">            f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">1</span>],f[v][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfss</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (vis[v])&#123;la=v;now=u;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="built_in">dfss</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lxy</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    now=u,la=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfss</span>(u,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(now,<span class="number">0</span>,now,la);</span><br><span class="line">    <span class="type">int</span> res=f[now][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(la,<span class="number">0</span>,la,now);</span><br><span class="line">    ans+=<span class="built_in">max</span>(res,f[la][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        v[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>()+<span class="number">1</span>,v=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            <span class="built_in">lxy</span>(i);</span><br><span class="line">    <span class="type">double</span> res=<span class="number">1.0</span>*K*ans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1552 [APIO2012]派遣</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20P1552%20%5BAPIO2012%5D%E6%B4%BE%E9%81%A3/</url>
    <content><![CDATA[<p>题意：$n$个点组成一棵树，每个点都有一个领导力和费用，可以让一个点当领导，然后在这个点的子树中选择一些费用之和不超过$m$的点，得到领导的领导力乘选择的点的个数（领导可不被选择）的利润。求利润最大值。 $n\leqslant100000$；</p>
<span id="more"></span>

<p>每个点构造一个大根堆，堆里的就是这个点的人。</p>
<p>往父亲那里合并堆，记录堆的大小，费用的总和。</p>
<p>从儿子合并完毕后，在每个节点，不断踢出费用最大的人，直到费用的总和$\leqslant m$这就是这个点的最优方案了。（显然，花费最小的都留下了）</p>
<p>对于每个点，用这个点的领导力乘堆的大小尝试更新答案即可。</p>
<p>注意：和子树合并的时候,$rt[x]&#x3D;merge(rt[x],rt[y])$注意是$rt[y]$因为这才是$y$的所属堆的入口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ll s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">ll ans,fa[<span class="number">300000</span>],size[<span class="number">300000</span>],p[<span class="number">300000</span>],sum[<span class="number">300000</span>],v[<span class="number">300000</span>],n,m,dist[<span class="number">300000</span>],f[<span class="number">300000</span>],s[<span class="number">2</span>][<span class="number">309009</span>],c[<span class="number">300000</span>],son[<span class="number">2</span>][<span class="number">300000</span>];</span><br><span class="line"><span class="function">ll <span class="title">merge</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x||!y)<span class="keyword">return</span> x|y;</span><br><span class="line">    <span class="keyword">if</span> (v[x]&lt;v[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    s[<span class="number">1</span>][x]=<span class="built_in">merge</span>(s[<span class="number">1</span>][x],y);</span><br><span class="line">    <span class="keyword">if</span> (dist[s[<span class="number">0</span>][x]]&lt;dist[s[<span class="number">1</span>][x]])<span class="built_in">swap</span>(s[<span class="number">0</span>][x],s[<span class="number">1</span>][x]);</span><br><span class="line">    dist[x]=dist[s[<span class="number">1</span>][x]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (ll i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        fa[i]=<span class="built_in">read</span>();v[i]=<span class="built_in">read</span>();p[i]=<span class="built_in">read</span>();</span><br><span class="line">        size[i]=<span class="number">1</span>;sum[i]=v[i];f[i]=i;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i=n;i&gt;<span class="number">1</span>;--i)&#123;</span><br><span class="line">        ll k=fa[i];</span><br><span class="line">        f[k]=<span class="built_in">merge</span>(f[i],f[k]);    </span><br><span class="line">        sum[k]+=sum[i];</span><br><span class="line">        size[k]+=size[i];</span><br><span class="line">        <span class="keyword">while</span> (sum[k]&gt;m)&#123;</span><br><span class="line">            sum[k]-=v[f[k]];</span><br><span class="line">            f[k]=<span class="built_in">merge</span>(s[<span class="number">0</span>][f[k]],s[<span class="number">1</span>][f[k]]);</span><br><span class="line">            --size[k];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,p[k]*size[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1345 [USACO5.4]奶牛的电信Telecowmunication</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P1345%20%5BUSACO5.4%5D%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication/</url>
    <content><![CDATA[<p>题意：求网络流图中最小<strong>割点</strong></p>
<span id="more"></span>

<p>一开始题意看成最小割边，把板子改了一下直接交，80(<del>这样都能有80</del>)</p>
<p>我们可以考虑“拆点”，即把一个点拆成两个点，中间连一条边权为1的边。</p>
<p>前一个点作为“入点”，别的点连边连入这里。</p>
<p>后一个点作为“出点”，出去的边从这里出去。</p>
<p>这样，只要我们切断中间那条边，就可以等效于除去这个点</p>
<p><img src="https://cdn.luogu.org/upload/pic/20620.png"></p>
<p>红色的边边权为$1$，黑色的边边权为$inf$。</p>
<p>原点和汇点的内部边权为$inf$，因为显然这两个点不能删除。</p>
<p>题面给的边删除没意义（因为我们要删点），所以也设为$inf$</p>
<p>网络流建反向边只是为了有”反悔”的机会，确保答案最优，所以在已有反向边时就没有必要建边圈为$0$的反向边了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,dis,next;</span><br><span class="line">&#125;e[<span class="number">400000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis,res,cnt=<span class="number">1</span>,head[<span class="number">400000</span>],inque[<span class="number">400000</span>],dep[<span class="number">400000</span>],n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(inque,<span class="number">0</span>,<span class="built_in">sizeof</span>(inque));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dep[v]&gt;dep[u]+<span class="number">1</span>)&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (v==t)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);inque[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t]&lt;<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==t) <span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> mi=<span class="number">0</span>,used=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (e[i].dis&amp;&amp;dep[v]==dep[u]+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(mn-used,e[i].dis)))&#123;</span><br><span class="line">                used+=mi;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                <span class="keyword">if</span> (used==mn)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())</span><br><span class="line">        <span class="keyword">while</span> (x=<span class="built_in">dfs</span>(s,<span class="number">0x3f3f3f3f</span>))res+=x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),s=<span class="built_in">read</span>()+n,t=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(i,i+n,<span class="number">1</span>),<span class="built_in">add</span>(i+n,i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u+n,v,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        <span class="built_in">add</span>(v+n,u,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">Dinic</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>最小割</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1550 [USACO08OCT]打井Watering Hole</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20P1550%20%5BUSACO08OCT%5D%E6%89%93%E4%BA%95Watering%20Hole/</url>
    <content><![CDATA[<p>题意:$Farmer John $的农场缺水了。</p>
<p>他决定将水引入到他的 $n$ 个牧场。他准备通过挖若干井，并在各块田中修筑水道来连通各块田地以供水。在第 $i$ 号田中挖一口井需要花费 $W_i$ 元。连接 $i$ 号田与 $j$ 号田需要 $P_{i,j}$（$P_{j,i}&#x3D;P_{i,j}$）元。</p>
<p>请求出 FJ 需要为使所有农场都与有水的农场相连或拥有水井所需要的最少钱数。</p>
<p>$1 \leqslant n \leqslant 300$，$1 \leqslant W_i \leqslant 10^5$，$1 \leqslant P_{i,j} \leqslant 10^5$。</p>
<span id="more"></span>

<p>做法最小生成树很容易发现，但是难点在于想单独打井，设一个源点$0$，把每个井与$0$连边，费用就是打井所需费用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,d;</span><br><span class="line">&#125;a[<span class="number">3000000</span>];</span><br><span class="line"><span class="type">int</span> cnt,x,n,m,ed,ans,f[<span class="number">400000</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.d&lt;b.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (f[k]==k)?k:(f[k]=<span class="built_in">find</span>(f[k]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bing</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="built_in">find</span>(x),v=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (u==v)<span class="keyword">return</span>;</span><br><span class="line">    f[u]=v;</span><br><span class="line">    ans+=d;</span><br><span class="line">    ++ed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">300000</span>;i++)f[i]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[++cnt].v=i;a[cnt].d=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span> (j&lt;i)</span><br><span class="line">                a[++cnt].u=j,a[cnt].v=i,a[cnt].d=x;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+cnt,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt&amp;&amp;ed&lt;=<span class="number">2</span>*n+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="built_in">bing</span>(a[i].u,a[i].v,a[i].d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1948 [USACO08JAN]电话线Telephone Lines</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P1948%20%5BUSACO08JAN%5D%E7%94%B5%E8%AF%9D%E7%BA%BFTelephone%20Lines/</url>
    <content><![CDATA[<p>题意:求原点$1$到$n$的所有路中的第$k+1$长的路最小</p>
<span id="more"></span>

<p>二分答案+$spfa$</p>
<p>题意：求原点$1$到$n$的所有路中的第$k+1$长的路最小。</p>
<p>因为题意中的答案要最小，我们贪心肯定要使$k$次免费的资格用完，那么最划算的方案肯定是拿最长的$k$条路使之免费，然后付第$k+1$长路的长度的钱。。。这样的贪心思路显然是正确的。</p>
<p>我们首先二分第$k+1$长的路的长度(即答案)，然后关键是如何判断正确性。我们考虑简化问题，对于长度小于二分出的答案的线段，因为不需要付价钱，所以可以将其权值看作是$0$;同理，大于二分的值的路径，我们将长度看作$1$(意味着我需要使用$1$次免费的资格)。我们跑一遍$spfa$，看到了$n$点的最短路的长度，如果大于$k$，则不行，缩小$r$范围继续二分;如果小于，则有可能更小，缩小$l$范围继续二分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,to,next;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis&lt;dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[<span class="number">400000</span>];</span><br><span class="line"><span class="type">int</span> n,m,k,o,head[<span class="number">400000</span>],cnt,dis[<span class="number">400000</span>],vis[<span class="number">400000</span>],u[<span class="number">400000</span>],w[<span class="number">400000</span>],v[<span class="number">400000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].dis=d;</span><br><span class="line">    e[cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(node&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">top</span>().to;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[x];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[y]&gt;dis[x]+e[i].dis)&#123;</span><br><span class="line">                dis[y]=dis[x]+e[i].dis;</span><br><span class="line">                q.<span class="built_in">push</span>(node&#123;dis[y],y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[n]&gt;k)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;o=<span class="number">1</span>;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        u[i]=<span class="built_in">read</span>(),v[i]=<span class="built_in">read</span>(),w[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="built_in">add</span>(u[i],v[i],mid&lt;w[i]),<span class="built_in">add</span>(v[i],u[i],mid&lt;w[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dijkstra</span>())r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1613 【跑路】</title>
    <url>/2019/05/26/%E9%A2%98%E8%A7%A3%20P1613%20%E3%80%90%E8%B7%91%E8%B7%AF%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有$n$个点，$m$条边，边权为一，每次都可以走$2^k$条边，问最多要走几次</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>考虑倍增，设$f_{i,j,k}$表示$i$到$j$是否能以走$2^k$条边相互到达。</p>
<p>可以用$Floyd$的方法求出$f$数组。</p>
<p>求完后，若$f_{i,j,k}&#x3D;1(0\leqslant k\leqslant 64)$,则连一条$i$到$j$的边权为$1$的边</p>
<p>最后再用$Floyd$求出$1$~$n$的最短路即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d[N][N],f[N][N][N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        f[u][v][<span class="number">0</span>]=<span class="number">1</span>;d[u][v]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p=<span class="number">1</span>;p&lt;=<span class="number">64</span>;++p)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                    <span class="keyword">if</span> (f[i][k][p<span class="number">-1</span>]&amp;f[k][j][p<span class="number">-1</span>])</span><br><span class="line">                        f[i][j][p]=<span class="number">1</span>,d[i][j]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">    cout&lt;&lt;d[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>$Floyd$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2050 【[NOI2012]美食节】</title>
    <url>/2019/06/01/%E9%A2%98%E8%A7%A3%20P2050%20%E3%80%90%5BNOI2012%5D%E7%BE%8E%E9%A3%9F%E8%8A%82%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有$n$个厨师$m$道菜，每种菜有$p_i$个人点，每个厨师$j$烧第$i$道菜要$t_{i,j}$分钟，所有人等菜时间之和为多少？</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p><a href="https://www.luogu.org/problemnew/show/P2053">P2053 [SCOI2007]修车</a>的加强版</p>
<p>我们就按照那题的方法建图</p>
<p>对于每个菜$i$</p>
<p>$S \stackrel{p_{i}, 0}{\longrightarrow}i$</p>
<p>然后建$n$层点，每层点有$m$个点，第$i$层的第$j$个点表示第$j$个厨师做第<strong>倒数</strong>$i$道菜,记为$c_{i,j}$。</p>
<p>$c_{i,j} \stackrel{1, 0}{\longrightarrow}t$</p>
<p>假设第$j$个厨师做第倒数$k$道菜，那么对于菜$i$，向其连一条流量为$1$，费用为$k\times t_{i,j}$的边。这表示第$j$个厨师做的倒数第$k$道菜是菜$i$，那么就要做$t_{i,j}$这么长的时间，有$k$个人要等这么长的时间。</p>
<p>$i \stackrel{1,k\times t_{i,j}}{\longrightarrow}c_{j,k}$</p>
<p>然后，我们会发现，这样写会$T$成傻$*$</p>
<p>然后我们就必须进行优化</p>
<p>我们发现一个性质，如果经过$c_{i,j}$的流为$0$,那么经过$c_{i+1,j}\sim c_{n,j}$的流也一定为$0$.也就是说这些点根本不用建。</p>
<p>于是我们先建$n$个菜和第一层点，并连接第一层点和$t$,跑一边$spfa$</p>
<p>一旦一条增广路被用掉了（也就是$c_{j,k}$被用掉了），那么我们就把$c_{j,k+1}$加上去，再跑$spfa$</p>
<p>所以我们考虑用$EK$写费用流，因为$EK$一次只找一条增广路，与题意相符，且跑费用流的效率和$Dinic$差不多快(我也不知道为什么)。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 400000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,dis,w,next;</span><br><span class="line">&#125;e[<span class="number">1007000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cr,flow[N],lxy=<span class="number">1</span>,pri[N],pre[N],ma[<span class="number">500</span>][<span class="number">500</span>],a[N],p,w[N],cnt=<span class="number">1</span>,head[N],dis[N],inque[N],vis[N],cur[N],cost,n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].w=-w;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n+(x<span class="number">-1</span>)*p+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">chushi</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (k-n<span class="number">-1</span>)/p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">waittime</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (k-n<span class="number">-1</span>)%p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);<span class="built_in">memset</span>(flow,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(flow));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                pre[v]=u;pri[v]=i;flow[v]=<span class="built_in">min</span>(flow[u],e[i].dis);</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mcmf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        res+=flow[t];</span><br><span class="line">        cost+=flow[t]*dis[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> now=t;now!=s;now=pre[now])&#123;</span><br><span class="line">            e[pri[now]].dis-=flow[t];</span><br><span class="line">            e[pri[now]^<span class="number">1</span>].dis+=flow[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lxy=pre[t];</span><br><span class="line">        <span class="built_in">add</span>(lxy+<span class="number">1</span>,t,<span class="number">1</span>,<span class="number">0</span>);<span class="comment">//向终点连边 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;++cr;</span><br><span class="line">            <span class="built_in">add</span>(i,lxy+<span class="number">1</span>,<span class="number">1</span>,ma[i][<span class="built_in">chushi</span>(lxy+<span class="number">1</span>)]*<span class="built_in">waittime</span>(lxy+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=<span class="built_in">read</span>(),p+=w[i],<span class="built_in">add</span>(s,i,w[i],<span class="number">0</span>);</span><br><span class="line">    s=<span class="number">0</span>,t=n+p*m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123; </span><br><span class="line">            ma[i][j]=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(i,<span class="built_in">id</span>(j,<span class="number">1</span>),<span class="number">1</span>,ma[i][j]);</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">id</span>(i,<span class="number">1</span>),t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">mcmf</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>分层图网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1972 [SDOI2009]HH的项链</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20P1972%20%5BSDOI2009%5DHH%E7%9A%84%E9%A1%B9%E9%93%BE/</url>
    <content><![CDATA[<p>题意概括：给定一个长度为$N$的自然数序列$(N\leqslant500000$,数的范围$0$到$1000000$之间的整数)，有$M$个询问，每个询问两个整数$l,r$表示$l$~$r$区间内有几个不同的数$(M\leqslant500000)$</p>
<span id="more"></span>

<p>这道题我们考虑离线+树状数组。</p>
<p>设$last_{i}$表示$1$<del>当前枚举到的右端点 这个序列中i这个数最后出现的位置，如果要求$l$</del>$r$之间不同的数个数，只要求有几个$last_{i}$在$l$<del>$r$之间即可,因为我们可以将当前不为空的$last_{i}$分成两类，一类为大小在$1$</del>$(l-1)$中，因为$last_{i}$表示最后出现的位置，所以在$l$之后不可能有$i$这个数，我们将这一类数设为$a$;另一类为大小在$l$<del>$r$中，由于$last_{i}$的定义，所以$i$这个数一定在$l$</del>$r$之间，我们将这一类数设为$b$。显然答案就是$b$，所以我们只需要求$sum_{r}-sum_{l-1}$即可(因为$sum_{r}&#x3D;a+b,sum_{l-1}&#x3D;a)$。 </p>
<p>我们将询问保存下来，设为$b$数组，将$b$数组按照右端点排序，从让$i&#x3D;1$~$n$枚举右端点，若$i&#x3D;b[j].r$,则$j++$并统计答案，然后更新$last$数组。</p>
<p>单点修改，区间查询，显然可以用树状数组维护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,num;</span><br><span class="line">&#125;b[<span class="number">3000000</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">3000000</span>],a[<span class="number">3000000</span>],n,m,last[<span class="number">3000000</span>],c[<span class="number">3000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        c[x]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x-=<span class="built_in">lowbit</span>(x))</span><br><span class="line">        res+=c[x];</span><br><span class="line">    <span class="keyword">return</span> res;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=<span class="built_in">read</span>();</span><br><span class="line">    m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        b[i].l=<span class="built_in">read</span>(),b[i].r=<span class="built_in">read</span>(),b[i].num=i;</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">change</span>(i,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">change</span>(last[a[i]],<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (b[t].r==i)&#123;</span><br><span class="line">            ans[b[t].num]=<span class="built_in">query</span>(b[t].r)-<span class="built_in">query</span>(b[t].l<span class="number">-1</span>);</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        last[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1967 货车运输</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P1967%20%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93/</url>
    <content><![CDATA[<p>题意：$n$个节点，$m$条边，$q$个询问，对于每个询问求图中两点间所有路径中最小边权的最大值</p>
<span id="more"></span>

<p>对于一条边，我们可以走另一条最小边权的最大值；比这条边的权值大的路径，所以对于原图，我们只需求最大生成树，然后求$LCA$即可，在倍增求$LCA$的同时算一个数组$w$表示最小边权的最大值；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,to,next;</span><br><span class="line">&#125;e[<span class="number">300000</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,d;</span><br><span class="line">&#125;ed[<span class="number">300000</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wln</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,head[<span class="number">300000</span>],fa[<span class="number">300000</span>],dep[<span class="number">300000</span>],f[<span class="number">300000</span>][<span class="number">22</span>],w[<span class="number">300000</span>][<span class="number">22</span>],cnt,vis[<span class="number">300000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> fa[k]==k?k:fa[k]=<span class="built_in">find</span>(fa[k]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;<span class="keyword">return</span> a.d&gt;b.d;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(ed+<span class="number">1</span>,ed+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)fa[i]=i;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(ed[i].u)==<span class="built_in">find</span>(ed[i].v)) <span class="keyword">continue</span>;</span><br><span class="line">        fa[<span class="built_in">find</span>(ed[i].u)]=<span class="built_in">find</span>(ed[i].v);</span><br><span class="line">        <span class="built_in">add</span>(ed[i].u,ed[i].v,ed[i].d);</span><br><span class="line">        <span class="built_in">add</span>(ed[i].v,ed[i].u,ed[i].d);</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">deal_lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;++i)</span><br><span class="line">        f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>],w[u][i]=<span class="built_in">min</span>(w[u][i<span class="number">-1</span>],w[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">        f[v][<span class="number">0</span>]=u;w[v][<span class="number">0</span>]=e[i].dis;</span><br><span class="line">        <span class="built_in">deal_lca</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">2100000000</span>;</span><br><span class="line">    <span class="keyword">if</span> (dep[x]&lt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[f[x][i]]&gt;=dep[y])res=<span class="built_in">min</span>(res,w[x][i]),x=f[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x==y)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x][i]!=f[y][i])</span><br><span class="line">            res=<span class="built_in">min</span>(res,<span class="built_in">min</span>(w[x][i],w[y][i])),x=f[x][i],y=f[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(res,<span class="built_in">min</span>(w[x][<span class="number">0</span>],w[y][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        ed[i].u=<span class="built_in">read</span>(),ed[i].v=<span class="built_in">read</span>(),ed[i].d=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">Kruskal</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])&#123;</span><br><span class="line">            dep[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">deal_lca</span>(i,<span class="number">0</span>);</span><br><span class="line">            f[i][<span class="number">0</span>]=i;</span><br><span class="line">            w[i][<span class="number">0</span>]=<span class="number">2100000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            f[j][i]=f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            w[j][i]=<span class="built_in">min</span>(w[j][i<span class="number">-1</span>],w[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">wln</span>(<span class="built_in">lca</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最小生成树</tag>
        <tag>$LCA$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2151 【[SDOI2009]HH去散步】</title>
    <url>/2019/05/01/%E9%A2%98%E8%A7%A3%20P2151%20%E3%80%90%5BSDOI2009%5DHH%E5%8E%BB%E6%95%A3%E6%AD%A5%E3%80%91/</url>
    <content><![CDATA[<p>题意:HH有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间 内，走过一定的距离。 但是同时HH又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。 又因为HH是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多 少种散步的方法。</p>
<p>现在给你学校的地图（假设每条路的长度都是一样的都是$1$），问长度为$t$，从给定地 点$A$走到给定地点$B$共有多少条符合条件的路径</p>
<span id="more"></span>

<p>如果没有限制条件不能沿着刚走过的道路走回，那就是裸的矩阵快速幂优化$DP$了。</p>
<p>但是，这个限制条件使得无论怎么构造矩阵，普通的矩阵快速幂不能符合要求</p>
<p>这时，我们就要向别的方向想了，普通的矩阵快速幂是点之间转移，那我们能不能边与边之间转移呢$？$</p>
<p>只需要在矩阵中将除了当前边与当前边的反向边以外的所有边对的权值都赋为$1$,然后进行矩阵快速幂即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 45989</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ed</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">&#125;e[<span class="number">393939</span>];</span><br><span class="line"><span class="type">int</span> cnt,ans,n,m,t,A,B;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">207</span>][<span class="number">207</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init0</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">                a[i][j]=i==j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span> *(node a,node b)&#123;</span><br><span class="line">        node res;res.<span class="built_in">init0</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)&#123;</span><br><span class="line">                    res.a[i][k]=(res.a[i][k]+a.a[i][j]*b.a[j][k]%mod)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span> ^(node x,<span class="type">int</span> p)&#123;</span><br><span class="line">        node res;res.<span class="built_in">init1</span>();</span><br><span class="line">        <span class="keyword">while</span> (p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p&amp;<span class="number">1</span>)res=res*x;</span><br><span class="line">            x=x*x;</span><br><span class="line">            p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;desire.in&quot;,&quot;r&quot;, stdin); freopen(&quot;desire.out&quot;, &quot;w&quot;, stdout); </span></span><br><span class="line">    cnt=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),t=<span class="built_in">read</span>(),A=<span class="built_in">read</span>(),B=<span class="built_in">read</span>();</span><br><span class="line">    f.<span class="built_in">init0</span>();n=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        e[++n]=(ed)&#123;u,v&#125;;</span><br><span class="line">        e[++n]=(ed)&#123;v,u&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> ((i!=j)&amp;&amp;((i^<span class="number">1</span>)!=j)&amp;&amp;(e[i].v==e[j].u))</span><br><span class="line">                f.a[i][j]=<span class="number">1</span>;</span><br><span class="line">    f=f^(t<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (e[i].u==A)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">if</span> (e[j].v==B)</span><br><span class="line">                    ans=(ans+f.a[i][j])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2045 【方格取数加强版】</title>
    <url>/2019/06/08/%E9%A2%98%E8%A7%A3%20P2045%20%E3%80%90%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E5%8A%A0%E5%BC%BA%E7%89%88%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给出一个$n\times n$的矩阵,每一格有一个非负整数$a_{i,j},(a_i,j\leqslant 1000)$现在从$(1,1)$出发,可以往右或者往下走,最后到达$(n,n),$每达到一格,把该格子的数取出来,该格子的数就变成$0$,这样一共走$K$次,现在要求$K$次所达到的方格的数的和最大</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>源点$s$和汇点$t$分别连向$(1,1),(n,n),$容量为$k$，费用为$0$，仅表示一共可以走k次；<br>对于方格中的每个点i，进行拆点，分别为$i_{1}<del>$和$i_{2}$。$i_1</del>$和$i_{2}~$之间连两条边，一条容量为$1$，费用为$a_{i,j}$，表示每个点的数只可以取一次；另一条容量为$\infty$，费用为$0$，仅表示可以经过无数次；<br>对于在其下方或右边点的点，连一条容量为$\infty$，费用为$0$的边</p>
<p>最后跑最大费用最大流即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 40000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,dis,w,next;</span><br><span class="line">&#125;e[<span class="number">1007000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,head[N],dis[N],n,m,flow[N],pre[N],pri[N],rt,in[N],leaf[N],inque[N],k,vis[N],x[N],y[N],a[N],b[N],cur[N],cost,w[N],s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].w=-w;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)dis[i]=-inf;</span><br><span class="line">    <span class="built_in">memset</span>(flow,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(flow));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&lt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                pre[v]=u;pri[v]=i;</span><br><span class="line">                flow[v]=<span class="built_in">min</span>(flow[u],e[i].dis);</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]&gt;-inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        res+=flow[t];</span><br><span class="line">        cost+=flow[t]*dis[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> now=t;now!=s;now=pre[now])&#123;</span><br><span class="line">            e[pri[now]].dis-=flow[t];</span><br><span class="line">            e[pri[now]^<span class="number">1</span>].dis+=flow[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*n+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();s=<span class="number">0</span>,m=n*n,t=m+m+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(s,<span class="built_in">id</span>(<span class="number">1</span>,<span class="number">1</span>),k,<span class="number">0</span>);<span class="built_in">add</span>(<span class="built_in">id</span>(n,n)+m,t,k,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i,j)+m,<span class="number">1</span>,<span class="built_in">read</span>());</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i,j)+m,inf,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (j!=n)<span class="built_in">add</span>(<span class="built_in">id</span>(i,j)+m,<span class="built_in">id</span>(i,j+<span class="number">1</span>),inf,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i!=n)<span class="built_in">add</span>(<span class="built_in">id</span>(i,j)+m,<span class="built_in">id</span>(i+<span class="number">1</span>,j),inf,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">Dinic</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2052 [NOI2011]道路修建</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P2052%20%5BNOI2011%5D%E9%81%93%E8%B7%AF%E4%BF%AE%E5%BB%BA/</url>
    <content><![CDATA[<p>题意：给定一棵有$n$个节点的树，树上每条边花费的价格是这条边两侧的点的数量的差的绝对值与这条边长度的积。求这棵树的总花费。</p>
<span id="more"></span>

<p>随便选一个点作为根节点(这里选用节点$1$)，我们可以对这棵树进行$dfs$计算出每个点的$size$，然后就知道这条边的贡献为$abs(n-2\times size_{v})\times w_{i}$，其中$v$为这条边的儿子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll dis,to,next;</span><br><span class="line">&#125;e[<span class="number">3000000</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wln</span><span class="params">(ll x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ll s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line">ll head[<span class="number">3000000</span>],size[<span class="number">3000000</span>],n,ans,cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(ll u,ll v,ll d)</span></span>&#123;</span><br><span class="line">    e[++cnt].dis=d;</span><br><span class="line">    e[cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u,ll fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        ll v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(ll u,ll fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        ll v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=e[i].dis*<span class="built_in">abs</span>(size[v]*<span class="number">2</span>-n);</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (ll i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        size[i]=<span class="number">1</span>;</span><br><span class="line">        ll u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),d=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v,d);<span class="built_in">add</span>(v,u,d);</span><br><span class="line">    &#125;size[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2325 【[SCOI2005]王室联邦】</title>
    <url>/2019/05/19/%E9%A2%98%E8%A7%A3%20P2325%20%E3%80%90%5BSCOI2005%5D%E7%8E%8B%E5%AE%A4%E8%81%94%E9%82%A6%E3%80%91/</url>
    <content><![CDATA[<p>  题意:把一个有$n$个点的树划分成若干个<strong>省</strong>，要求每个省至少要有$B$个城市，最多可以有$3B$个城市。</p>
<span id="more"></span>

<p>我们可以考虑这样一种构造方法：</p>
<p>我们$dfs$整棵树，处理当前节点$u$时，将其子节点进行分块，如果需要进行分块的节点数不能整除块的大小，则将未被分块的子节点与$u$分在同一个块。</p>
<p>枚举$u$的每个子节点$v$，递归处理子树后，将每个子节点返回的未被分块的节点添加到集合$S$中，一旦$\vert S\vert\geqslant size$就把$S$作为一个新的块并将$u$作为省会，然后清空$S$并继续枚举$v$。</p>
<p>处理完所有子树后，将$u$也加入到集合$S$中，此时在$S$中的节点为未被分块的节点，将被返回到上一层，显然$S$的大小最大为$size$,$size-1$个子树节点$+u$节点本身。</p>
<p>由于返回的集合的大小最大为$size$，对于一个子树会对集合最多增加$B-1$个节点，那么每个块的大小最大为$2B-1,$满足条件。</p>
<p>在$dfs$结束后，集合$S$中可能还有节点（最多有$B$个），那么我们把这$ B$个节点并入最后一个块（以根节点为省会的最后一个块，块的大小最大为 $2B-1$）中，那么这个块的大小最大为$3B-1$，符合条件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,top,head[N],sh[N],K,col[N],st[N],n,B;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=top;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        <span class="keyword">if</span> (top-now&gt;=B)&#123;</span><br><span class="line">            sh[++K]=u;</span><br><span class="line">            <span class="keyword">while</span> (top&gt;now)col[st[top--]]=K;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st[++top]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),B=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n==B)sh[++K]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (top)col[st[top--]]=K;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,col[i]);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,sh[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树分块</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2048 【[NOI2010]超级钢琴】</title>
    <url>/2020/02/20/%E9%A2%98%E8%A7%A3%20P2048%20%E3%80%90%5BNOI2010%5D%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给$n$个数，求数字和前$k$大的区间的和</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>我们考虑先找全局最大值，再删去全局最大值，找次大值，然后删去，直到找到第$k$大值。</p>
<p>枚举左端点，此时可行的右端点是一个区间$[i+L-1,min(i+R-1,n)]$,可以搞一个结构体$\left( i,i+L-1,min(i+R-1,n),\max\limits_{j&#x3D;i+L-1}^{min(i+R-1,n)}sum[j],loc\right),loc$表示$max;sum[j]$的位置$j,$然后把它扔到堆里，堆中比较$\max\limits_{j&#x3D;i+L-1}^{min(i+R-1,n)}sum[j]-sum[i-1]$</p>
<p>全局最大值取堆顶${x,l,r,mx,loc}$,然后弹出，放入$\left(x,l,loc-1,\max\limits_{j&#x3D;l}^{loc-1}sum[j],nloc_1\right)$和<br>$\left(x,loc+1,r,\max\limits_{j&#x3D;loc+1}^{r}sum[j],nloc_2\right)$</p>
<p>这个东西显然是对的</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500200</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> lg[N],n,m,L,R;</span><br><span class="line">ll ans,sum[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,loc;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f[N][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rec</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,l,r;node v;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(rec a,rec b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.v.v-sum[a.x<span class="number">-1</span>]&lt;b.v.v-sum[b.x<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;rec&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=lg[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f[l][s],f[r-(<span class="number">1</span>&lt;&lt;s)+<span class="number">1</span>][s]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),L=<span class="built_in">read</span>(),R=<span class="built_in">read</span>();lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        f[i][<span class="number">0</span>]=(node)&#123;sum[i]=sum[i<span class="number">-1</span>]+<span class="built_in">read</span>(),i&#125;,lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;++i)</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (i+L<span class="number">-1</span>&lt;=n)</span><br><span class="line">        q.<span class="built_in">push</span>((rec)&#123;i,i+L<span class="number">-1</span>,<span class="built_in">min</span>(i+R<span class="number">-1</span>,n),<span class="built_in">query</span>(i+L<span class="number">-1</span>,<span class="built_in">min</span>(i+R<span class="number">-1</span>,n))&#125;);</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        rec u=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (u.l&lt;u.v.loc)q.<span class="built_in">push</span>((rec)&#123;u.x,u.l,u.v.loc<span class="number">-1</span>,<span class="built_in">query</span>(u.l,u.v.loc<span class="number">-1</span>)&#125;);</span><br><span class="line">        <span class="keyword">if</span> (u.v.loc&lt;u.r)q.<span class="built_in">push</span>((rec)&#123;u.x,u.v.loc+<span class="number">1</span>,u.r,<span class="built_in">query</span>(u.v.loc+<span class="number">1</span>,u.r)&#125;);</span><br><span class="line">        ans+=u.v.v-sum[u.x<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>$st$表</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2403 【[SDOI2010]所驼门王的宝藏】</title>
    <url>/2019/05/01/%E9%A2%98%E8%A7%A3%20P2403%20%E3%80%90%5BSDOI2010%5D%E6%89%80%E9%A9%BC%E9%97%A8%E7%8E%8B%E7%9A%84%E5%AE%9D%E8%97%8F%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2403">题面</a></p>
<span id="more"></span>

<p>$Tarjan+toposort$的经典套路题吧，$Tarjan+toposort$应该一眼就能看出来，但是发现对于第$1$,$2$种边连边显然会超时，这里用了一种比较无脑简单的方法(像我这种小蒟蒻都能想出来肯定简单啊)，这里以第$1$种为例(第二种类比一下就可以了)</p>
<p>若有多个第一种门在某一行，那么这些门都是可以互相到达的，但是我们两两之间连$n^2$的边显然很愚蠢，只需要连成一个环即可(第$1$个连第$2$个，第$2$个连第$3$个，最后一个连第$1$个)，在这个环上的其他所有点，只需从环上任意一点连出去即可(像对于网络流时经常用的建一个虚点连接两边优化$n^2$连边的方法应该也可以)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1003000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 19260817</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node1</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,to,next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;ll,<span class="type">int</span>&gt;mp,ed;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;x[N],y[N];</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,dy[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> opt[N],R,C,m,u[N],v[N],cnt=<span class="number">1</span>,head[N],dfn[N],low[N],ans,f[N],st[N],top,num,col,in[N],w[N],color[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].u=u;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">h</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*(x<span class="number">-1</span>)*C+<span class="number">1ll</span>*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ee</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span>*(x<span class="number">-1</span>)*col+<span class="number">1ll</span>*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;</span><br><span class="line">    st[++top]=u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!color[v])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[u]==dfn[u])&#123;</span><br><span class="line">        ++col;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ++w[col];color[st[top--]]=col;</span><br><span class="line">        &#125;<span class="keyword">while</span> (st[top+<span class="number">1</span>]!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=col;++i)<span class="keyword">if</span> (!in[i])q.<span class="built_in">push</span>(i),f[i]=w[i];</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            --in[v];</span><br><span class="line">            f[v]=<span class="built_in">max</span>(f[v],f[u]+w[v]);</span><br><span class="line">            <span class="keyword">if</span> (!in[v])q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m=<span class="built_in">read</span>(),R=<span class="built_in">read</span>(),C=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        u[i]=<span class="built_in">read</span>(),v[i]=<span class="built_in">read</span>(),opt[i]=<span class="built_in">read</span>();</span><br><span class="line">        mp[<span class="built_in">h</span>(u[i],v[i])]=i;</span><br><span class="line">        x[u[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">        y[v[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=R;++i)&#123;</span><br><span class="line">        <span class="type">int</span> st=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (st&lt;x[i].<span class="built_in">size</span>()&amp;&amp;opt[x[i][st]]!=<span class="number">1</span>)++st;<span class="type">int</span> last;</span><br><span class="line">        <span class="keyword">if</span> (st!=x[i].<span class="built_in">size</span>())&#123;++cnt;last=x[i][st];&#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt)<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;st;++j)<span class="built_in">add</span>(last,x[i][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=st+<span class="number">1</span>;j&lt;x[i].<span class="built_in">size</span>();++j)</span><br><span class="line">            <span class="keyword">if</span> (opt[x[i][j]]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">add</span>(last,x[i][j]);</span><br><span class="line">                last=x[i][j];++cnt;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="built_in">add</span>(x[i][st],x[i][j]);</span><br><span class="line">        <span class="keyword">if</span> (cnt&gt;<span class="number">1</span>)<span class="built_in">add</span>(last,x[i][st]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;++i)&#123;</span><br><span class="line">        <span class="type">int</span> st=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (st&lt;y[i].<span class="built_in">size</span>()&amp;&amp;opt[y[i][st]]!=<span class="number">2</span>)++st;<span class="type">int</span> last;</span><br><span class="line">        <span class="keyword">if</span> (st!=y[i].<span class="built_in">size</span>())&#123;++cnt;last=y[i][st];&#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt)<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;st;++j)<span class="built_in">add</span>(last,y[i][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=st+<span class="number">1</span>;j&lt;y[i].<span class="built_in">size</span>();++j)</span><br><span class="line">            <span class="keyword">if</span> (opt[y[i][j]]==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">add</span>(last,y[i][j]);</span><br><span class="line">                last=y[i][j];++cnt;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="built_in">add</span>(y[i][st],y[i][j]);&#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt&gt;<span class="number">1</span>)<span class="built_in">add</span>(last,y[i][st]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="keyword">if</span> (opt[i]==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ii=<span class="number">0</span>;ii&lt;<span class="number">8</span>;++ii)&#123;</span><br><span class="line">                <span class="type">int</span> x=u[i]+dx[ii],y=v[i]+dy[ii];</span><br><span class="line">                <span class="keyword">if</span> (!mp[<span class="built_in">h</span>(x,y)])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">add</span>(i,mp[<span class="built_in">h</span>(x,y)]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            <span class="built_in">Tarjan</span>(i);</span><br><span class="line">    <span class="type">int</span> tot=cnt;<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=e[i].u,v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (color[u]!=color[v])&#123;</span><br><span class="line">            <span class="keyword">if</span> (ed[<span class="built_in">ee</span>(color[u],color[v])])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">add</span>(color[u],color[v]);</span><br><span class="line">            ed[<span class="built_in">ee</span>(color[u],color[v])]=<span class="number">1</span>;</span><br><span class="line">            ++in[color[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topo</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=col;++i)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>连边优化</tag>
        <tag>$Tarjan$</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2414 【[NOI2011]阿狸的打字机】</title>
    <url>/2019/05/24/%E9%A2%98%E8%A7%A3%20P2414%20%E3%80%90%5BNOI2011%5D%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>打字机上只有$28$个按键，分别印有$26$个小写英文字母和$’B’$、$’P’$两个字母。这个打字机是这样工作的：</p>
<p>输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。</p>
<p>按一下印有$’B’$的按键，打字机凹槽中最后一个字母会消失。 </p>
<p>按一下印有$’P’$的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。 例如，阿狸输入$aPaPBbP$，纸上被打印的字符如下：$a aa ab$我们把纸上打印出来的字符串从$1$开始顺序编号，一直到$n$。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数$(x,y)($其中$1\leqslant x,y\leqslant n)$，打字机会显示第$x$个打印的字符串在第$y$个打印的字符串中出现了多少次。 </p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution:$"></a>$Solution:$</h2><p>先无脑搭出一只$AC$自动机再说，然后再考虑各档分的做法</p>
<h3 id="40"><a href="#40" class="headerlink" title="$40$"></a>$40$</h3><p>给每个串的结束位置都标记一下，给$AC$自动机中的每个节点记录一个父亲节点，然后对于每个串的结束位置都暴力往上跳，计算有几个被标记过的节点即可</p>
<h3 id="70-1"><a href="#70-1" class="headerlink" title="$70(1)$"></a>$70(1)$</h3><p>这样对于每一个询问都要暴力往上跳</p>
<p>如果对于某个串有重复的多次询问</p>
<p>那么就会多很多次没有任何意义的计算</p>
<p>所以，可以离线把所有询问都按照$y$排序</p>
<p>$y$相同的询问将从$y$向上跳碰到的标记记录下来，最后一起统计</p>
<h3 id="70-2"><a href="#70-2" class="headerlink" title="$70(2)$"></a>$70(2)$</h3><p>原来是$y$的某个节点往上跳能不能到达$x$</p>
<p>现在反过来：</p>
<p>$x$往下跳能够到达几个$y$的节点</p>
<p>如果把$y$这个字符串所有的节点全部打上一个$1$的标记</p>
<p>那么，每次就变成了求$x$结束位置的子树和</p>
<p>而一个点的子树在$dfs$序上一定是连续的一段</p>
<p>单点修改，区间查询，考虑用树状数组打标记</p>
<h3 id="100"><a href="#100" class="headerlink" title="$100$"></a>$100$</h3><p>每次把串插入进树状数组会导致很多的串会有重复</p>
<p>考虑对$Trie$进行$dfs$</p>
<p>对于每个节点访问到的时候对它的$dfs$序打一个$+1$,结束的时候对它的$dfs$序打一个$-1$</p>
<p>每次访问到一个结束节点的时候，一定是有且仅有这个结束节点对应的串的所有节点被打了标记，这样就可以直接回答这个串作为$y$的所有询问了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><h3 id="40-1"><a href="#40-1" class="headerlink" title="$40$"></a>$40$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> tot,K,ch[N][<span class="number">26</span>],fail[N],fa[N],w[N],ed[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)<span class="keyword">if</span> (ch[<span class="number">0</span>][i])q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">            <span class="keyword">if</span> (ch[now][i])</span><br><span class="line">                fail[ch[now][i]]=ch[fail[now]][i],q.<span class="built_in">push</span>(ch[now][i]);</span><br><span class="line">            <span class="keyword">else</span> ch[now][i]=ch[fail[now]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> now=ed[y];now;now=fa[now])</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t=now;t;t=fail[t])</span><br><span class="line">            <span class="keyword">if</span> (w[t]==x)&#123;</span><br><span class="line">                ++res;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            now=fa[now];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">            ed[++K]=now;w[now]=K;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ch[now][v])ch[now][v]=++tot,fa[tot]=now;</span><br><span class="line">            now=ch[now][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="70-1-1"><a href="#70-1-1" class="headerlink" title="$70(1)$"></a>$70(1)$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,num;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> cnt[N],tot,K,ch[N][<span class="number">26</span>],ans[N],fail[N],fa[N],w[N],ed[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)<span class="keyword">if</span> (ch[<span class="number">0</span>][i])q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">            <span class="keyword">if</span> (ch[now][i])</span><br><span class="line">                fail[ch[now][i]]=ch[fail[now]][i],q.<span class="built_in">push</span>(ch[now][i]);</span><br><span class="line">            <span class="keyword">else</span> ch[now][i]=ch[fail[now]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> now=ed[y];now;now=fa[now])</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t=now;t;t=fail[t])&#123;</span><br><span class="line">            ++cnt[w[t]];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            now=fa[now];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">            ed[++K]=now;w[now]=K;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ch[now][v])ch[now][v]=++tot,fa[tot]=now;</span><br><span class="line">            now=ch[now][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)q[i].x=<span class="built_in">read</span>(),q[i].y=<span class="built_in">read</span>(),q[i].num=i;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=n;i=j)&#123;</span><br><span class="line">        <span class="built_in">query</span>(q[i].y);</span><br><span class="line">        <span class="keyword">while</span> (q[i].y==q[j].y)ans[q[j].num]=cnt[q[j].x],++j;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="70-2-1"><a href="#70-2-1" class="headerlink" title="$70(2)$"></a>$70(2)$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,num;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> cnt[N],tot,K,ch[N][<span class="number">26</span>],ans[N],fail[N],fa[N],w[N],ed[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)<span class="keyword">if</span> (ch[<span class="number">0</span>][i])q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">            <span class="keyword">if</span> (ch[now][i])</span><br><span class="line">                fail[ch[now][i]]=ch[fail[now]][i],q.<span class="built_in">push</span>(ch[now][i]);</span><br><span class="line">            <span class="keyword">else</span> ch[now][i]=ch[fail[now]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> now=ed[y];now;now=fa[now])</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t=now;t;t=fail[t])&#123;</span><br><span class="line">            ++cnt[w[t]];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            now=fa[now];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">            ed[++K]=now;w[now]=K;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ch[now][v])ch[now][v]=++tot,fa[tot]=now;</span><br><span class="line">            now=ch[now][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)q[i].x=<span class="built_in">read</span>(),q[i].y=<span class="built_in">read</span>(),q[i].num=i;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=n;i=j)&#123;</span><br><span class="line">        <span class="built_in">query</span>(q[i].y);</span><br><span class="line">        <span class="keyword">while</span> (q[i].y==q[j].y)ans[q[j].num]=cnt[q[j].x],++j;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="100-1"><a href="#100-1" class="headerlink" title="$100$"></a>$100$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,num;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> ql[N],qr[N],cc[N][<span class="number">26</span>],ttt,head[N],dfn[N],low[N],dfsnum,c[<span class="number">100007</span>],cnt[N],tot,K,ch[N][<span class="number">26</span>],ans[N],fail[N],fa[N],w[N],ed[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;<span class="keyword">for</span> (;x&lt;=dfsnum;x+=(x&amp;(-x)))c[x]+=d;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="type">int</span> res=<span class="number">0</span>;<span class="keyword">for</span> (;x;x&amp;=x<span class="number">-1</span>)res+=c[x];<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)<span class="keyword">if</span> (ch[<span class="number">0</span>][i])q.<span class="built_in">push</span>(ch[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> now=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">            <span class="keyword">if</span> (ch[now][i])</span><br><span class="line">                fail[ch[now][i]]=ch[fail[now]][i],q.<span class="built_in">push</span>(ch[now][i]);</span><br><span class="line">            <span class="keyword">else</span> ch[now][i]=ch[fail[now]][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> now=ed[y];now;now=fa[now])</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t=now;t;t=fail[t])&#123;</span><br><span class="line">            ++cnt[w[t]];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=++dfsnum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)<span class="built_in">Dfs</span>(e[i].to);</span><br><span class="line">    low[u]=dfsnum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++ttt].to=v;</span><br><span class="line">    e[ttt].next=head[u];</span><br><span class="line">    head[u]=ttt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(dfn[u],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (w[u])</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=ql[w[u]];i&lt;=qr[w[u]];++i)</span><br><span class="line">            ans[q[i].num]=<span class="built_in">sum</span>(low[ed[q[i].x]])-<span class="built_in">sum</span>(dfn[ed[q[i].x]]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        <span class="keyword">if</span> (cc[u][i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(cc[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">add</span>(dfn[u],<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            now=fa[now];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">            ed[++K]=now;w[now]=K;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ch[now][v])ch[now][v]=++tot,fa[tot]=now;</span><br><span class="line">            now=ch[now][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;++j)</span><br><span class="line">            cc[i][j]=ch[i][j];</span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;++i)<span class="built_in">Add</span>(fail[i],i);<span class="built_in">Dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)q[i].x=<span class="built_in">read</span>(),q[i].y=<span class="built_in">read</span>(),q[i].num=i;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=n;i=j)&#123;</span><br><span class="line">        ql[q[i].y]=i;</span><br><span class="line">        <span class="keyword">while</span> (q[i].y==q[j].y)++j;</span><br><span class="line">        qr[q[i].y]=j<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>$AC$自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2153 【[SDOI2009]晨跑】</title>
    <url>/2019/05/30/%E9%A2%98%E8%A7%A3%20P2153%20%E3%80%90%5BSDOI2009%5D%E6%99%A8%E8%B7%91%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>$Elaxia$最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等 等，不过到目前为止，他坚持下来的只有晨跑。 现在给出一张学校附近的地图，这张地图中包含$N$个十字路口和$M$条街道，$Elaxia$只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia每天从寝室出发 跑到学校，保证寝室编号为$1$，学校编号为$N$.$Elaxia$的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以 在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路 口。$Elaxia$耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天 数尽量长。 除了练空手道，$Elaxia$其他时间都花在了学习和找$MM$上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。</p>
<p>存在$1\rightarrow n$的边存在。这种情况下，这条边只能走一次。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>边$(a,b)$表示容量为$a$,费用为$b$</p>
<p>由于在一个周期内，除了$1$和$n$,一个点只能走一次,于是考虑拆点，将每个点$i$拆成$i_1<del>$和$i_2</del>$,对于$1_1$和$1_2$,$n_1$和$n_2$之间连$(inf,0)$,其余连$(1,0)$.并从$s$到$1_1$连$(inf,0)$,$n_2$到$~t$连$(inf,0)$</p>
<p>对于每条读入的边(从$u$到$v$，边权为$d$)，从$u_2$到$v_1$连$(1,d)$</p>
<p>最后跑费用流即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,w,to,next;</span><br><span class="line">&#125;e[<span class="number">1000067</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,cur[N],head[N],dis[N],vis[N],inque[N],cost,n,m,s,t,a[N],b[N],c[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].w=-w;</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                cost+=mi*e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (mn==used)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        vis[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (vis[t])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">            res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),s=<span class="number">0</span>,t=n+n+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(s,<span class="number">1</span>,inf,<span class="number">0</span>);<span class="built_in">add</span>(n+n,t,inf,<span class="number">0</span>);<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>+n,inf,<span class="number">0</span>);<span class="built_in">add</span>(n,n+n,inf,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;++i)<span class="built_in">add</span>(i,i+n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),d=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u+n,v,<span class="number">1</span>,d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">Dinic</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2444 【[POI2000]病毒】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P2444%20%E3%80%90%5BPOI2000%5D%E7%97%85%E6%AF%92%E3%80%91/</url>
    <content><![CDATA[<p>题意:给定$n$个$01$串，保证$01$串长度之和不超过$30000$，询问是否存在无限长的$01$串，使得给定串都不是它的子串。</p>
<span id="more"></span>

<p>很考验对$fail$指针的理解,假设我们构造出了一个无限长的安全代码，再到$AC$自动机上匹配，从原点出发，向下走遇到一个环，然后不停地在这个环上跳转(无法理解就手玩样例)，且这个环上没有危险节点(即病毒单词最后一个字母在$Trie$树上的位置)</p>
<p>注意：<strong>这个环不包括$fail$指针</strong>,但是包括优化边(即如果节点$i$的某个字符儿子为空，那么这个儿子存为$i$的$fail$指针指向的节点的相同字符儿子)(有点绕,放张样例构成的$trie$图)</p>
<p><img src="https://i.loli.net/2019/04/06/5ca86414ee224.png"></p>
<p>黑边是$trie$树上的正常边，蓝边是在处理$AC$自动机时连上的优化边，红边是$fail$指针。灰色节点即危险节点</p>
<p>这里的环只由蓝边和黑边构成的，即不考虑走$fail$指针，</p>
<p>这样，问题就变成了找一个从根节点出发能在不经过危险节点的情况下走到到的环，且环上没有危险节点。</p>
<p>注意：如果某个点的$fail$指针指向的点是有危险节点，那么该节点也是危险节点</p>
<p>接下来$dfs$找环，找到就输出属于基础图论。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> fail,cnt,ch[<span class="number">2</span>];</span><br><span class="line">&#125;f[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans,cnt,ok[N],vis[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="type">int</span> v=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!f[now].ch[v])f[now].ch[v]=++cnt;</span><br><span class="line">        now=f[now].ch[v];</span><br><span class="line">    &#125;</span><br><span class="line">    f[now].cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build_fail</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)<span class="keyword">if</span> (f[<span class="number">0</span>].ch[i])q.<span class="built_in">push</span>(f[<span class="number">0</span>].ch[i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">            <span class="keyword">if</span> (f[u].ch[i])&#123;</span><br><span class="line">                f[f[u].ch[i]].fail=f[f[u].fail].ch[i];</span><br><span class="line">                f[f[u].ch[i]].cnt|=f[f[f[u].fail].ch[i]].cnt;</span><br><span class="line">                q.<span class="built_in">push</span>(f[u].ch[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> f[u].ch[i]=f[f[u].fail].ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ok[now])&#123;<span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span> (vis[now]||f[now].cnt)<span class="keyword">return</span>;</span><br><span class="line">    vis[now]=ok[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[now].ch[<span class="number">0</span>])<span class="built_in">dfs</span>(f[now].ch[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (f[now].ch[<span class="number">1</span>])<span class="built_in">dfs</span>(f[now].ch[<span class="number">1</span>]);</span><br><span class="line">    ok[now]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        <span class="built_in">build</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_fail</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>$AC$自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2602 [ZJOI2010]数字计数</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P2602%20%5BZJOI2010%5D%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p>题意：给定两个正整数$a$和$b$，求在$[a,b]$中的所有整数中，每个数字各出现了多少次。</p>
<span id="more"></span>

<p>定义状态$f[i][j][k]$表示以$j$开头的$i$位数$k$出现的次数</p>
<p>状态转移方程</p>
<p>$f[i][j][k]&#x3D;\sum\limits_{p&#x3D;0}^{9}f[i-1][p][k]+(10^{i-1}* [j&#x3D;&#x3D;k])$</p>
<p>(解释：$i$位数除去最高位就是$i-1$位数，所以要加上所以$i-1$位数的出现次数$(\sum\limits_{p&#x3D;0}^{9}f[i-1][p][k])$，再加上最高位出现的次数$(10^{i-1}* [j&#x3D;&#x3D;k])$</p>
<p>求$A$到$B$之间出现的次数即使就$(1$<del>$B)-(1$</del>$(A-1))$的次数</p>
<p>$dp$完了后要开始统计了，首先特判$0$的情况，然后计算出这个数的位数$pos$，所以位数比这个数小的都可以统计答案。由于不能有前导$0$，所以最高位要从$1$枚举到$9$，再枚举所有$i$位数，从最高位枚举到最低位，只要小于当前位的都可以统计(注意等于不可以统计)，再统计一下当前位的贡献，最后还要减去前导$0$的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">30</span>][<span class="number">40</span>][<span class="number">40</span>],ans[<span class="number">300</span>],poow[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)&#123;</span><br><span class="line">        ans[<span class="number">0</span>]+=d;<span class="keyword">return</span>;<span class="comment">//0单独特判 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> o=x,poos=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(o)&#123;++poos;o/=<span class="number">10</span>;&#125;<span class="comment">//算出这个数的位数 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;poos;++i)<span class="comment">//位数比这个数小的都可以统计答案 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;++j)<span class="comment">//从1开始循环是因为开头不能为0 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">9</span>;++k)</span><br><span class="line">                ans[k]+=f[i][j][k]*d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=poos;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="type">int</span> now=x/poow[i<span class="number">-1</span>];x%=poow[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;now;++j)&#123;<span class="comment">//比当前位小的都要统计答案 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">9</span>;++k)</span><br><span class="line">                ans[k]+=f[i][j][k]*d;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[now]+=(x+<span class="number">1</span>)*d;<span class="comment">//当前位也要统计答案(x+1)是因为有后面都是0的情况)</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)ans[i]-=f[poos][<span class="number">0</span>][i]*d;<span class="comment">//减去前导0 </span></span><br><span class="line">    ans[<span class="number">0</span>]+=d;</span><br><span class="line"><span class="comment">//0要特殊处理，因为减去前导0时把0一起统计了</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">13</span>;</span><br><span class="line">    poow[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)poow[i]=poow[i<span class="number">-1</span>]*<span class="number">10</span>;<span class="comment">//预处理10的幂次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;++j)f[<span class="number">1</span>][j][j]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">9</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">9</span>;++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> p=<span class="number">0</span>;p&lt;=<span class="number">9</span>;++p)</span><br><span class="line">                    f[i][j][k]+=f[i<span class="number">-1</span>][p][k];</span><br><span class="line">            f[i][j][j]+=poow[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">make</span>(b,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">make</span>(a<span class="number">-1</span>,<span class="number">-1</span>);<span class="comment">//类似前缀和 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数位$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2429 【制杖题】</title>
    <url>/2019/06/30/%E9%A2%98%E8%A7%A3%20P2429%20%E3%80%90%E5%88%B6%E6%9D%96%E9%A2%98%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>求不大于$m$的、 质因数集与给定质数集有交集的自然数之和。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>考虑容斥。统计所有$a_i$的倍数，然后减去两两之间的乘积，再加上三个之间的乘积$\cdots,$这个过程可以用状压实现。</p>
<p>对于当前状态$s,$根据$s$中$1$的个数确定状态$s$对答案的贡献是加还是减。然后计算一个$res$表示$s$中所有$1$位置上$a_i$的乘积。将答案$+&#x2F;-$上$\sum\limits_{i&#x3D;1}^{m&#x2F;res}i\times res,z$这个式子可以化简为$$\frac{(m&#x2F;res)\times(m\times res+1)}{2}\times res$$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200057</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 376544743</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inv2 188272372</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> w[N],ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span> (n*m&lt;=<span class="number">1e7</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">if</span> (i%w[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)ans=(ans+i)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s=<span class="number">1</span>;s&lt;(<span class="number">1</span>&lt;&lt;n);++s)&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (s&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))</span><br><span class="line">                res*=w[j],++cnt;</span><br><span class="line">        <span class="type">int</span> t=m/res;</span><br><span class="line">        <span class="keyword">if</span> (cnt&amp;<span class="number">1</span>)ans=(ans+res*t%mod*(t+<span class="number">1</span>)%mod*inv2%mod)%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans-res*t%mod*(t+<span class="number">1</span>)%mod*inv2%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>容斥</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2451 [SDOI2005]遗传代码</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P2451%20%5BSDOI2005%5D%E9%81%97%E4%BC%A0%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>题意:给定$n$ 个数对$(l,r)$，求一个最短的序列$a$，使得对于所有给定的$(l,r)$ 都存在$i$使得$a_i&#x3D;l$且 $a_{i+1}&#x3D;r$。输出这个序列的长度。</p>
<span id="more"></span>

<p>想法题，如果一个$l$等于一个$r$，那么他们可以抵消成一个，但是洛谷数据好像有锅，当前位置上的$r&gt;l$时，$ans$加上$r-l$，或者当前位置上的$l&lt;r$时，$ans$加上$l-r$，都是对的。(但洛谷上只有$r-l$是对的)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wln</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans,l[<span class="number">300000</span>],r[<span class="number">300000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ++l[<span class="built_in">read</span>()];</span><br><span class="line">        ++r[<span class="built_in">read</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;++i)</span><br><span class="line">        <span class="keyword">if</span> (r[i]&gt;l[i])</span><br><span class="line">            ans+=<span class="built_in">abs</span>(r[i]-l[i]);</span><br><span class="line">    cout&lt;&lt;ans+n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2604 【[ZJOI2010]网络扩容】</title>
    <url>/2019/06/01/%E9%A2%98%E8%A7%A3%20P2604%20%E3%80%90%5BZJOI2010%5D%E7%BD%91%E7%BB%9C%E6%89%A9%E5%AE%B9%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给你一张有向图。每条边有一个容量$c$和一个扩容费用$w$。每将这条边的容量扩大$1$就需要$w$的费用。</p>
<p>求$1 \sim n$的最大流和将最大流扩大$k$的最小费用。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>对于第一问，直接求最大流即可</p>
<p>考虑对于残量网络中的每条边$e$，在图上连一条流量为$\infty$，费用为$w_e$的边。</p>
<p>然后从$s$连一条边到$1$，容量为$k$，以保证扩容流量正好是$k$。</p>
<p>只要再求一遍$s$到$n$的最小费用最大流就好了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 30000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,w,to,next;</span><br><span class="line">&#125;e[<span class="number">1000067</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> u[N],v[N],d[N],cnt=<span class="number">1</span>,cur[N],head[N],dis[N],dep[N],vis[N],inque[N],cost,n,m,k,s,t,w[N],c[<span class="number">400</span>][<span class="number">400</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].w=-w;</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                cost+=mi*e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (mn==used)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        vis[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (vis[t])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(cur));</span><br><span class="line">            res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();s=<span class="number">1</span>;t=n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        u[i]=<span class="built_in">read</span>(),v[i]=<span class="built_in">read</span>(),d[i]=<span class="built_in">read</span>(),w[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u[i],v[i],d[i],<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">Dinic</span>());</span><br><span class="line">    s=<span class="number">0</span>;<span class="built_in">add</span>(s,<span class="number">1</span>,k,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="built_in">add</span>(u[i],v[i],k,w[i]);<span class="built_in">Dinic</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2754 【[CTSC1999]家园】</title>
    <url>/2019/06/02/%E9%A2%98%E8%A7%A3%20P2754%20%E3%80%90%5BCTSC1999%5D%E5%AE%B6%E5%9B%AD%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>现有$n$个太空站位于地球与月球之间，且有$m$艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而每艘太空船$i$只可容纳$h_i~$个人。每艘太空船将周期性地停靠一系列的太空站，例如$:(1,3,4)$表示该太空船将周期性地停靠太空站$134,134,134\cdots$。每一艘太空船从一个太空站驶往任一太空站耗时均为$1$。人们只能在太空船停靠太空站(或月球、地球)时上、下船。</p>
<p>初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。</p>
<p>对于给定的太空船的信息，找到让所有人尽快地全部转移到月球上的运输方案。</p>
<span id="more"></span>


<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>用并查集判断是否有解法。将一艘飞船可以到达的所有星球并查集连起来，最后如果地球和月球无法连接，则无解。</p>
<p>然后枚举答案。</p>
<p>考虑按时间分层拆点。令$t$时刻的$i$号站为$c_{t,i}$。</p>
<p>那么枚举的答案每增加1，就需要新建一层地球和太空站的点。</p>
<p>源点$s$向每一层的地球连一条容量为$inf$的边，每个空间站向下一时间的该空间站连一条容量为$inf$的边，代表时间的转移。</p>
<p>每个飞船现在在哪个星球，下一秒会飞到哪一个星球都可以计算得到，所以直接连边，容量为飞船载人量。</p>
<p>月球就是汇点，且每层图中没有月球。</p>
<p>然后跑最大流，如果最大流$\geqslant$需要转移的人数了，那么当前$ans$就是答案。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1070000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,dis,w,next;</span><br><span class="line">&#125;e[<span class="number">1007000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res,cr,f[N],h[N],r[N],d[<span class="number">3000</span>][<span class="number">3000</span>],flow[N],pri[N],pre[N],p,w[N],cnt=<span class="number">1</span>,head[N],dep[N],inque[N],vis[N],cur[N],cost,n,m,k,s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;!dep[v])&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (dep[v]==dep[u]+<span class="number">1</span>&amp;&amp;e[i].dis)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                <span class="keyword">if</span> (used==mn)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">        res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> f[k]==k?k:f[k]=<span class="built_in">find</span>(f[k]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="number">-1</span>)*(n+<span class="number">1</span>)+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),k=<span class="built_in">read</span>(),s=<span class="number">0</span>,t=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;++i)f[i]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        h[i]=<span class="built_in">read</span>(),r[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=r[i];++j)&#123;</span><br><span class="line">            d[i][j]=<span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (d[i][j]==<span class="number">0</span>)d[i][j]=n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (d[i][j]==<span class="number">-1</span>)d[i][j]=n+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (j!=<span class="number">1</span>)f[<span class="built_in">find</span>(d[i][j])]=<span class="built_in">find</span>(d[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(n+<span class="number">1</span>)!=<span class="built_in">find</span>(n+<span class="number">2</span>))&#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ans=<span class="number">1</span>;;++ans)&#123;</span><br><span class="line">        <span class="built_in">add</span>(s,<span class="built_in">id</span>(ans,n+<span class="number">1</span>),inf); </span><br><span class="line">        <span class="keyword">if</span> (ans!=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">id</span>(ans<span class="number">-1</span>,i),<span class="built_in">id</span>(ans,i),inf);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            <span class="type">int</span> a=d[i][(ans<span class="number">-1</span>)%r[i]+<span class="number">1</span>],b=d[i][ans%r[i]+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (a==n+<span class="number">2</span>)a=t;<span class="keyword">else</span> a=<span class="built_in">id</span>(ans,a);</span><br><span class="line">            <span class="keyword">if</span> (b==n+<span class="number">2</span>)b=t;<span class="keyword">else</span> b=<span class="built_in">id</span>(ans+<span class="number">1</span>,b);</span><br><span class="line">            <span class="built_in">add</span>(a,b,h[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res+=<span class="built_in">Dinic</span>();</span><br><span class="line">        <span class="keyword">if</span> (res&gt;=k)&#123;cout&lt;&lt;ans&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流$24$题</tag>
        <tag>分层图网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2757 【[国家集训队]等差子序列】&amp;&amp; CF452F Permutation</title>
    <url>/2019/06/20/%E9%A2%98%E8%A7%A3%20P2757%20%E3%80%90%5B%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%5D%E7%AD%89%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%91&amp;&amp;%20CF452F%20Permutation/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给你一个$1$到$n$的排列，你需要判断该排列内部是否存在一个$3$个元素的子序列(可以不连续)，使得这个子序列是等差序列。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><h3 id="思路一-bitset-优化暴力"><a href="#思路一-bitset-优化暴力" class="headerlink" title="思路一$:bitset$优化暴力"></a>思路一$:bitset$优化暴力</h3><p>枚举中间的数$,$判断一下这个数的对称的两侧$,$如果一侧的数出现了但是另一侧的没出现。那么一定存在一个可行方案</p>
<h3 id="思路二-线段树维护-hash-值"><a href="#思路二-线段树维护-hash-值" class="headerlink" title="思路二$:$线段树维护$hash$值"></a>思路二$:$线段树维护$hash$值</h3><p>从左到右，设当前数$w_j$为中间那一个,那么有以下两种情况</p>
<p><img src="https://i.loli.net/2019/06/20/5d0ba02b1cbd528428.png"></p>
<p>显然对于$l\sim j$与$r\sim j$如果有一位不相等（也就是它们的值不相等）那么就成立，因为一个在前面出现过了，另一个在后面还没出现过。</p>
<p>如上图中我们假设$c_a,c_b$不相等$($设$c_a&#x3D;1,c_b&#x3D;0)$,那么$a$在$w_j$之前就出现过$($即原序列中在$w_j$前$),$而$b$在$w_j$之后出现$($即原序列中在$w_j$后$)$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><p>$bitset$优化暴力</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 560000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    bitset&lt;10060&gt;b,c;b.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)c.<span class="built_in">set</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        b.<span class="built_in">set</span>(a[i]);c.<span class="built_in">reset</span>(n-a[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (((b&gt;&gt;(a[i]+<span class="number">1</span>))&amp;(c&gt;&gt;(n-a[i]+<span class="number">1</span>+<span class="number">1</span>))).<span class="built_in">any</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        n=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>())&#123;<span class="built_in">puts</span>(<span class="string">&quot;Y&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>())<span class="built_in">puts</span>(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;N&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线段树维护$hash$值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> base 131</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(k) (k&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(k) (k&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pushup(k) a[k]=a[ls(k)]+a[rs(k)],b[k]=b[rs(k)]+b[ls(k)]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> po[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val,len;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;val=<span class="number">0</span>,len=<span class="number">0</span>;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span> +(node a,node b)&#123;</span><br><span class="line">        <span class="keyword">return</span> (node)&#123;(a.val*po[b.len]%mod+b.val)%mod,a.len+b.len&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">        a[k]=b[k]=(node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">ls</span>(k),l,mid);</span><br><span class="line">    <span class="built_in">build</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">        a[k]=b[k]=(node)&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid)<span class="built_in">change</span>(<span class="built_in">ls</span>(k),l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r,x);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query1</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=l&amp;&amp;r&lt;=y)</span><br><span class="line">        <span class="keyword">return</span> a[k];</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;node res;res.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid)res=res+<span class="built_in">query1</span>(<span class="built_in">ls</span>(k),l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span> (mid&lt;y) res=res+<span class="built_in">query1</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query2</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=l&amp;&amp;r&lt;=y)</span><br><span class="line">        <span class="keyword">return</span> b[k];</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;node res;res.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span> (mid&lt;y) res=res+<span class="built_in">query2</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid)res=res+<span class="built_in">query2</span>(<span class="built_in">ls</span>(k),l,mid,x,y);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    po[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)po[i]=po[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (flag)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,x);</span><br><span class="line">        <span class="type">int</span> len=<span class="built_in">min</span>(x<span class="number">-1</span>,n-x);</span><br><span class="line">        <span class="keyword">if</span> (len&lt;=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">query1</span>(<span class="number">1</span>,<span class="number">1</span>,n,x-len,x<span class="number">-1</span>).val!=<span class="built_in">query2</span>(<span class="number">1</span>,<span class="number">1</span>,n,x+<span class="number">1</span>,x+len).val)&#123;flag=<span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(flag?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>$bitset$</tag>
        <tag>$hash$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2749 【[USACO5.1]夜空繁星Starry Night】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P2749%20%E3%80%90%5BUSACO5.1%5D%E5%A4%9C%E7%A9%BA%E7%B9%81%E6%98%9FStarry%20Night%E3%80%91/</url>
    <content><![CDATA[<p>题意:夜空可以表示为一份天体图，它是一个由字符$0$和$1$组成的二维矩阵，字符$1$表示所在的位置有一颗星；字符$0$表示该位置上是空的.给定一份天体图，用同一个小写英文标识相似的所有星座。相似的星座必须用相同的字母标识，不同的星座表示为不同的字母。标识一个星座，就是将其中各星体对应的字符1替换为相应的小写字母.</p>
<span id="more"></span>

<p>难点在于判断图像是否相似，我们采用将每个点之间互相连起来，计算每个点与点之间的距离之和（也可用$hash$、直接写对称旋转函数或八个循环判断），共$\frac{n*(n-1)}{2}$条线段，这种做法的正确性不难证明，当和相同时，每条边长度相等（正确性下面再证），可以将图像看成一个多边形，连接点可以看成将多边形分成许多三角形，根据三角形全等判定条件（$sss$），可以判定每个三角形全等，根据三角形全等推出对应边相等、对应角相等，可证多边形全等<br>当和相等，每条边也相等的证明：三角形将每个格点的边长设为$1$，故每条线段的长度都为整数或一个整数的开方，整数的小数部分为$0$，整数的开根小数部分取值十分有限，使用$long double$可以将出错率大大降低。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> k,tail,tx[<span class="number">200000</span>],ty[<span class="number">200000</span>],n,m,a[<span class="number">300000</span>],b[<span class="number">300000</span>],dx[]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,dy[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">char</span> s[<span class="number">3000</span>][<span class="number">3000</span>],p=<span class="string">&#x27;a&#x27;</span>,u[<span class="number">3999</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> t[<span class="number">39</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">char</span> q,<span class="type">char</span> p)</span></span>&#123;<span class="comment">//深搜求联通块（广搜也可）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;<span class="comment">//根据题意是八个方向</span></span><br><span class="line">        <span class="type">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span> (xx&lt;<span class="number">1</span>||xx&gt;n||yy&lt;<span class="number">0</span>||yy&gt;=m||s[xx][yy]!=p) <span class="keyword">continue</span>;</span><br><span class="line">        tx[++tail]=xx;ty[tail]=yy;</span><br><span class="line">        s[xx][yy]=q;</span><br><span class="line">        <span class="built_in">dfs</span>(xx,yy,q,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tail;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail;j++)</span><br><span class="line">            res+=<span class="built_in">sqrt</span>((tx[i]-tx[j])*(tx[i]-tx[j])+(ty[i]-ty[j])*(ty[i]-ty[j]));<span class="comment">//计算每个点与点之间的直线距离和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(res-t[i])&lt;<span class="number">0.00001</span>)&#123;<span class="comment">//浮点数的判定相等的方法</span></span><br><span class="line">            p--;<span class="type">char</span> o=s[x][y];</span><br><span class="line">            s[x][y]=u[i];</span><br><span class="line">            <span class="built_in">dfs</span>(x,y,u[i],o);<span class="comment">//若与前面重复则重新赋值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    t[++k]=res;u[k]=p;<span class="comment">//不重复则加入数组（也可用map）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen(&quot;star.in&quot;, &quot;r&quot;, stdin), freopen(&quot;star.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="keyword">if</span> (s[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                s[i][j]=p;</span><br><span class="line">                tx[<span class="number">1</span>]=i;ty[<span class="number">1</span>]=j;</span><br><span class="line">                tail=<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i,j,p,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                <span class="built_in">check</span>(i,j);</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) </span><br><span class="line">            cout&lt;&lt;s[i][j];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>奇技淫巧</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2765 魔术球问题</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P2765%20%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2765">链接</a></p>
<span id="more"></span>

<p>我们考虑建图，把每个点拆开，若两个数和为平方数，那么就从编号小的向编号大的连权值为$1$的有向边。那么就把这个问题转换成了最大匹配问题。</p>
<p>然后我们考虑对于一个新的球，如果能找到原来在的一个球能够匹配，那么可以直接匹配，否则就需要新开一根柱子。所以我们从小到大枚举放的球数，每次加入一个球，直到柱子个数超过给定的上限，那么上一次就是能放的最多球数。</p>
<p>对于方案，我们为了方便，在新增一根柱子的时候记录这个需要新柱子的球的编号，其余路径就按网络流跑二分图匹配的路径记录搞一搞即可。</p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mx=<span class="number">3939</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,dis;</span><br><span class="line">&#125;e[<span class="number">393939</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num,ans[<span class="number">10000</span>],ttt,res,n,m,s,t,cnt=<span class="number">1</span>,nex[<span class="number">10000</span>],vis[<span class="number">10000</span>],head[<span class="number">10000</span>],cur[<span class="number">10000</span>],dep[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;!dep[v])&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//                if (v==t)return 1;</span></span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (e[i].dis&amp;&amp;dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;<span class="keyword">if</span> (v!=t)nex[(u<span class="number">-1</span>)%mx+<span class="number">1</span>]=(v<span class="number">-1</span>)%mx+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (mn==used)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">        res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),s=<span class="number">0</span>,t=mx&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ttt&lt;=n)&#123;++num;</span><br><span class="line">        <span class="built_in">add</span>(s,num,<span class="number">1</span>);<span class="built_in">add</span>(num+mx,t,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="built_in">sqrt</span>(num)+<span class="number">1</span>;i*i-num&lt;num;++i)</span><br><span class="line">            <span class="built_in">add</span>(i*i-num,num+mx,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">Dinic</span>();</span><br><span class="line">        <span class="keyword">if</span> (!k)ans[++ttt]=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;num;++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])&#123;</span><br><span class="line">            <span class="type">int</span> now=i;</span><br><span class="line">            <span class="keyword">while</span> (now)&#123;</span><br><span class="line">                vis[now]=<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,now);</span><br><span class="line">                now=nex[now];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>网络流$24$题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2770 【航空路线问题】</title>
    <url>/2019/05/31/%E9%A2%98%E8%A7%A3%20P2770%20%E3%80%90%E8%88%AA%E7%A9%BA%E8%B7%AF%E7%BA%BF%E9%97%AE%E9%A2%98%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>求两条途径点数尽可能多的从$1$到$n$的不相交路线（$1,n$除外）</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>对于每个点$a<del>$拆成$a_1</del>$和$a_2$两个点，两个点之间的容量为$1$，边权为$1$，（因为每个点只能选一次，每选一个点可以对答案造成$1$的贡献） （若$a$为$1$或$n$容量应为$2$，因为这两个点可以选$2$次）</p>
<p>对于每条从$u$到$v$的边，从$u_2$向$v_1$建一条容量为$1$，边权为$0$的边（因为每条边只能选一次，选边并不会对答案造成影响）</p>
<p>最后从源点$s$向$a_1$建一条容量为$2$，边权为$0$,的边</p>
<p>从$n_2$向汇点建一条容量为$2$，边权为$0$的边</p>
<p>跑最大费用最大流即可</p>
<p>对于输出城市,进行两遍$dfs$，</p>
<p>第一次$dfs$找到一条$1$到$n$所有边的$flow$都为$0$的路径正序输出，</p>
<p>第二次$dfs$找到另一条$1$到$n$所有边的$flow$都为$0$的路径倒序输出（这次$n$不输出）</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 30000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,w,to,next;</span><br><span class="line">&#125;e[<span class="number">1000067</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,cur[N],head[N],dis[N],dep[N],vis[N],inque[N],cost,n,m,s,t,w[N],c[<span class="number">400</span>][<span class="number">400</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].w=-w;</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)dis[i]=-inf;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&lt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]&gt;-inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                cost+=mi*e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (mn==used)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        vis[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (vis[t])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">            res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">string ss[<span class="number">107</span>],s1,s2;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;ma;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;ss[u-n]&lt;&lt;endl;vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v&lt;=n&amp;&amp;!e[i].dis&amp;&amp;!vis[v+n])&#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(v+n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v&lt;=n&amp;&amp;!e[i].dis&amp;&amp;!vis[v+n])&#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(v+n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ss[u-n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),s=<span class="number">0</span>,t=n+n+<span class="number">1</span>;<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;ss[i],ma[ss[i]]=i,<span class="built_in">add</span>(i,i+n,<span class="number">1</span>+(i==<span class="number">1</span>||i==n),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">        <span class="type">int</span> a=ma[s1],b=ma[s2];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)<span class="built_in">swap</span>(a,b); </span><br><span class="line">        <span class="keyword">if</span> (a==<span class="number">1</span>&amp;&amp;b==n)flag=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(a+n,b,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(s,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>);<span class="built_in">add</span>(n+n,t,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">Dinic</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ans||(ans==<span class="number">1</span>&amp;&amp;!flag))&#123;<span class="built_in">puts</span>(<span class="string">&quot;No Solution!&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (ans==<span class="number">1</span>&amp;&amp;flag)&#123;<span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);cout&lt;&lt;ss[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>&lt;&lt;ss[n]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>&lt;&lt;ss[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost<span class="number">-2</span>);<span class="comment">//1,n被重复算了两次</span></span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>+n);<span class="built_in">dfs2</span>(<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>网络流$24$题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2761 【软件补丁问题】</title>
    <url>/2019/07/30/%E9%A2%98%E8%A7%A3%20P2761%20%E3%80%90%E8%BD%AF%E4%BB%B6%E8%A1%A5%E4%B8%81%E9%97%AE%E9%A2%98%E3%80%91/</url>
    <content><![CDATA[<h2 id="Dscription"><a href="#Dscription" class="headerlink" title="$Dscription$"></a>$Dscription$</h2><p>$T$公司发现其研制的一个软件中有$n$个错误，随即为该软件发放了一批共 $m$个补丁程序。每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。</p>
<p>换句话说，对于每一个补丁$i$，都有 2 个与之相应的错误集合$B1_i$和 $B2_i,$使得仅当软件包含$B1_i$中的所有错误，而不包含$B2_i$中的任何错误时，才可以使用补丁$i$。补丁$i$将修复软件中的某些错误$F1_i,$而同时加入另一些错误$F2_i.$另外，每个补丁都耗费一定的时间。</p>
<p>试设计一个算法，利用$T$公司提供的$m$个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的$n$个错误和$m$个补丁程序，找到总耗时最少的软件修复方案。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>一个很显然的状压$DP,f_s$表示当从初始状态到病毒状态为$s$时的最小耗时.转移考虑利用最短路</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4000050</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,to,next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> w[N],cnt,head[N],dis[N],inque[N],n,m,b1[N],b2[N],f1[N],f2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((u&amp;b1[i])==b1[i]&amp;&amp;(u&amp;b2[i])==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> v=u&amp;(((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)^f1[i])|f2[i];</span><br><span class="line">                <span class="keyword">if</span> (dis[v]&gt;dis[u]+w[i])&#123;</span><br><span class="line">                    dis[v]=dis[u]+w[i];</span><br><span class="line">                    <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                        q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        w[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                b1[i]|=(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s[j]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                b2[i]|=(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                f1[i]|=(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s[j]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                f2[i]|=(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[<span class="number">0</span>]&gt;=inf?<span class="number">0</span>:dis[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>网络流$24$题</tag>
        <tag>状压$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2864 【[USACO06JAN]树林The Grove】</title>
    <url>/2019/05/24/%E9%A2%98%E8%A7%A3%20P2864%20%E3%80%90%5BUSACO06JAN%5D%E6%A0%91%E6%9E%97The%20Grove%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给定一张$R\times C$的地图，并给出一个联通块和一个起点，要求从起点出发，绕联通块一圈的最短路。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution:$"></a>$Solution:$</h2><p>设起点为$S$,从这个树林的第一行最左边的那个点向左连出一条射线，然后从$S$开始$bfs$，求穿越射线奇数次最后终点在$S$的最短路径即可。</p>
<p>以样例为例，</p>
<p><img src="https://s2.ax1x.com/2019/05/24/VFJYWt.png"></p>
<p><img src="https://s2.ax1x.com/2019/05/24/VFJZJ1.png"></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;node&gt;q;</span><br><span class="line"><span class="type">char</span> s[<span class="number">60</span>];</span><br><span class="line"><span class="type">int</span> n,m,ma[<span class="number">60</span>][<span class="number">60</span>],dis[<span class="number">60</span>][<span class="number">60</span>][<span class="number">2</span>],xx,yy,sx,sy,dx[]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,dy[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//dis[x][y][v]表示当前bfs的坐标为(x,y),穿越射线次数的奇偶性为v</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">across</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x==xx&amp;&amp;a.y&lt;yy&amp;&amp;xx&gt;b.x)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b.x==xx&amp;&amp;b.y&lt;yy&amp;&amp;xx&gt;a.x)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断是否穿越射线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>((node)&#123;sx,sy,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));dis[sx][sy][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node u=q.<span class="built_in">front</span>();<span class="type">int</span> x=u.x,y=u.y,p=u.p;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line">            node v=(node)&#123;xx,yy,p&#125;;</span><br><span class="line">            <span class="keyword">if</span> (ma[xx][yy]==<span class="number">-1</span>||xx&lt;<span class="number">1</span>||yy&lt;<span class="number">1</span>||xx&gt;n||yy&gt;m)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">across</span>(u,v))v.p^=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dis[xx][yy][v.p]!=inf)<span class="keyword">continue</span>;</span><br><span class="line">            dis[xx][yy][v.p]=dis[x][y][p]+<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//bfs</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">            <span class="keyword">if</span> (s[j]==<span class="string">&#x27;.&#x27;</span>)ma[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[j]==<span class="string">&#x27;*&#x27;</span>)ma[sx=i][sy=j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="keyword">if</span> (!xx)xx=i,yy=j;ma[i][j]=<span class="number">-1</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dis[sx][sy][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>奇技淫巧</tag>
        <tag>射线法</tag>
        <tag>$bfs$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2921 【[USACO08DEC]在农场万圣节Trick or Treat on the Farm】</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20P2921%20%E3%80%90%5BUSACO08DEC%5D%E5%9C%A8%E5%86%9C%E5%9C%BA%E4%B8%87%E5%9C%A3%E8%8A%82Trick%20or%20Treat%20on%20the%20Farm%E3%80%91/</url>
    <content><![CDATA[<p>题意:从图中第$i$号节点开始遍历,每个节点存有下一步要去的节点,当遍历的路径出现环时结束遍历并输出路径长度(边权默认为$1$)</p>
<span id="more"></span>

<p>这道题很像<a href="https://www.luogu.org/problemnew/show/P2661">P2661</a>，那道题用带权并查集求有向图中的最小环，这道题要求的是每个点在有向图中的环的长度或进入环之前经过的点数与环的长度的和。由于并查集经过路径压缩后只能存储它祖先的信息，所以我们开一个$fa$数组记录它的父亲。判断环我们只需判断读入的$a_{i}$与$i$是否祖先节点相同，那么就可以判断是否能构成一个环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;<span class="comment">//快读</span></span><br><span class="line"><span class="type">int</span> ans[<span class="number">300000</span>],f[<span class="number">300000</span>],fa[<span class="number">3000000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k)<span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;<span class="comment">//并查集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200000</span>;i++)f[i]=i,fa[i]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(x)==<span class="built_in">find</span>(i))&#123;<span class="comment">//如果构成环</span></span><br><span class="line">            <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=x;j!=i;j=fa[j]) res++;<span class="comment">//从x-&gt;x的父亲--&gt;……直到回到i，其中i~x这条边没算，所以res初值赋为1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=x;j!=i;j=fa[j]) ans[j]=res;<span class="comment">//给环中的每个节点的答案赋值</span></span><br><span class="line">            ans[i]=res;<span class="comment">//i这个点刚刚没赋值</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            f[<span class="built_in">find</span>(i)]=<span class="built_in">find</span>(x);</span><br><span class="line">            fa[i]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//由于i一定是第一次赋值，所以find(i)一定等于i，所以这个循环中的find(i)都可以写成i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">        <span class="keyword">if</span> (ans[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> res=<span class="number">1</span>,j;</span><br><span class="line">            <span class="keyword">for</span> (j=fa[i];ans[j]==<span class="number">0</span>;j=fa[j])</span><br><span class="line">                res++;</span><br><span class="line">            ans[i]=res+ans[j];</span><br><span class="line">        &#125;<span class="comment">//特别处理自身不在环中的点，计算进入环之前经过的点数与环的长度的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2766 【最长不下降子序列问题】</title>
    <url>/2019/05/30/%E9%A2%98%E8%A7%A3%20P2766%20%E3%80%90%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给定正整数序列$a_1,a_2,\cdots ,a_n$。</p>
<p>$1.$计算其最长不下降子序列的长度$s$。</p>
<p>$2.$计算从给定的序列中最多可取出多少个长度为$s$的不下降子序列。</p>
<p>$3.$如果允许在取出的序列中多次使用$x_1$和$x_n$，则从给定序列中最多可取出多少个长度为$s$的不下降子序列。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>首先动态规划求出$f_{i}$，表示以第$i$位为开头的最长不下降子序列的长度，求出最长不下降子序列长度$W$。</p>
<p>把序列每位$i$拆成两个点$i_1$和$i_2$，从$i_1<del>$到$i_2</del>$连接一条容量为$1$的边。</p>
<p>如果序列第$i$位有$f_{i}&#x3D;W$，从$s$到$i_{1}~$连接一条容量为$1$的有向边。</p>
<p>如果$f_i&#x3D;1$，从$i_2<del>$到$</del>t~$连接一条容量为1的有向边。</p>
<p>如果$j&gt;i$且$a_i&lt;a_j$且$f_j+1&#x3D;f_i$，从$i_2<del>$到$j_1</del>$连接一条容量为$1$的有向边。</p>
<p>第二问直接求最大流即可</p>
<p>对于第三问,要求$a_1$和$a_n$可以重复使用，只需取消这两个点相关边的流量限制即可，具体操作只需把$(1_1,1_2)(n_1,n_2)(s,1_1)(n_2,t)$四条边权值改成$inf$,再跑最大流即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,to,next;</span><br><span class="line">&#125;e[<span class="number">1000055</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res,w[N],f[N],ans,cnt=<span class="number">1</span>,head[N],dep[N],inque[N],cur[N],n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;!dep[v])&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (e[i].dis&amp;&amp;dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                <span class="keyword">if</span> (used==mn)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">        res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),s=<span class="number">0</span>,t=n+n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=<span class="built_in">read</span>(),f[i]=<span class="number">1</span>;ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=n<span class="number">-1</span>;i;--i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (w[j]&gt;=w[i])</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">if</span> (ans==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n%d\n&quot;</span>,n,n);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(i,i+n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (f[i]==ans)<span class="built_in">add</span>(s,i,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (f[i]==<span class="number">1</span>)<span class="built_in">add</span>(i+n,t,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (f[j]+<span class="number">1</span>==f[i]&amp;&amp;w[j]&gt;=w[i])</span><br><span class="line">                <span class="built_in">add</span>(i+n,j,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Dinic</span>());</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>+n,inf);<span class="built_in">add</span>(n,n+n,inf);</span><br><span class="line">    <span class="keyword">if</span> (f[<span class="number">1</span>]==ans)<span class="built_in">add</span>(s,<span class="number">1</span>,inf);</span><br><span class="line">    <span class="keyword">if</span> (f[<span class="number">1</span>]==<span class="number">1</span>)<span class="built_in">add</span>(n+<span class="number">1</span>,t,inf);</span><br><span class="line">    <span class="keyword">if</span> (f[n]==<span class="number">1</span>)<span class="built_in">add</span>(n+n,t,inf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Dinic</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>网络流$24$题</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3153 【[CQOI2009]跳舞】</title>
    <url>/2019/06/03/%E9%A2%98%E8%A7%A3%20P3153%20%E3%80%90%5BCQOI2009%5D%E8%B7%B3%E8%88%9E%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>一次舞会有$n$个男孩和$n$个女孩。每首曲子开始时，所有男孩和女孩恰好配成$n$对跳交谊舞。每个男孩都不会和同一个女孩跳两首（或更多）舞曲。有一些男孩女孩相互喜欢，而其他相互不喜欢（不会”单向喜欢“）。每个男孩最多只愿意和$k$个不喜欢的女孩跳舞，而每个女孩也最多只愿意和$k$个不喜欢的男孩跳舞。给出每对男孩女孩是否相互喜欢的信息，舞会最多能有几首舞曲？</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>二分答案$ans$</p>
<p>把每个人$i<del>$拆成喜欢对方$i_1</del>$和不喜欢对方$i_2~$两个点</p>
<p>从源点$s$向$i_1~$连容量为$ans$的边，表示限制$ans$支舞曲</p>
<p>再从$i_1<del>$连向$i_2</del>$连边，容量为$k$</p>
<p>这样的话就解决了这个问题</p>
<p>接下来就很好办了</p>
<p>若男生$i$和女生$j$互相喜欢</p>
<p>$i_1$连向$j_1$</p>
<p>若男生$i$和女生$j$互相不喜欢</p>
<p>$i_2$连向$j_2$</p>
<p>而女生之间的连边类似于男生</p>
<p>（你就想，如果这个图反过来是一样的，所以怎么连边就很清晰了）</p>
<p>这个时候跑最大流</p>
<p>求出来的就是最大的匹配数</p>
<p>如果最大流恰好等于$ans\times n$</p>
<p>也就是恰好$ans\times n$组匹配，意味着可行</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,to,next;</span><br><span class="line">&#125;e[<span class="number">1000700</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,ma[<span class="number">2007</span>][<span class="number">2007</span>],head[N],dep[N],inque[N],cur[N],n,k,p,s,t;</span><br><span class="line"><span class="type">char</span> ss[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;!dep[v])&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (e[i].dis&amp;&amp;dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                <span class="keyword">if</span> (used==mn)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">        res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(s,i,mid);<span class="built_in">add</span>(i+n+n,t,mid);<span class="built_in">add</span>(i,i+n,k);<span class="built_in">add</span>(i+n*<span class="number">3</span>,i+n+n,k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (ma[i][j])</span><br><span class="line">                <span class="built_in">add</span>(i,j+n+n,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">add</span>(i+n,j+n*<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Dinic</span>()==mid*n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();s=<span class="number">0</span>,t=n*<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            ma[i][j]=ss[j]==<span class="string">&#x27;Y&#x27;</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">3000</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid))ans=mid,l=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3043 【[USACO12JAN]牛联盟Bovine Alliance】</title>
    <url>/2019/06/29/%E9%A2%98%E8%A7%A3%20P3043%20%E3%80%90%5BUSACO12JAN%5D%E7%89%9B%E8%81%94%E7%9B%9FBovine%20Alliance%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给出$n$个点$m$条边的图,每条边找一个配对的点，要求边$(u,v)$配对的点是$u$或$v,$且每个点最多只能被一条边配对，求不同方案数</p>
<p>$ps:$题面的翻译不太准确，上面的翻译来自讨论,并稍加补充</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>先给出一组$hack$数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line">8 6</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">ouput:</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>有好几篇题解会被$hack,$原因是没有判在一个联通块中边数大于点数的情况</p>
<p>我们先$dfs$找出每个联通块，并算出这个联通块中的点数$po$与边数$ed,$然后分类讨论，最后利用乘法原理乘起来</p>
<p>$1.po&gt;ed:$由于是联通块，所以只能是$po&#x3D;ed+1$,即是一棵树。这种情况下我们在$po$个点中找$ed$个点去匹配，无论怎么选都是合法的，所以贡献即是$C_{po}^{ed}&#x3D;C_{po}^{po-1}&#x3D;po$</p>
<p>$2.po&#x3D;&#x3D;ed:$即一个环的情况，只有顺时针选和逆时针选两种情况，所以贡献即是$2$</p>
<p>$3.po&lt;ed:$这种情况下无论怎么选都不合法，所以贡献为$0$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200700</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;     </span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,head[N],vis[N],po,ed,ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    ++po;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next,++ed)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v])</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v);<span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])&#123;</span><br><span class="line">            po=ed=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            ed/=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (po&gt;ed)ans=ans*po%mod;</span><br><span class="line">            <span class="keyword">if</span> (po==ed)ans=ans*<span class="number">2</span>%mod;</span><br><span class="line">            <span class="keyword">if</span> (po&lt;ed)ans=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分类讨论</tag>
        <tag>$dfs$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2986 [USACO10MAR]伟大的奶牛聚集</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P2986%20%5BUSACO10MAR%5D%E4%BC%9F%E5%A4%A7%E7%9A%84%E5%A5%B6%E7%89%9B%E8%81%9A%E9%9B%86/</url>
    <content><![CDATA[<p>题意:有$n$个点,$n-1$条边,每个点上有$c_{i}$个人.要选一个点使所有人到这个点的距离最小</p>
<!--more--->

<p>观察如果已经知道$1$号节点所需的时间</p>
<p>那么，我们可以做如下假设：</p>
<p>① 所有的牛首先到达了$1$号节点</p>
<p>② $3$号节点以及他子树上的节点都需要退回$1-&gt;3$的路径的长度</p>
<p>③ 除了$3$号节点以及他子树上的节点都需要前进$1-&gt;3$的路径的长度</p>
<p>通过上面的三条东西，我们就可以从任意一个父节点推出子节点的时间</p>
<p>所以，又是一遍$O(n)$的计算就可以推出最终的答案</p>
<p>$d[v] &#x3D; d[u] - size[v]\times e[i].w + (n - size[v])*e[i].w;$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,to,next;</span><br><span class="line">&#125;e[<span class="number">400000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,cnt,ans=<span class="number">2100000000000000</span>,size[<span class="number">300000</span>],dep[<span class="number">400000</span>],f[<span class="number">400000</span>],head[<span class="number">400000</span>],c[<span class="number">400000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    size[u]=c[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dep[v]=dep[u]+e[i].dis;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        size[u]+=size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        f[v]=f[u]+(m<span class="number">-2</span>*size[v])*e[i].dis;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,f[v]);</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)c[i]=<span class="built_in">read</span>(),m+=c[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),d=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v,d);<span class="built_in">add</span>(v,u,d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[<span class="number">1</span>]+=dep[i]*c[i];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">min</span>(ans,f[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3254 【圆桌问题】</title>
    <url>/2019/05/30/%E9%A2%98%E8%A7%A3%20P3254%20%E3%80%90%E5%9C%86%E6%A1%8C%E9%97%AE%E9%A2%98%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>假设有来自$m$个不同单位的代表参加一次国际会议。每个单位的代表数分别为$r_i(1\leqslant i\leqslant m)$。</p>
<p>会议餐厅共有$n$张餐桌，每张餐桌可容纳$c_i(1\leqslant i\leqslant n)$个代表就餐。</p>
<p>为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试设计一个算法，给出满足要求的代表就餐方案。</p>
<p>对于给定的代表数和餐桌数以及餐桌容量，编程计算满足要求的代表就餐方案。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><h4 id="贪心做法"><a href="#贪心做法" class="headerlink" title="贪心做法"></a>贪心做法</h4><p>把桌子和单位的规模分别从大到小排个序(其实桌子拍不拍序没什么影响)。因为单位规模越大就越难满足，所以我们优先考虑他们;</p>
<p>而对于桌子你可以这样想，你桌子数量越多显然更容易满足题意，又因为小桌子很快会坐满而导致不能用，所以我们优先坐大桌子。</p>
<h4 id="还有一种最大流的做法"><a href="#还有一种最大流的做法" class="headerlink" title="还有一种最大流的做法"></a>还有一种最大流的做法</h4><p>考虑对桌子和单位构点。从源点连容量为$r_i$的边到单位$i$，从餐桌$i$连容量为$c_i$的边到汇点。</p>
<p>注意到每个单位只能在每张桌子上放一个人。考虑从每个单位向每张桌子连一条容量为$1$的边。</p>
<p>如果最大流小于人数和则无解。</p>
<p>否则对于每个单位，枚举它的出边，输出满流边的终点即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><p>只贴了贪心的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 400</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> w,id;</span><br><span class="line">&#125;p[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v[<span class="number">400</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w&gt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)p[i].w=<span class="built_in">read</span>(),p[i].id=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)q[i].w=<span class="built_in">read</span>(),q[i].id=i;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p[i].w;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!q[j].w)&#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">            v[i].<span class="built_in">pb</span>(q[j].id);--q[j].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">        ans[p[i].id]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i,<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;v[ans[i]].<span class="built_in">size</span>();++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,v[ans[i]][j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>贪心</tag>
        <tag>网络流$24$题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3355 【骑士共存问题】</title>
    <url>/2019/05/30/%E9%A2%98%E8%A7%A3%20P3355%20%E3%80%90%E9%AA%91%E5%A3%AB%E5%85%B1%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>求带障碍的$n\times n$的国际象棋棋盘可以放多少个马，使得两两之间互相不能攻击。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>将可以互相攻击的格子之间连一条边，然后求二分图的最大独立集即可。</p>
<p>二分图最大独立集$&#x3D;$点数$-$最大匹配</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,to,next;</span><br><span class="line">&#125;e[<span class="number">1000055</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,dy[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;,tot,id[<span class="number">207</span>][<span class="number">207</span>],ma[<span class="number">207</span>][<span class="number">207</span>],cnt=<span class="number">1</span>,head[N],dep[N],inque[N],cur[N],n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (!dep[v]&amp;&amp;e[i].dis)&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (e[i].dis&amp;&amp;dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                <span class="keyword">if</span> (used==mn)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">        res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),s=<span class="number">0</span>,t=n*n-m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)ma[<span class="built_in">read</span>()][<span class="built_in">read</span>()]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (!ma[i][j])&#123;</span><br><span class="line">                id[i][j]=++tot;</span><br><span class="line">                <span class="keyword">if</span> ((i+j)&amp;<span class="number">1</span>)<span class="built_in">add</span>(s,id[i][j],<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">add</span>(id[i][j],t,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (!ma[i][j])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> p=<span class="number">0</span>;p&lt;<span class="number">8</span>;++p)&#123;</span><br><span class="line">                    <span class="type">int</span> x=i+dx[p],y=j+dy[p];</span><br><span class="line">                    <span class="keyword">if</span> (ma[x][y]||x&lt;<span class="number">1</span>||y&lt;<span class="number">1</span>||x&gt;n||y&gt;n)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((i+j)&amp;<span class="number">1</span>)</span><br><span class="line">                        <span class="built_in">add</span>(id[i][j],id[x][y],<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">add</span>(id[x][y],id[i][j],<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n*n-m-<span class="built_in">Dinic</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流$24$题</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3393 【逃离僵尸岛】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P3393%20%E3%80%90%E9%80%83%E7%A6%BB%E5%83%B5%E5%B0%B8%E5%B2%9B%E3%80%91/</url>
    <content><![CDATA[<p>题意：有$N$个点，$M$条双向边，$K$个被侵略城市，与这$K$个被侵略城市距离$\leqslant$$S$的城市就是危险城市。其他就是安全城市。安全城市的点权就是$P$，危险城市的点权就是$Q$,问才$1$号点到$N$号点的最小花费。</p>
<span id="more"></span>

<p>标记危险城市显然需要跑最短路，但是对于$K$个点跑$K$次最短路时间复杂度太高，于是我们建立虚点连接$K$个点，边权为$0$,原先道路边权为$1$,跑最短路即可，这样就可以找到所有危险城市了。</p>
<p>对于点权最短路，我们只需要将到达点的权值设为边权即可，对于到达点是危险城市或是$1$或$N$特判。</p>
<p>记得开$long long$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,dis;</span><br><span class="line">&#125;e[<span class="number">499999</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt,head[<span class="number">400000</span>],dis[<span class="number">300000</span>],inque[<span class="number">300000</span>],tag[<span class="number">300000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(inque,<span class="number">0</span>,<span class="built_in">sizeof</span>(inque));</span><br><span class="line">    dis[s]=<span class="number">0</span>;queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[v]&gt;dis[u]+e[i].dis)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].dis;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])&#123;</span><br><span class="line">                    inque[v]=<span class="number">1</span>;q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),k=<span class="built_in">read</span>(),s=<span class="built_in">read</span>(),p=<span class="built_in">read</span>(),q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">read</span>();</span><br><span class="line">        tag[t]=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,t,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u,v,<span class="number">1</span>);<span class="built_in">add</span>(v,u,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        tag[i]=tag[i]==<span class="number">0</span>?dis[i]&lt;=s:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag[e[i].to]==<span class="number">2</span>)&#123;e[i].dis=inf;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (e[i].to==n||e[i].to==<span class="number">1</span>)&#123;e[i].dis=<span class="number">0</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (tag[e[i].to]==<span class="number">1</span>)&#123;e[i].dis=q;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> e[i].dis=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,dis[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3449 【[POI2006]PAL-Palindromes】</title>
    <url>/2019/05/12/%E9%A2%98%E8%A7%A3%20P3449%20%E3%80%90%5BPOI2006%5DPAL-Palindromes%E3%80%91/</url>
    <content><![CDATA[<p>题意：给出$n$个回文串$s_1, s_2, \cdots,s_n$求如下二元组$(i, j)$的个数$s_i + s_j$仍然是回文串</p>
<span id="more"></span>

<p>对于每个字符串进行$hash$,判断连接形成回文串只需判断$a+b$是否$&#x3D;$$b+a$即可</p>
<p>注:这里的$x+y$指的是将字符串$y$连到字符串$x$后面去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hash HASH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> base 131</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,hash[N],len[N],ch[N][<span class="number">26</span>],tot,po[N],w[N],ans;</span><br><span class="line">string s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)res=(res*base+s[i]-<span class="string">&#x27;a&#x27;</span>)%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(string s,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>(),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="type">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ch[now][v])ch[now][v]=++tot;</span><br><span class="line">        now=ch[now][v];</span><br><span class="line">    &#125;</span><br><span class="line">    w[now]=id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(string ss,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> le=ss.<span class="built_in">length</span>(),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;le;++i)&#123;</span><br><span class="line">        <span class="type">int</span> v=ss[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        now=ch[now][v];</span><br><span class="line">        <span class="keyword">if</span> (w[now]&amp;&amp;w[now]!=id)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((hash[w[now]]*po[len[id]]%mod+hash[id])%mod==(hash[id]*po[len[w[now]]]%mod+hash[w[now]])%mod)&#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();po[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200000</span>;++i)po[i]=po[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        len[i]=<span class="built_in">read</span>();cin&gt;&gt;s[i];</span><br><span class="line">        <span class="built_in">build</span>(s[i],i);</span><br><span class="line">        hash[i]=<span class="built_in">calc</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">query</span>(s[i],i);</span><br><span class="line">    cout&lt;&lt;ans*<span class="number">2</span>+n;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>$hash$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3480 【[POI2009]KAM-Pebbles】</title>
    <url>/2019/05/26/%E9%A2%98%E8%A7%A3%20P3480%20%E3%80%90%5BPOI2009%5DKAM-Pebbles%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有$N$堆石子，除了第一堆外，每堆石子个数都不少于前一堆的石子个数。两人轮流操作每次操作可以从一堆石子中移走任意多石子，但是要保证操作后仍然满足初始时的条件谁没有石子可移时输掉游戏。问先手是否必胜。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>题目要求每堆石子个数都不少于前一堆的石子个数，可以理解为差分数组$c$必须每项都$\geqslant 0$,而每次操作在第$i$堆取了$k$个石子，就相当于$c_{i}-&#x3D;k,c_{i+1}+&#x3D;k$,这就类似于阶梯$nim$了，不过由于方向相反，所以阶梯$nim$要反着做</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 300007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[N],w[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="built_in">read</span>(),ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=<span class="built_in">read</span>(),c[i]=w[i]-w[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n;i;--i)</span><br><span class="line">            <span class="keyword">if</span> ((n-i+<span class="number">1</span>)&amp;<span class="number">1</span>)</span><br><span class="line">                ans^=c[i];</span><br><span class="line">        <span class="keyword">if</span> (ans)<span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>巧妙转化</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3476 【[POI2008]TRO-Triangles】</title>
    <url>/2019/06/13/%E9%A2%98%E8%A7%A3%20P3476%20%E3%80%90%5BPOI2008%5DTRO-Triangles%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给定平面上的一些点，求这些点能组成的所有三角形的面积之和</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>以下向量的叉积运算用$;,\hat{};,$符号表示</p>
<p>$\sum S_{\triangle}$为$\sum\limits_{i&lt;j&lt;k}|(\vec{j}-\vec{i})<del>\hat{}</del>(\vec{k}-\vec{i})|$</p>
<p>我们先枚举$i$,并求出其他每个点以$i$为原点的坐标</p>
<p>这样对于每个点$<del>i</del>$要求的就变成了$\sum\limits_{i&lt;j&lt;k}\left|\vec{j};,\hat{};,\vec{k}\right|$，我们发现有个绝对值很难处理，于是我们想让绝对值中间的叉积运算为正。</p>
<p>$\vec{i};,\hat{};,\vec{j}$只有当$<del>\vec{i}</del>$在$<del>\vec{j}$逆时针方向是才会是正的，所以我们在枚举$</del>i~$后对所有的的向量进行极角排序，原式的绝对值就消去了。</p>
<p>这样原式就变成了$\sum\limits_{i&lt;j&lt;k}(\vec{j};,\hat{};,\vec{k})$ </p>
<p>再把叉积化成一般形式$:\sum\limits_{i&#x3D;1}^{n}\sum\limits_{j&#x3D;i+1}^{n}\sum\limits_{k&#x3D;j+1}^{n}(x_{j}\times y_{k}-y_{j}\times x_{k} )$</p>
<p>$\qquad\qquad\qquad\quad;;,&#x3D;\sum\limits_{i&#x3D;1}^{n}\sum\limits_{j&#x3D;i+1}^{n}(x_{j}\times \sum\limits_{k&#x3D;j+1}^{n} y_{k}-y_{j}\times\sum\limits_{k&#x3D;j+1}^{n} x_{k} )$</p>
<p>发现可以用后缀和维护</p>
<p>复杂度$O(n^2logn)$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200900</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps 1e-6</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">friend</span> point <span class="keyword">operator</span> -(point a,point b)&#123;</span><br><span class="line">        <span class="keyword">return</span> (point)&#123;b.x-a.x,b.y-a.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">int</span> <span class="keyword">operator</span> ^(point a,point b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N],q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a^b)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp1</span><span class="params">(point a,point b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x!=b.x)<span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)p[i].x=<span class="built_in">read</span>(),p[i].y=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+<span class="number">1</span>+n,cmp1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)q[++tot]=p[j]-p[i];</span><br><span class="line">        <span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+tot,cmp); </span><br><span class="line">        <span class="type">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=tot;j;--j)&#123;</span><br><span class="line">            sum1+=q[j].x,sum2+=q[j].y;</span><br><span class="line">            ans+=q[j].x*sum2-q[j].y*sum1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld.%d\n&quot;</span>,ans&gt;&gt;<span class="number">1</span>,(ans&amp;<span class="number">1</span>)*<span class="number">5</span>);;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>计算几何</tag>
        <tag>极角排序</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3618 【误会】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P3618%20%E3%80%90%E8%AF%AF%E4%BC%9A%E3%80%91/</url>
    <content><![CDATA[<p>题意:对于一句原句和听到的句子，理解方式是将听到的句子替换掉原句的相同部分，替换成$*$，使得原句形成一个新的句子，以达到新的意思，你的任务是统计有多少种意思</p>
<span id="more"></span>

<p>$dp+hash$</p>
<p>设子串长度为$m$，$f_{i}$表示到子串末尾在原句是第$i$个位置有几种方案，显然对于每个$f_{i}$有三种情况，当原句以$i$结尾的长度为$m$的字符串等于子串$f_{i}&#x3D;f_{i-1}+f_{i-m}$,即选或不选，否则$f_{i}&#x3D;f_{i-1}$,只能不选；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p=<span class="number">313</span>;</span><br><span class="line"><span class="type">int</span> v=<span class="number">1</span>,T,n,m,a[<span class="number">2000000</span>];</span><br><span class="line">ull power[<span class="number">2000000</span>],sum[<span class="number">2000000</span>],f[<span class="number">200000</span>],t;</span><br><span class="line"><span class="type">char</span> s1[<span class="number">200000</span>],s2[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    power[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100001</span>;i++) power[i]=power[i<span class="number">-1</span>]*p;</span><br><span class="line">    <span class="keyword">while</span> (v&lt;=T)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s\n%s&quot;</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        n=<span class="built_in">strlen</span>(s1+<span class="number">1</span>);m=<span class="built_in">strlen</span>(s2+<span class="number">1</span>);t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]*p+s1[i]<span class="number">-96</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            t=t*p+s2[i]<span class="number">-96</span>;</span><br><span class="line">        f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span> (t==sum[i]-sum[i-m]*power[m])</span><br><span class="line">                f[i]=(f[i<span class="number">-1</span>]+f[i-m])%<span class="number">1000000007</span>;</span><br><span class="line">            <span class="keyword">else</span> f[i]=f[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>,v,f[n]);</span><br><span class="line">        v++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>$hash$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3582 【[POI2015]KIN】</title>
    <url>/2019/06/15/%E9%A2%98%E8%A7%A3%20P3582%20%E3%80%90%5BPOI2015%5DKIN%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>共有$m$部电影，编号为$1\sim m$，第$i$部电影的好看值为$w_{i}$。在$n$天之中(从$1\sim n$编号）每天会放映一部电影，第$i$天放映的是第$<del>f_{i}</del>$部。你可以选择$l,r(1\leqslant l\leqslant r\leqslant n)$，并观看第$l,l+1,\cdots,r$天内所有的电影。如果同一部电影你观看多于一次，你会感到无聊，于是无法获得这部电影的好看值。所以你希望最大化观看且仅观看过一次的电影的好看值的总和。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>枚举右端点$r$，维护一个序列$c,$其中$c_l$表示$l\sim r$的好看值。对于一个位置$i$的好看值$w_i$，把他上一次出现的位置记做$pre_{i}$。由于如果有一个好看值$w_i$出现两次及以上，那么$w_i$的贡献为$0$,只有出现一次时才有贡献，显然只有在$pre_i+1\sim i$才会出现一次，所以当前$r$枚举到$i,c_{pre_i+1}\sim c_{i}+&#x3D;w_i,$另外， 对于一个$<del>i</del>,pre_{pre_{i}}+1\sim pre_{i}$在上一个$j(w_{j}&#x3D;&#x3D;w_{i})$时加上了一个$w_i$,但是对于$i,pre_{pre_{i}}+1\sim pre_{i}$区间中$w_i$的贡献为$0$,所以还有减去</p>
<p>这些操作考虑用线段树维护</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 4000600</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000600</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(k) (k&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(k) (k&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans,mx[M],tag[M],n,m,a[N],ma[N],pre[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    mx[k]=<span class="built_in">max</span>(mx[<span class="built_in">ls</span>(k)],mx[<span class="built_in">rs</span>(k)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    tag[k]+=d;</span><br><span class="line">    mx[k]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">ls</span>(k),tag[k]);<span class="built_in">add</span>(<span class="built_in">rs</span>(k),tag[k]);</span><br><span class="line">    tag[k]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        <span class="built_in">add</span>(k,d);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tag[k])<span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid)<span class="built_in">change</span>(<span class="built_in">ls</span>(k),l,mid,x,y,d);</span><br><span class="line">    <span class="keyword">if</span> (mid&lt;y) <span class="built_in">change</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r,x,y,d);</span><br><span class="line">    <span class="built_in">pushup</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=l&amp;&amp;r&lt;=y)</span><br><span class="line">        <span class="keyword">return</span> mx[k];</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tag[k])<span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span> (x&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">ls</span>(k),l,mid,x,y));</span><br><span class="line">    <span class="keyword">if</span> (mid&lt;y) res=<span class="built_in">max</span>(res,<span class="built_in">query</span>(<span class="built_in">rs</span>(k),mid+<span class="number">1</span>,r,x,y));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)w[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        pre[i]=ma[a[i]],ma[a[i]]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,pre[i]+<span class="number">1</span>,i,w[a[i]]);</span><br><span class="line">        <span class="keyword">if</span> (pre[i])<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,pre[pre[i]]+<span class="number">1</span>,pre[i],-w[a[i]]);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3645 【[APIO2015]雅加达的摩天楼】</title>
    <url>/2019/05/26/%E9%A2%98%E8%A7%A3%20P3645%20%E3%80%90%5BAPIO2015%5D%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有$m$只$doge$分布在$n$个摩天大楼上。楼和$doge$都是从$0$开始编号。</p>
<p>每只$doge$初始位置$b[i]$，弹跳力$p[i]$。 它每一次跳会恰好跳$p[i]$个大楼。比如从$x$可以到$x±p[i]$。</p>
<p>现在，$0$号$doge$要把某信息传给$1$号$doge$。对于一只$doge$，若它尚未知道信息，就不能动。 对于一只$doge$，若它已经知道信息，可以选择把信息告诉处于同一位置的$doge$们，或者跳去别的位置。</p>
<p>求最少跳的步数。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>先考虑暴力</p>
<p>对于每一只$doge$，我们从$b[i]$ 连边到所有它可以跳到（可以跳好多步）的位置，边权为需要跳的次数。</p>
<p>从$b[0]$跑一下最短路即可。</p>
<p>但是，这样边数太多了。</p>
<p>那么考虑一下分块，把每一座摩天大楼拆成$O(\sqrt{n})$层，第$0$层表示原点,第$j$层代表一步能跳到$b[i]±j$的摩天大楼，如果某座摩天大楼的$p[i]&gt;size$则暴力从该摩天大楼的原点向$b[i]±j$的摩天大楼的原点连边，然后这一层每一个摩天大楼向它能到达的摩天大楼的相同层连双向边，并且每座摩天大楼的每一层都要向该摩天大楼的原点连边，可以保证边数在$n\sqrt{n}$级别左右(视$n,m$同阶)</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 6000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 6000020</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,to,next;</span><br><span class="line">&#125;e[M*<span class="number">9</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,head[N],dis[N],inque[N],b[N],p[N],n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y*n+x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[s]=<span class="number">0</span>;queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();inque[u]=<span class="number">0</span>;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[v]&gt;dis[u]+e[i].dis)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].dis;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();<span class="type">int</span> size=<span class="built_in">sqrt</span>(n/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        b[i]=<span class="built_in">read</span>(),p[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (p[i]&gt;size)&#123;<span class="comment">//大于size的直接暴力连,边数最多m*sqrt(n)条 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d=<span class="number">1</span>,j=b[i]-p[i];j&gt;=<span class="number">0</span>;++d,j-=p[i])</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">id</span>(b[i],<span class="number">0</span>),<span class="built_in">id</span>(j,<span class="number">0</span>),d);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d=<span class="number">1</span>,j=b[i]+p[i];j&lt;n;++d,j+=p[i])</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">id</span>(b[i],<span class="number">0</span>),<span class="built_in">id</span>(j,<span class="number">0</span>),d);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">id</span>(b[i],<span class="number">0</span>),<span class="built_in">id</span>(b[i],p[i]),<span class="number">0</span>);<span class="comment">//从每层原点向第p[i]层连边，表示b[i]这个摩天大楼可以跳到b[i]±j的摩天大楼</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=size;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i+j&lt;n) <span class="built_in">add</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i+j,j),<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i-j&gt;=<span class="number">0</span>)<span class="built_in">add</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i-j,j),<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(i,<span class="number">0</span>),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(<span class="built_in">id</span>(b[<span class="number">0</span>],<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (dis[<span class="built_in">id</span>(b[<span class="number">1</span>],<span class="number">0</span>)]&gt;=inf)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dis[<span class="built_in">id</span>(b[<span class="number">1</span>],<span class="number">0</span>)]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>连边优化</tag>
        <tag>分块</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3953 【逛公园】</title>
    <url>/2019/06/30/%E9%A2%98%E8%A7%A3%20P3953%20%E3%80%90%E9%80%9B%E5%85%AC%E5%9B%AD%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>设$d$为$1\sim n$号点的最短路，问有多少长度不超过$d+K$的$1\sim n$路线。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>设$dis1_{a.,b}$为$a$到$b$的最短路，$dis_{a,b}$为$a$到$b$的路线</p>
<p>设$f[u][j]$为$dis[u][n]\leqslant dis1[u][n]+j$的方案数，这里把$j$称为“多余的路”</p>
<p>答案就是$f[1][K]$</p>
<p>考虑一条边$(u,v,w)$</p>
<p>走这条边的话，$(dis1[v][n]+w-dis1[u][n])$即是多余的路，当前的$f[u][j]$可以被$f[v]<a href="j-(dis1%5Bv%5D%5Bn%5D+w-dis1%5Bu%5D%5Bn%5D)%3C=K">j-(dis1[v][n]+w-dis1[u][n])</a>$更新</p>
<p>以上可以用跑一边反图，然后记忆化搜索实现</p>
<p>那么对于有$0$环这种情况怎么办呢，记一个$vis$数组，如果当前的$(u,k)$已经访问过了$($即$vis[u][k]&#x3D;&#x3D;1)$,则直接返回$-1$即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 600000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,to,dis,next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k,cnt,head[N],ans[<span class="number">10</span>],tot,vis[<span class="number">100007</span>][<span class="number">56</span>],dis[N],inque[N],f[<span class="number">100007</span>][<span class="number">56</span>],mod,u[N],v[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].u=u;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[v]&gt;dis[u]+e[i].dis)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].dis;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[u][k])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[u][k])<span class="keyword">return</span> f[u][k];</span><br><span class="line">    <span class="type">int</span> t,w;vis[u][k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u==n)f[u][k]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ((t=(k-(dis[v]+e[i].dis-dis[u])))&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((w=<span class="built_in">dfs</span>(v,t))==<span class="number">-1</span>)<span class="keyword">return</span> f[u][k]=<span class="number">-1</span>;</span><br><span class="line">            f[u][k]=(f[u][k]+w)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u][k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> f[u][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),k=<span class="built_in">read</span>(),mod=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            u[i]=<span class="built_in">read</span>(),v[i]=<span class="built_in">read</span>(),w[i]=<span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(v[i],u[i],w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">spfa</span>(n);        </span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">            <span class="built_in">add</span>(u[i],v[i],w[i]);</span><br><span class="line">        ans[++tot]=<span class="built_in">dfs</span>(<span class="number">1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3959 【宝藏】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P3959%20%E3%80%90%E5%AE%9D%E8%97%8F%E3%80%91/</url>
    <content><![CDATA[<p>题意$:$给定一张 $n$个点$,m$条边的<strong>有重边</strong>的图，找到一个生成树，使得每条边的权值$ \times$到根的距离最小</p>
<span id="more"></span>

<p>在任意时刻，我们关心的只有我们已经把多少点加进树了，以及树的最大树高是多少。</p>
<p>设$f[S][i]$为当前树已经包含集合$S$中的点，并且树高是$i$。</p>
<p>那么怎么判断$S_{0}$在转移中是否合法呢？我们设$G_{S}$是$S$能拓展到的边的集合，显然$G$数组是可以预处理出来的。</p>
<p>$f[S][i]&#x3D;min(f[S_0][i-1]+pay)$，其中满足$S_{0}$是$S$的子集，通过$S_{0}$加边一定可以联结成$S$。$pay$是这次加边的花费。</p>
<p>设$ss&#x3D;S<del>xor</del>S_{0}$，即$ss$是在$S$但不在$S_{0}$中的元素。</p>
<p>这里$pay$的计算显然是对于每个$ss$中的元素找$S_{0}$中的元素与它最短一条的边求和后$\times $树高(即$i$)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,ma[<span class="number">393939</span>],head[<span class="number">393939</span>],f[<span class="number">15</span>][<span class="number">40000</span>],dis[<span class="number">39</span>][<span class="number">39</span>],ans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),d=<span class="built_in">read</span>();</span><br><span class="line">        dis[v][u]=dis[u][v]=<span class="built_in">min</span>(dis[v][u],d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)dis[i][i]=<span class="number">0</span>,f[<span class="number">0</span>][<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">1</span>;i&lt;=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span> (re <span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (i&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))</span><br><span class="line">                <span class="keyword">for</span> (re <span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">                    <span class="keyword">if</span> (dis[j][k]!=inf)</span><br><span class="line">                        ma[i]|=<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> s=<span class="number">2</span>;s&lt;=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;++s)</span><br><span class="line">        <span class="keyword">for</span> (re <span class="type">int</span> i=s<span class="number">-1</span>;i;i=s&amp;(i<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">if</span> ((s|ma[i])==ma[i])&#123;</span><br><span class="line">                <span class="type">int</span> res=<span class="number">0</span>,st=s^i;</span><br><span class="line">                <span class="keyword">for</span> (re <span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">                    <span class="keyword">if</span> (st&amp;(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>)))&#123;</span><br><span class="line">                        <span class="type">int</span> t=inf;</span><br><span class="line">                        <span class="keyword">for</span> (re <span class="type">int</span> p=<span class="number">1</span>;p&lt;=n;++p)</span><br><span class="line">                            <span class="keyword">if</span> (i&amp;(<span class="number">1</span>&lt;&lt;(p<span class="number">-1</span>)))</span><br><span class="line">                                t=<span class="built_in">min</span>(t,dis[p][k]);</span><br><span class="line">                        res+=t;</span><br><span class="line">                        <span class="keyword">if</span> (res&gt;inf)<span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (res&lt;inf)</span><br><span class="line">                    <span class="keyword">for</span> (re <span class="type">int</span> t=<span class="number">1</span>;t&lt;n;++t)</span><br><span class="line">                        f[t][s]=<span class="built_in">min</span>(f[t][s],f[t<span class="number">-1</span>][i]+res*t);</span><br><span class="line">            &#125;</span><br><span class="line">    ans=inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,f[i][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>状压$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3604 【美好的每一天】</title>
    <url>/2019/05/25/%E9%A2%98%E8%A7%A3%20P3604%20%E3%80%90%E7%BE%8E%E5%A5%BD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>一个区间如果满足区间内的值重排之后可以成为一个回文串，则这个区间可以回归天空</p>
<p>当前有$m$个区间，要求每个区间中有多少个子区间可以回归天空</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>很容易想到是莫队题，但是对于维护区间贡献很难处理。</p>
<p>由于区间内的字符都是小写字母，考虑用$2$的幂次表示，如$’a’$表示为$2^0$,$’b’$表示为$2^1$,$’z’$表示为$2^{25}$(用$2$的幂次表示的原因下会讲)</p>
<p>然后考虑一个区间$[l,r]$对答案有贡献当且仅当$a_{r}<del>xor</del>a_{l-1}&#x3D;2^x$或$0$，其中$a_{i}$为异或前缀和</p>
<p>开一个计数数组$c$,其中$c_{i}$表示当前区间中异或前缀和的值为$i$的点的个数，统计答案时若当前枚举到的点$j$的异或前缀和为$a_{j}$，枚举$2$的所有幂次和$0$,$ans$直接加上(或减去)$c[a_{j}]+\sum\limits_{i&#x3D;0}^{25}c[2^i<del>xor</del>a_{j}]$</p>
<p>至于为什么区间内字符用$2$的幂次表示,换用别的编号呢$?$</p>
<p>如果不用$2$的幂次表示,换用别的编号，那么即使$xor$起来$&#x3D;0$也不能说明区间内的数能排列成回文串,如一个区间内三个数的的编号分别为$1,4,5$,即使它们异或起来也是$0$，但是它们显然不能构成回文串。</p>
<p>$PS:$当前维护$[l,r]$的信息时，$ans$应加上$[l-1,r-1]$的信息(若是减去则维护$[l-1,r]$的信息)，并且桶维护$[l-1,r]$的信息,因为当前枚举到的点是$r$。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 60007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,num;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans,block,n,m,w[N],a[N],Ans[N];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> c[<span class="number">1</span>&lt;&lt;<span class="number">26</span>];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.l/block)^(b.l/block)?a.l&lt;b.l:(((a.l/block)&amp;<span class="number">1</span>)?a.r&lt;b.r:a.r&gt;b.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        ans+=c[k^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">    ans+=c[k];</span><br><span class="line">    ++c[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        ans-=c[k^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">    --c[k];</span><br><span class="line">    ans-=c[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();block=(m&amp;&amp;n/<span class="built_in">sqrt</span>(m*<span class="number">2</span>/<span class="number">3</span>))?n/<span class="built_in">sqrt</span>(m*<span class="number">2</span>/<span class="number">3</span>):<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=(<span class="number">1</span>&lt;&lt;(s[i]-<span class="string">&#x27;a&#x27;</span>)),a[i]=a[i<span class="number">-1</span>]^w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)q[i].l=<span class="built_in">read</span>()<span class="number">-1</span>,q[i].r=<span class="built_in">read</span>(),q[i].num=i;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> ql=q[i].l,qr=q[i].r;</span><br><span class="line">        <span class="keyword">while</span> (l&gt;ql)<span class="built_in">add</span>(a[--l]);</span><br><span class="line">        <span class="keyword">while</span> (r&lt;qr)<span class="built_in">add</span>(a[++r]);</span><br><span class="line">        <span class="keyword">while</span> (l&lt;ql)<span class="built_in">del</span>(a[l++]);</span><br><span class="line">        <span class="keyword">while</span> (r&gt;qr)<span class="built_in">del</span>(a[r--]);</span><br><span class="line">        Ans[q[i].num]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>莫队</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3556 【[POI2013]MOR-Tales of seafaring】</title>
    <url>/2019/06/30/%E9%A2%98%E8%A7%A3%20P3556%20%E3%80%90%5BPOI2013%5DMOR-Tales%20of%20seafaring%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给$n$个点$m$条边无向图，每次询问两个点之间是否有长度为$d$的路径（不一定是简单路径）</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>设这两个点分别为$x,y$</p>
<p>如果$x,y$之间有一条奇偶性与$d$相同且长度$\leqslant d$的路径，那么结果就是$TAK,$否则则是$NIE.$</p>
<p>证明$:$对于一条边$(a,b)$,可以花费$2$的长度,从$a$到$b$，再从$b$到$a$.那么对于一条长度$\leqslant d$且奇偶性与$d$相同的路径, 我们可以在一条边上反复横跳以能够刚好以$d$的长度到达终点。</p>
<p>由于边权为$1,$所以求最短路可以用$bfs$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100057</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,d,id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,Q,dis[N],cnt,head[N];</span><br><span class="line"><span class="type">bool</span> ans[<span class="number">1050596</span>];</span><br><span class="line">vector&lt;node&gt;v[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+n;++i)dis[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[v])<span class="keyword">continue</span>;</span><br><span class="line">            dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[s].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        node p=v[s][i];</span><br><span class="line">        <span class="type">int</span> t=dis[p.y+(p.d&amp;<span class="number">1</span>)*n];</span><br><span class="line">        ans[p.id]=(t&lt;=p.d&amp;&amp;t&amp;&amp;((t&amp;<span class="number">1</span>)==(p.d&amp;<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),Q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u+n,v);<span class="built_in">add</span>(u,v+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Q;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),d=<span class="built_in">read</span>();</span><br><span class="line">        v[x].<span class="built_in">push_back</span>((node)&#123;y,d,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">bfs</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Q;++i)</span><br><span class="line">        <span class="built_in">puts</span>(ans[i]?<span class="string">&quot;TAK&quot;</span>:<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>$bfs$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3980 【[NOI2008]志愿者招募】</title>
    <url>/2019/06/01/%E9%A2%98%E8%A7%A3%20P3980%20%E3%80%90%5BNOI2008%5D%E5%BF%97%E6%84%BF%E8%80%85%E6%8B%9B%E5%8B%9F%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有$n$天，每天需要$a_i$个志愿者,一共有$m$类志愿者可以招募。其中第$i$类可以从第$s_i$天工作到第$t_i$天，招募费用是每人$c_i$元。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>边$(a,b)$表示边的容量为$a$费用为$b$</p>
<p>对于某一天为$i$</p>
<p>$i \stackrel{inf-a_{i}, 0}{\longrightarrow}i+1$</p>
<p>对于某一种志愿者$j$</p>
<p>$s_i \stackrel{inf,c_{i}}{\longrightarrow}t_i+1$</p>
<p>此外</p>
<p>$S \stackrel{inf,0}{\longrightarrow}1$</p>
<p>$n+1 \stackrel{inf,0}{\longrightarrow}T$</p>
<p>求最小费用最大流即可。</p>
<p>那么为什么要这么连边呢$?$</p>
<p>首先我们考虑，这样连最大流肯定$&#x3D;inf$,由于求的是最小费用最大流，所以流会尽量往$i {\longrightarrow}i+1$这一类边走，但是由于这类边的边权为$inf-a_i$,所以必定至少有$a_i$的流往$s_i{\longrightarrow}t_i+1$这类边流，这就满足题意了。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 40000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,dis,w,next;</span><br><span class="line">&#125;e[<span class="number">1007000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,head[N],dis[N],inque[N],vis[N],cur[N],cost,w[N],s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].w=-w;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                cost+=e[i].w*mi;</span><br><span class="line">                <span class="keyword">if</span> (mn==used)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        vis[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (vis[t])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">            res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();s=<span class="number">0</span>,t=n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        w[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">add</span>(s,<span class="number">1</span>,inf,<span class="number">0</span>),<span class="built_in">add</span>(n+<span class="number">1</span>,t,inf,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(i,i+<span class="number">1</span>,inf-w[i],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),d=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(a,b+<span class="number">1</span>,inf,d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dinic</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3702 【[SDOI2017]序列计数】</title>
    <url>/2019/05/19/%E9%A2%98%E8%A7%A3%20P3702%20%E3%80%90%5BSDOI2017%5D%E5%BA%8F%E5%88%97%E8%AE%A1%E6%95%B0%E3%80%91/</url>
    <content><![CDATA[<p>题意:Alice 想要得到一个长度为 $n$ 的序列，序列中的数都是不超过 $m$ 的正整数，而且这 $n$ 个数的和是 $p$ 的倍数。</p>
<p>Alice 还希望，这 $n$ 个数中，至少有一个数是质数。</p>
<p>Alice 想知道，有多少个序列满足她的要求。</p>
<p>$1\leq n \leq 10^9,1\leq m \leq 2\times 10^7,1\leq p\leq 100$。</p>
<span id="more"></span>

<p>很显然，要求的方案数可以转化为所有方案数减去不含质数的方案数</p>
<p>对于所有方案，设$f_{i,j}$表示前$i$个数$mod~p$等于$j$的方案数</p>
<p>$f_{i,j}&#x3D;\sum\limits_{k&#x3D;1}^{m}f_{i-1,((j-k)%p+p)%p}$</p>
<p>对于不含质数的方案，我们只需先预处理$cnt_i$表示$1$<del>$m$中$%p&#x3D;&#x3D;i$的合数的个数，设$g_{i,j}$表示前$i$个数$mod</del>p$等于$j$且没有质数的方案数。</p>
<p>$g_{i,j}&#x3D;\sum\limits_{k&#x3D;0}^{p-1} cnt_{((j-k)%p+p)%p}$</p>
<p>然后发现这两个东西显然都可以用矩阵快速幂优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 20170408</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 20000070</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> f[M];</span><br><span class="line"><span class="type">int</span> cnt[M],pre[<span class="number">7000000</span>],tot,n,m,p,ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    a+=b;</span><br><span class="line">    <span class="keyword">while</span> (a&gt;=mod)a-=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">207</span>][<span class="number">207</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init0</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p<span class="number">-1</span>;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=p<span class="number">-1</span>;++j)</span><br><span class="line">                a[i][j]=i==j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span> *(node a,node b)&#123;</span><br><span class="line">        node res;res.<span class="built_in">init0</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p<span class="number">-1</span>;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;=p<span class="number">-1</span>;++k)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=p<span class="number">-1</span>;++j)</span><br><span class="line">                    <span class="built_in">add</span>(res.a[i][k],<span class="number">1ll</span>*a.a[i][j]*b.a[j][k]%mod);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> node <span class="keyword">operator</span> ^(node x,<span class="type">int</span> p)&#123;</span><br><span class="line">        node res;res.<span class="built_in">init1</span>();</span><br><span class="line">        <span class="keyword">while</span> (p)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p&amp;<span class="number">1</span>)res=res*x;</span><br><span class="line">            x=x*x;</span><br><span class="line">            p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t,A;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!f[i])pre[++tot]=i,--cnt[i%p];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*pre[j]&lt;=m;++j)&#123;</span><br><span class="line">            f[i*pre[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i%pre[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//     freopen(&quot;dodo.in&quot;, &quot;r&quot;, stdin); freopen(&quot;dodo.out&quot;, &quot;w&quot;, stdout); </span></span><br><span class="line">    n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();p=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)++cnt[i%p];</span><br><span class="line">    <span class="built_in">init</span>();t.<span class="built_in">init0</span>();</span><br><span class="line">    <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">0</span>;i&lt;=p<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span> (re <span class="type">int</span> j=<span class="number">0</span>;j&lt;=p<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="type">int</span> d=((j-i)%p+p)%p;</span><br><span class="line">            <span class="keyword">if</span> (d==<span class="number">0</span>)d=p;<span class="comment">//特判，因为序列中的数都是不超过mm的正整数 </span></span><br><span class="line">            <span class="keyword">if</span> (m&gt;=d)t.a[i][j]=(m-d)/p+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    t=t^n;<span class="type">int</span> res=t.a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=p<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=p<span class="number">-1</span>;++j)&#123;</span><br><span class="line">            <span class="type">int</span> d=((j-i)%p+p)%p;<span class="comment">//余数 </span></span><br><span class="line">            t.a[i][j]=cnt[d];</span><br><span class="line">        &#125;</span><br><span class="line">    t=t^n;</span><br><span class="line">    cout&lt;&lt;((res-t.a[<span class="number">0</span>][<span class="number">0</span>])%mod+mod)%mod&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4014 【分配问题】</title>
    <url>/2019/05/30/%E9%A2%98%E8%A7%A3%20P4014%20%E3%80%90%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有 nn 件工作要分配给$n$个人做。第$i$个人做第$j$件工作产生的效益为 $c_{i,j}$。试设计一个将$n$件工作分配给$n$个人做的分配方案，使产生的总效益最大。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>一个人只能搭配一个任务，显然应该想到二分图，由于有权值，只需在二分图上跑费用流即可</p>
<p>以下边$(a,b)$表示容量为a,费用为$b$的边</p>
<p>首先从$s$向每个人连边$(1,0)$,再从每个任务向$t$连边$(1,0)$</p>
<p>在每个人$i$与任务$j$之间连边$(1,c_{i,j})$</p>
<p>分别跑最小费用最大流和最大费用最大流即可</p>
<p>最大费用最大流只需把$spfa$的最短路改成最长路即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,w,to,next;</span><br><span class="line">&#125;e[<span class="number">1000067</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,head[N],dis[N],vis[N],inque[N],cost,n,s,t,c[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].w=-w;</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)dis[i]=-inf;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&lt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=-inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                cost+=mi*e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (used==mn)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dinic1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa1</span>())&#123;</span><br><span class="line">        vis[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (vis[t])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="built_in">dfs</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dinic2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa2</span>())&#123;</span><br><span class="line">        vis[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (vis[t])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="built_in">dfs</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),s=<span class="number">0</span>,t=n+n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            c[i][j]=<span class="built_in">read</span>(),<span class="built_in">add</span>(i,j+n,<span class="number">1</span>,c[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">add</span>(s,i,<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">add</span>(i+n,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Dinic1</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost);</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">1</span>;cost=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="built_in">add</span>(i,j+n,<span class="number">1</span>,c[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">add</span>(s,i,<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">add</span>(i+n,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Dinic2</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>网络流$24$题</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4085 【[USACO17DEC]Haybale Feast】</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20P4085%20%E3%80%90%5BUSACO17DEC%5DHaybale%20Feast%E3%80%91/</url>
    <content><![CDATA[<p>线段树、树状数组、ST表、分块、堆……等数据结构，但是复杂度都至少是$nlogn$的，于是我写了个尺取法+单调队列的方法，时间复杂度$O(n)$</p>
<p>单调队列维护区间中$si$~$sj$的最大值,这里运用到了一点贪心策略，如果两个区间有包含关系，那么大的区间最大值一定$\geqslant$小的区间最大值，所以对于每一个$i$，我们去前面找第一个$head$，使$sum_{i,j}\geqslant m$</p>
<p><img src="https://cdn.luogu.org/upload/pic/49403.png"></p>
<p>如图所示，我们选择$5$作为$head$而不是前面的$11$、$2$、$3$、$4$，是因为区间更长，就像在一个数列中加入了另一些数，另一些数中可能有大于原数列的最大值，因为要求最大值的最小值，故不是最优。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;<span class="comment">//快读</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">300000</span>],b[<span class="number">300000</span>],p[<span class="number">300000</span>],head=<span class="number">1</span>,head1=<span class="number">1</span>,tail1=<span class="number">0</span>,ans=<span class="number">2100000000</span>;</span><br><span class="line">ll sum,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a&gt;b)<span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>(),b[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">while</span> (head&lt;=i&amp;&amp;sum-a[head]&gt;=m)&#123;</span><br><span class="line">            sum-=a[head];head++;<span class="comment">//这里注意要先减再head++，尺取法与单调队列在这里都容易出错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head1&lt;=tail1&amp;&amp;p[head1]&lt;head) head1++;<span class="comment">//若队首位置小于区间左端，则出队</span></span><br><span class="line">        <span class="keyword">while</span> (head1&lt;=tail1&amp;&amp;b[i]&gt;=b[p[tail1]]) tail1--;<span class="comment">//若新加入的数大于队尾，则队尾出队</span></span><br><span class="line">        p[++tail1]=i;<span class="comment">//放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (sum&gt;=m)ans=<span class="built_in">Min</span>(ans,b[p[head1]]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>尺取法</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4088 【[USACO18FEB]Slingshot】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P4088%20%E3%80%90%5BUSACO18FEB%5DSlingshot%E3%80%91/</url>
    <content><![CDATA[<p>题意:有一个数轴，上面有$n$ 个传送门，使用第$i$个传送门，你可以从$x_i$ 走到 $y_i$，花费的时间为 $t_i$ 秒。你的速度为$1 $格$&#x2F;$秒，有 $m$ 次询问，每次你要从 $a_i$ 走到 $b_i$，最多使用一次传送门，问最少需要多少秒。</p>
<span id="more"></span>

<p>由于坐标很大，先离散化，然后离线处理询问，然后通过调整枚举顺序与在树状数组的插入位置等处理不同情况，手推一下应该不难理解，情况如下图所示</p>
<p>设$x,y$为弹弓左端点与右端点,$s,t$为查询左端点与右端点</p>
<p><img src="https://i.loli.net/2019/03/25/5c98dbd7cda1b.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,v,id;</span><br><span class="line">&#125;a[<span class="number">200200</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[<span class="number">200200</span>],cnt,nm,px[<span class="number">200200</span>],py[<span class="number">200200</span>],ans[<span class="number">100100</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;<span class="keyword">return</span> (a.x!=b.x)?a.x&lt;b.x:a.y&lt;b.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;x&lt;=cnt;x+=x&amp;-x)</span><br><span class="line">        c[x]=<span class="built_in">min</span>(c[x],d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x-=x&amp;-x)</span><br><span class="line">        res=<span class="built_in">min</span>(res,c[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),t=<span class="built_in">read</span>();</span><br><span class="line">        a[++cnt]=node&#123;x,y,t,<span class="number">0</span>&#125;;</span><br><span class="line">        px[cnt]=x;py[cnt]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        a[++cnt]=node&#123;x,y,<span class="number">0</span>,i&#125;;</span><br><span class="line">        px[cnt]=x;py[cnt]=y;</span><br><span class="line">        ans[i]=<span class="built_in">abs</span>(y-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(px+<span class="number">1</span>,px+<span class="number">1</span>+cnt);</span><br><span class="line">    <span class="built_in">sort</span>(py+<span class="number">1</span>,py+<span class="number">1</span>+cnt);</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+cnt,cmp);</span><br><span class="line">    nm=<span class="built_in">unique</span>(px+<span class="number">1</span>,px+<span class="number">1</span>+cnt)-px<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)a[i].x=<span class="built_in">lower_bound</span>(px+<span class="number">1</span>,px+<span class="number">1</span>+nm,a[i].x)-px;</span><br><span class="line">    nm=<span class="built_in">unique</span>(py+<span class="number">1</span>,py+<span class="number">1</span>+cnt)-py<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)a[i].y=<span class="built_in">lower_bound</span>(py+<span class="number">1</span>,py+<span class="number">1</span>+nm,a[i].y)-py;<span class="comment">//离散化</span></span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)</span><br><span class="line">        <span class="keyword">if</span> (!a[i].id)</span><br><span class="line">            <span class="built_in">change</span>(a[i].y,-px[a[i].x]-py[a[i].y]+a[i].v);</span><br><span class="line">        <span class="keyword">else</span> ans[a[i].id]=<span class="built_in">min</span>(ans[a[i].id],<span class="built_in">query</span>(a[i].y)+px[a[i].x]+py[a[i].y]);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)</span><br><span class="line">        <span class="keyword">if</span> (!a[i].id)</span><br><span class="line">            <span class="built_in">change</span>(cnt-a[i].y+<span class="number">1</span>,-px[a[i].x]+py[a[i].y]+a[i].v);</span><br><span class="line">        <span class="keyword">else</span> ans[a[i].id]=<span class="built_in">min</span>(ans[a[i].id],<span class="built_in">query</span>(cnt-a[i].y+<span class="number">1</span>)+px[a[i].x]-py[a[i].y]);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=cnt;i;--i)    </span><br><span class="line">        <span class="keyword">if</span> (!a[i].id)</span><br><span class="line">            <span class="built_in">change</span>(a[i].y,px[a[i].x]-py[a[i].y]+a[i].v);</span><br><span class="line">        <span class="keyword">else</span> ans[a[i].id]=<span class="built_in">min</span>(ans[a[i].id],<span class="built_in">query</span>(a[i].y)-px[a[i].x]+py[a[i].y]);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=cnt;i;--i)</span><br><span class="line">        <span class="keyword">if</span> (!a[i].id)</span><br><span class="line">            <span class="built_in">change</span>(cnt-a[i].y+<span class="number">1</span>,px[a[i].x]+py[a[i].y]+a[i].v);</span><br><span class="line">        <span class="keyword">else</span> ans[a[i].id]=<span class="built_in">min</span>(ans[a[i].id],<span class="built_in">query</span>(cnt-a[i].y+<span class="number">1</span>)-px[a[i].x]-py[a[i].y]);<span class="comment">//四种情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离线</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4008 【[NOI2003]文本编辑器】</title>
    <url>/2019/05/19/%E9%A2%98%E8%A7%A3%20P4008%20%E3%80%90%5BNOI2003%5D%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4008">链接</a></p>
<span id="more"></span>

<p>块状链表模板题，但出奇的恶心</p>
<p>由于一些操作会产生或删去一些块，所以对于块的产生与删去，块的编号用内存池分配</p>
<p>先给出几个操作，添加块($add$),查询属于哪个块($belong$),分裂($split$),合并($merge$)，具体细节看代码分析.</p>
<p>下面对题目给的操作进行分析</p>
<h5 id="1-Move-k-将光标移动到第-k-个字符之后"><a href="#1-Move-k-将光标移动到第-k-个字符之后" class="headerlink" title="$1.Move~k$ 将光标移动到第 $k$个字符之后"></a>$1.Move~k$ 将光标移动到第 $k$个字符之后</h5><p>直接移动即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pos=read();</span><br></pre></td></tr></table></figure>

<h5 id="2-Insertns-在光标处插入长度为-n-的字符串-s-，光标位置不变"><a href="#2-Insertns-在光标处插入长度为-n-的字符串-s-，光标位置不变" class="headerlink" title="$2.Insertns$ 在光标处插入长度为$n$的字符串$s$，光标位置不变"></a>$2.Insert<del>n</del>s$ 在光标处插入长度为$n$的字符串$s$，光标位置不变</h5><p>将插入串分块，最后一块(即剩余块,唯一的一块长度不一定是$size$的块)与它后面那一块判断一下，如果长度相加后$&lt;size$,那么就合并.</p>
<p>并且我们很可能在块内插入，那我们就要将这个块从插入位置$split$,然后进行插入。</p>
<h5 id="3-Delete-n-删除光标后的n个字符，光标位置不变"><a href="#3-Delete-n-删除光标后的n个字符，光标位置不变" class="headerlink" title="$3.Delete~n$ 删除光标后的n个字符，光标位置不变"></a>$3.Delete~n$ 删除光标后的n个字符，光标位置不变</h5><p>先将两端所在的块分裂，然后直接删除，并且对两端分类出的块长度和进行判断，如果$&lt;size$，就进行$merge$操作。</p>
<h5 id="4-Get-n-输出光标后的-n-个字符，光标位置不变"><a href="#4-Get-n-输出光标后的-n-个字符，光标位置不变" class="headerlink" title="$4.Get~n$ 输出光标后的$n$个字符，光标位置不变"></a>$4.Get~n$ 输出光标后的$n$个字符，光标位置不变</h5><p>只需把左边块和右边块的需要部分给截出来，与中间完整的块拼在一起输出即可</p>
<h5 id="5-Prev-光标前移一个字符"><a href="#5-Prev-光标前移一个字符" class="headerlink" title="$5.Prev$ 光标前移一个字符"></a>$5.Prev$ 光标前移一个字符</h5><p>直接移动即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--pos;</span><br></pre></td></tr></table></figure>

<h5 id="6-Next-光标后移一个字符"><a href="#6-Next-光标后移一个字符" class="headerlink" title="$6.Next$ 光标后移一个字符"></a>$6.Next$ 光标后移一个字符</h5><p>直接移动即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">++pos;</span><br></pre></td></tr></table></figure>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code:$"></a>$Code:$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> nx,size;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">4500</span>];</span><br><span class="line">&#125;t[<span class="number">9000</span>];</span><br><span class="line"><span class="type">char</span> ans[<span class="number">8000000</span>];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,tot,pos,pool[<span class="number">800000</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size=<span class="number">2007</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mod</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> pool[++cnt];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;pool[cnt--]=x;&#125;<span class="comment">//动态分配和回收内存池</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> len,<span class="type">char</span> *s)</span></span>&#123;<span class="comment">//在编号为x的块后面加一个编号为y的块</span></span><br><span class="line">    t[y].nx=t[x].nx;t[y].size=len;</span><br><span class="line">    <span class="built_in">memcpy</span>(t[y].s,s,<span class="built_in">sizeof</span>(t[y].s));</span><br><span class="line">    t[x].nx=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">belong</span><span class="params">(<span class="type">int</span> &amp;k)</span></span>&#123;<span class="comment">//查询属于哪个块</span></span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p&amp;&amp;k&gt;t[p].size)k-=t[p].size,p=t[p].nx;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//将第x个块从y处分裂</span></span><br><span class="line">    <span class="keyword">if</span> (!x||y==t[x].size)<span class="keyword">return</span>;<span class="comment">//如果当前块不存在或从块中最后一个开始分割是没有意义的</span></span><br><span class="line">    <span class="built_in">add</span>(x,<span class="built_in">mod</span>(),t[x].size-y,t[x].s+y);<span class="comment">//t[x].s+y就相当于截去了t[x].s[1~(y-1)]</span></span><br><span class="line">    t[x].size=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//合并x和y，把y接在x的后面,然后把y删除</span></span><br><span class="line">    <span class="built_in">memcpy</span>(t[x].s+t[x].size,t[y].s,t[y].size);</span><br><span class="line">    t[x].size+=t[y].size;t[x].nx=t[y].nx;<span class="built_in">del</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> len,<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=pos,now=<span class="built_in">belong</span>(k),w=now;</span><br><span class="line">    <span class="built_in">split</span>(now,k);<span class="type">int</span> sum,nx;</span><br><span class="line">    <span class="keyword">for</span> (sum=<span class="number">0</span>;sum+size&lt;=len;sum+=size)&#123;</span><br><span class="line">        <span class="built_in">add</span>(now,nx=<span class="built_in">mod</span>(),size,s+sum);</span><br><span class="line">        now=nx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len-sum&gt;<span class="number">0</span>)&#123;<span class="comment">//如果剩余块的大小大于0 </span></span><br><span class="line">        <span class="built_in">add</span>(now,nx=<span class="built_in">mod</span>(),len-sum,s+sum);</span><br><span class="line">        <span class="keyword">if</span> (t[now].size+t[nx].size&lt;size&amp;&amp;nx)</span><br><span class="line">            <span class="built_in">merge</span>(now,nx);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (t[w].size+t[t[w].nx].size&lt;size&amp;&amp;t[w].nx)</span><br><span class="line">        <span class="built_in">merge</span>(w,t[w].nx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dele</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=pos,now=<span class="built_in">belong</span>(k);</span><br><span class="line">    <span class="built_in">split</span>(now,k);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=t[now].nx;t[i].size&lt;len&amp;&amp;i;i=t[i].nx)</span><br><span class="line">        len-=t[i].size;</span><br><span class="line">    <span class="built_in">split</span>(i,len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=t[now].nx;j!=t[i].nx;j=t[now].nx)</span><br><span class="line">        t[now].nx=t[j].nx,<span class="built_in">del</span>(j);</span><br><span class="line">    <span class="type">int</span> q=t[i].nx;</span><br><span class="line">    <span class="keyword">while</span> (t[now].size+t[q].size&lt;size&amp;&amp;q)<span class="built_in">merge</span>(now,q),q=t[q].nx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=pos;</span><br><span class="line">    <span class="type">int</span> now=<span class="built_in">belong</span>(k);</span><br><span class="line">    <span class="type">int</span> nx=t[now].nx;</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">min</span>(len,t[now].size-k);</span><br><span class="line">    <span class="built_in">memcpy</span>(ans,t[now].s+k,l);</span><br><span class="line">    <span class="keyword">while</span> (l+t[nx].size&lt;=len&amp;&amp;nx)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(ans+l,t[nx].s,t[nx].size);</span><br><span class="line">        l+=t[nx].size;nx=t[nx].nx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len-l&gt;<span class="number">0</span>&amp;&amp;nx)</span><br><span class="line">        <span class="built_in">memcpy</span>(ans+l,t[nx].s,len-l);</span><br><span class="line">    ans[len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[<span class="number">8000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch!=<span class="string">&#x27;M&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;I&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;D&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;G&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;P&#x27;</span>&amp;&amp;ch!=<span class="string">&#x27;N&#x27;</span>)ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2e5</span>+<span class="number">7</span>;++i)pool[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="type">char</span> ch=<span class="built_in">gc</span>();</span><br><span class="line">        <span class="keyword">if</span> (ch==<span class="string">&#x27;M&#x27;</span>)&#123;<span class="comment">//将光标移动到第 k个字符之后</span></span><br><span class="line">            pos=<span class="built_in">read</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">&#x27;I&#x27;</span>)&#123;<span class="comment">//在光标处插入长度为n的字符串s，光标位置不变</span></span><br><span class="line">            <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                s[i]=<span class="built_in">getchar</span>();</span><br><span class="line">                <span class="keyword">if</span> (s[i]&lt;<span class="number">32</span>||s[i]&gt;<span class="number">126</span>)--i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ins</span>(n,s);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">&#x27;D&#x27;</span>)&#123;<span class="comment">//删除光标后的n个字符</span></span><br><span class="line">            <span class="built_in">dele</span>(<span class="built_in">read</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">&#x27;G&#x27;</span>)&#123;<span class="comment">//输出光标后的n个字符</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">read</span>());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">            --pos;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>分块</tag>
        <tag>块状链表</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4135 【作诗】</title>
    <url>/2019/05/24/%E9%A2%98%E8%A7%A3%20P4135%20%E3%80%90%E4%BD%9C%E8%AF%97%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>$N$个数，$M$组询问，每次问$[l,r]$中有多少个数出现正偶数次。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution:$"></a>$Solution:$</h2><p>考虑分块</p>
<p>先设$:f[i][j]$表示$i$块到$j$块的有多少个数出现正偶数次;</p>
<p>$sum[i][j]$表示<strong>前</strong>$i$块中，数值$j$的出现次数;</p>
<p>预处理$f$数组和$sum$数组,时间复杂度$O(n\sqrt n)$</p>
<p>处理询问时，设$res$为最终答案,$A$为询问左端点所在块，$B$为询问右端点所在块，先把$res$初值设为$f[A+1][B-1]$,然后处理两侧的不完整块.</p>
<p>对于一个值$j$,它在第$A+1$个块到第$B-1$个块中出现的次数就是$sum[B-1][j]-sum[A][j]$(类似于前缀和)</p>
<p>在处理不完整块的时候,若当前点的下标为$j$,那么只需要判断$++cnt[w[j]]+sum[B-1][w[j]]-sum[A][w[j]]$的奇偶性,并特判一下$0$变$1$的情况,然后更改$res$的值即可.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S 323</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> size,num,w[N],ans,n,m,c,sum[S][N],cnt[N],belong[N],l[N],r[N],f[S][S];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    size=<span class="built_in">sqrt</span>(n);num=(n<span class="number">-1</span>)/size+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)belong[i]=(i<span class="number">-1</span>)/size+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;++i)l[i]=(i<span class="number">-1</span>)*size+<span class="number">1</span>,r[i]=i*size;r[num]=n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;++i)&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=num;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=l[j];k&lt;=r[j];++k)</span><br><span class="line">                <span class="keyword">if</span> (!((++cnt[w[k]])&amp;<span class="number">1</span>))++res;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cnt[w[k]]!=<span class="number">1</span>)--res;</span><br><span class="line">            f[i][j]=res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=num;++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=l[j];k&lt;=r[j];++k)--cnt[w[k]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        ++cnt[w[i]];</span><br><span class="line">        <span class="keyword">if</span> (i==r[belong[i]])</span><br><span class="line">            <span class="built_in">memcpy</span>(sum[belong[i]],cnt,<span class="built_in">sizeof</span>(sum[belong[i]]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (l&lt;r)?(sum[r<span class="number">-1</span>][w]-sum[l][w]):<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=(x+ans)%n+<span class="number">1</span>,y=(y+ans)%n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="type">int</span> A=belong[x],B=belong[y],res=f[A+<span class="number">1</span>][B<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=x;i&lt;=<span class="built_in">min</span>(y,r[A]);++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!((++cnt[w[i]]+<span class="built_in">calc</span>(A,B,w[i]))&amp;<span class="number">1</span>))++res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt[w[i]]+<span class="built_in">calc</span>(A,B,w[i])!=<span class="number">1</span>)--res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A!=B)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=l[B];i&lt;=y;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!((++cnt[w[i]]+<span class="built_in">calc</span>(A,B,w[i]))&amp;<span class="number">1</span>))++res;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt[w[i]]+<span class="built_in">calc</span>(A,B,w[i])!=<span class="number">1</span>)--res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=l[B];i&lt;=y;++i)--cnt[w[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=x;i&lt;=<span class="built_in">min</span>(y,r[A]);++i)--cnt[w[i]];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),c=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans=<span class="built_in">query</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4159 【[SCOI2009]迷路】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P4159%20%E3%80%90%5BSCOI2009%5D%E8%BF%B7%E8%B7%AF%E3%80%91/</url>
    <content><![CDATA[<p>该有向图有 $n$ 个节点，节点从 $1$ 至 $n$ 编号，windy 从节点 $1$ 出发，他必须恰好在 $t$ 时刻到达节点 $n$。</p>
<p>现在给出该有向图，你能告诉 windy 总共有多少种不同的路径吗？ </p>
<p>答案对 $2009$ 取模。</p>
<p>注意：windy 不能在某个节点逗留，且通过某有向边的时间严格为给定的时间。</p>
<p>$2 \leq n \leq 10$，$1 \leq t \leq 10^9$。</p>
<span id="more"></span>

<p>首先考虑边权只有$0,1$的情况。这时候只需要$Floyd$矩阵进行矩阵乘法即可，但是这道题的边权并不是$0,1$，那么我们能不能让$Floyd$矩阵中的每个单位存大于$1$的边权，然后矩乘呢？</p>
<h1 id="不能"><a href="#不能" class="headerlink" title="不能"></a>不能</h1><p>也就是说在$Floyd$矩阵中每个单位的值只能是$0$或$1$，但是我们发现$2 &lt;&#x3D; N &lt;&#x3D; 10$，这意味着我们可以乱搞将每个点都拆开，将这张图转化成边权只有$0,1$的图，这样上面的意义就成立了。</p>
<p>我们发现可以将每个点拆成$9$个点，令有序数对$(i,j)$表示点$i$拆成的第$j$个点，其中第$0$个点是“真”点，其余的是“假”点。</p>
<p>我们可以令 $(i,j)$表示到“真”点$(i,0)$的距离为j的“假”点，只要让$(i,j)$向$(i,j-1)$连一条边权为$1$的边。</p>
<p>而对于原图中的一条$u→v $边权为$w$的边，只要让$(u,0)$向$(v,w−1)$连一条边权为$1$的边。</p>
<p>这样我们就还原了原图中的边，并且将边权都转化成了$0,1$。</p>
<p>而每个$(i,j)$又可以唯一对应一个编号$(i-1)<em>9+j$，因此原矩阵就变成了一个 $9n</em>9n$的矩阵$ f$.</p>
<p>答案就是$f[0][n-9]$即点$1$的真点与点$n$的真点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 2009</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> s[<span class="number">400</span>][<span class="number">400</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">400</span>][<span class="number">400</span>],now[<span class="number">400</span>][<span class="number">400</span>],t[<span class="number">400</span>][<span class="number">400</span>],ans[<span class="number">400</span>][<span class="number">400</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (s[i][j]!=<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                now[(i<span class="number">-1</span>)*<span class="number">9</span>][(j<span class="number">-1</span>)*<span class="number">9</span>+s[i][j]-<span class="string">&#x27;0&#x27;</span><span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;++j)&#123;</span><br><span class="line">            now[(i<span class="number">-1</span>)*<span class="number">9</span>+j][(i<span class="number">-1</span>)*<span class="number">9</span>+j<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> ttt=m;n*=<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)ans[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ttt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ttt&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="built_in">sizeof</span>(t));</span><br><span class="line">            <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">                <span class="keyword">for</span> (re <span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">                    <span class="keyword">for</span> (re <span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;++k)</span><br><span class="line">                        t[i][j]=(t[i][j]+now[i][k]*ans[k][j])%mod;</span><br><span class="line">            <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">                <span class="keyword">for</span> (re <span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">                    ans[i][j]=t[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        ttt&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="built_in">sizeof</span>(t));</span><br><span class="line">        <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span> (re <span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">for</span> (re <span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;++k)</span><br><span class="line">                    t[i][j]=(t[i][j]+now[i][k]*now[k][j])%mod;</span><br><span class="line">        <span class="keyword">for</span> (re <span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span> (re <span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">                now[i][j]=t[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[<span class="number">0</span>][n<span class="number">-9</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4870 【[BalticOI 20A09 Day1]甲虫】</title>
    <url>/2019/04/29/%E9%A2%98%E8%A7%A3%20P4870%20%E3%80%90%5BBalticOI%202009%20Day1%5D%E7%94%B2%E8%99%AB%E3%80%91/</url>
    <content><![CDATA[<p>题意:有一只甲虫处于一根水平的树枝。因为他沉迷数学无法自拔，所以他觉得很像是在 $x$ 轴上。</p>
<p>在同一根树枝上，还有 $n$ 滴露水。每滴露水占用 $m$ 个单位的水分。相对于甲虫的位置，他们的坐标分别是 $x_1,x_2,\dots,x_n$。</p>
<p>显然，这一天将会骄阳似火。每过一个时间单位，就会有一个单位的水分从每一滴露水流失。这只甲虫受尽了烈阳的折磨，以至于每当它碰到一滴露水都能瞬间喝完。在每个时间单位中它能移动一个单位的距离。</p>
<p>所以你要写一个程序，根据露水的坐标，计算出甲虫<strong>最多</strong>能喝到的水。</p>
<p>$0 \le n \le 300,1 \le m \le 1,000,000,-10,000 \le x_1,x_2,\dots,x_n \le 10,000,$ 对于所有 $i \ne j,x_i \ne x_j$。</p>
<span id="more"></span>

<p>这道题应该一眼就能看出是区间$DP$，但是关键在于怎么写,我们用$f[i][j][0&#x2F;1]$表示取完$i$~$j$之间的露水，停在$i$或$j$<strong>浪费的水分</strong>,因为露水水分不可能为负数，而走到后来可能行走路程$&gt;m$，使得计算出的水分为负，所以我们要枚举取的总的露水数$p$（注意不是水分数）<br>于是我们可以列出状态转移方程：</p>
<p>$f[i][j][0]&#x3D;min(f[i+1][j][0]+(p-len+1)\times(a[i+1]-a[i]),f[i+1][j][1]+(p-len+1)\times(a[j]-a[i]));$ </p>
<p>$f[i][j][1]&#x3D;min(f[i][j-1][1]+(p-len+1)\times(a[j]-a[j-1]),f[i][j-1][0]+(p-len+1)\times(a[j]-a[i]));$</p>
<p>$len$为$j-i+1$，即当前采集的露水数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">4000</span>],f[<span class="number">400</span>][<span class="number">400</span>][<span class="number">2</span>],t[<span class="number">400</span>][<span class="number">400</span>][<span class="number">2</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;water.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;water.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">    a[++n]=<span class="number">0</span>;<span class="comment">//由于从0出发，故添加一个点为0</span></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);<span class="comment">//排序应该不难理解</span></span><br><span class="line">    <span class="type">int</span> z=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,<span class="number">0</span>)-a;<span class="comment">//找出排序后0在的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p=<span class="number">1</span>;p&lt;=n;p++)&#123;<span class="comment">//枚举p</span></span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[z][z][<span class="number">0</span>]=<span class="number">0</span>;f[z][z][<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len=<span class="number">2</span>;len&lt;=p;len++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-len+<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">                f[i][j][<span class="number">0</span>]=<span class="built_in">min</span>(f[i+<span class="number">1</span>][j][<span class="number">0</span>]+(p-len+<span class="number">1</span>)*(a[i+<span class="number">1</span>]-a[i]),f[i+<span class="number">1</span>][j][<span class="number">1</span>]+(p-len+<span class="number">1</span>)*(a[j]-a[i])); </span><br><span class="line">                f[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(f[i][j<span class="number">-1</span>][<span class="number">1</span>]+(p-len+<span class="number">1</span>)*(a[j]-a[j<span class="number">-1</span>]),f[i][j<span class="number">-1</span>][<span class="number">0</span>]+(p-len+<span class="number">1</span>)*(a[j]-a[i]));<span class="comment">//状态转移方程</span></span><br><span class="line">                ans=<span class="built_in">max</span>(ans,(len<span class="number">-1</span>)*m-<span class="built_in">min</span>(f[i][j][<span class="number">1</span>],f[i][j][<span class="number">0</span>]));统计答案</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>区间$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4683 【[IOI2008] Type Printer 打印机】</title>
    <url>/2019/05/12/%E9%A2%98%E8%A7%A3%20P4683%20%E3%80%90%5BIOI2008%5D%20Type%20Printer%20%E6%89%93%E5%8D%B0%E6%9C%BA%E3%80%91/</url>
    <content><![CDATA[<p>给出这么多字符串，显然就是要你建出字典树</p>
<p>在建完字典树后，我们手动模拟一下，发现树上兄弟的遍历先后其实是没有关系的(只所有兄弟是连着一起遍历的就行了)(即$dfs$序)， 唯一不同的就是最后遍历的一个单词不用删，所以我们考虑让最长的单词最后遍历，于是考虑在最长单词的所有字母上加上标记，最后走。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>],tot,book[N],w[N],ans,n;</span><br><span class="line"><span class="type">char</span> s[N][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="type">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ch[now][v])ch[now][v]=++tot;</span><br><span class="line">        now=ch[now][v];</span><br><span class="line">    &#125;</span><br><span class="line">    w[now]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">strlen</span>(s),now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="type">int</span> v=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        now=ch[now][v];</span><br><span class="line">        book[now]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w[now])&#123;++ans;<span class="keyword">if</span> (flag)<span class="built_in">puts</span>(<span class="string">&quot;P&quot;</span>);&#125;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">        <span class="keyword">if</span> (ch[now][i])</span><br><span class="line">            <span class="keyword">if</span> (!book[ch[now][i]])&#123;</span><br><span class="line">                ++ans;<span class="keyword">if</span> (flag)<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,i+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                <span class="built_in">query</span>(ch[now][i],flag);</span><br><span class="line">                ++ans;<span class="keyword">if</span> (flag)<span class="built_in">puts</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> t=i;</span><br><span class="line">    <span class="keyword">if</span> (t!=<span class="number">-1</span>)&#123;</span><br><span class="line">        ++ans;</span><br><span class="line">        <span class="keyword">if</span> (flag)<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,t+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="built_in">query</span>(ch[now][t],flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();<span class="type">int</span> mx=<span class="number">0</span>,num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]);</span><br><span class="line">        <span class="built_in">build</span>(s[i]);<span class="type">int</span> len=<span class="built_in">strlen</span>(s[i]);</span><br><span class="line">        <span class="keyword">if</span> (len&gt;mx)&#123;mx=len;num=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">work</span>(s[num]);</span><br><span class="line">    <span class="built_in">query</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">query</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>$Trie$树</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4015 【运输问题】</title>
    <url>/2019/06/01/%E9%A2%98%E8%A7%A3%20P4015%20%E3%80%90%E8%BF%90%E8%BE%93%E9%97%AE%E9%A2%98%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>$n$个仓库$m$个商店.$i$仓库有$a_i$单位货物，$i$商店需要$b_i$单位货物。$i$仓库到$j$商店的运费是$c_{i,j} &#x2F;\text{单位}$。问最小运输费用和最大运输费用。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>费用流水题</p>
<p>对于每个仓库$i$,每个商店$j$</p>
<p>$s \stackrel{a_{i}, 0}{\longrightarrow}i$</p>
<p>$i \stackrel{inf, c_{i,j}}{\longrightarrow}i$</p>
<p>$j \stackrel{b_{i}, 0}{\longrightarrow}t$</p>
<p>分别跑最小费用最大流和最大费用最大流即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,w,to,next;</span><br><span class="line">&#125;e[<span class="number">1000067</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,head[N],dis[N],vis[N],inque[N],cost,n,m,s,t,a[N],b[N],c[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].w=-w;</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)dis[i]=-inf;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&lt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=-inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> ((!vis[v]||v==t)&amp;&amp;e[i].dis&amp;&amp;dis[v]==dis[u]+e[i].w)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                cost+=mi*e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (used==mn)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dinic1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa1</span>())&#123;</span><br><span class="line">        vis[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (vis[t])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="built_in">dfs</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dinic2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa2</span>())&#123;</span><br><span class="line">        vis[t]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (vis[t])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">            <span class="built_in">dfs</span>(s,inf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),s=<span class="number">0</span>,t=n+m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=<span class="built_in">read</span>(),<span class="built_in">add</span>(s,i,a[i],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)b[i]=<span class="built_in">read</span>(),<span class="built_in">add</span>(i+n,t,b[i],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">            c[i][j]=<span class="built_in">read</span>(),<span class="built_in">add</span>(i,j+n,inf,c[i][j]);</span><br><span class="line">    <span class="built_in">Dinic1</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost);</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">1</span>;cost=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(s,i,a[i],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)<span class="built_in">add</span>(i+n,t,b[i],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">            <span class="built_in">add</span>(i,j+n,inf,c[i][j]);</span><br><span class="line">    <span class="built_in">Dinic2</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>费用流</tag>
        <tag>网络流$24$题</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 SP4063 【MPIGS - Sell Pigs】</title>
    <url>/2019/05/30/%E9%A2%98%E8%A7%A3%20SP4063%20%E3%80%90MPIGS%20-%20Sell%20Pigs%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>$Mirko$在一个养猪场工作，养猪场有$M$个关着的猪圈，$Mirko$不能打开任何猪圈，因为他没钥匙。顾客一个接一个(顺序不能改变)地来到养猪场，他们各拥有一些猪圈的钥匙，想买若干猪。Mirko早就知道关于那天来农场的顾客的所有数据，他可以制定一个销售计划，以便尽可能增加出售的猪的数量。更明确地，整个过程如下：顾客来了，顾客用手里的钥匙打开猪圈了，$Mirko$把他要的猪(从当前打开着的猪圈中选出需要数量)卖给他，并且重排（当前开着的猪圈中的）剩余的猪，</p>
<p>注意，猪圈的容量无穷大。请尽可能最大化他能卖出的猪的数量,顾客来的顺序不可改变，顾客来后、调整完后猪圈门会关闭。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>在某个拥有$k$的钥匙的顾客$a$买过猪后，</p>
<p>在之后买猪的某个同样拥有钥匙$k$的顾客$b$也能买到$a$能买到的猪(因为$a$买剩下的猪可以在$a$买后调整到$k$中)。</p>
<p>所以，从$a$向$b$连边即可，流量为$inf$。</p>
<p>并且，如果$a$是第一个打开$k$的人，就将$a$和源点$s$连边，流量为$k$的初始猪的数量。</p>
<p>最后，将汇点$t$与每个顾客连边，流量为顾客最多能买的猪</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> dis,to,next;</span><br><span class="line">&#125;e[<span class="number">100055</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,head[N],dep[N],inque[N],cur[N],n,m,s,t,w[N],la[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;!dep[v])&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (e[i].dis&amp;&amp;dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                <span class="keyword">if</span> (used==mn)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">        res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),s=<span class="number">0</span>,t=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)w[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;++j)&#123;</span><br><span class="line">            <span class="type">int</span> d=<span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (!la[d])<span class="built_in">add</span>(s,i,w[d]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">add</span>(la[d],i,inf);</span><br><span class="line">            la[d]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> w=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(i,t,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Dinic</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 SRM 563 Div1 500 SpellCards</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20SRM%20563%20Div1%20500%20SpellCards/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有$n$张符卡排成一个队列，每张符卡有两个属性，等级$l_{i}$和伤害$d_{i}$。<br>你可以做任意次操作，每次操作为以下二者之一：</p>
<p>$1$. 把队首的符卡移动到队尾。</p>
<p>$2$. 使用队首的符卡，对敌人造成$d_{i}$点伤害，并丢弃队首的$l_{i}$张符卡（包括你所使用的符卡）。如果队列不足$l_{i}$张符卡那么你不能使用。</p>
<p>求出造成的伤害的总和的最大值。</p>
<p>$1$$\leqslant$$n$$\leqslant$$50,1$$\leqslant$$l_{i}$$\leqslant$$50,1$$\leqslant$$d_{i}$$\leqslant$$10000$</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution:$"></a>$Solution:$</h2><p>我们可以把原问题简化成在环上操作，这样第一个操作就被简化掉了</p>
<p>设我们选的集合的点的$l_{i}$为$L_{i}$，注意这里集合内的所有的$L_{i}$是可重的，也就是可以覆盖下一个点，例如下图是合法的。</p>
<p><a href="https://i.loli.net/2019/04/20/5cbb06150ea5d.png"></a></p>
<p>显然我们只需要满足$\sum L_{i}\leqslant$$n$就行了</p>
<p>我们发现一定有一个点没有覆盖下一个点，证明：如果每个点都覆盖了下一个点，那么整个环一定被完全覆盖了，再加上重叠的部分，$\sum L_{i}$不会$\leqslant$$n$，所有一定有一个点没有覆盖下一个点</p>
<p>那么，我们就可以直接用掉这个点$L_{i}$包含的区间，此时$n-&#x3D;L_{i}$,剩下的$\sum L_{i}$依然满足$\leqslant$$n$，这个点的上一个点就变成了没有覆盖下一个点的点了，就可以一直删，直到删完。</p>
<p>然后我们发现就是一个裸的背包问题</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code:$"></a>$Code:$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">60</span>],l[<span class="number">60</span>],d[<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)l[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)d[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-l[i]]+d[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P5400 【[CTS2019]随机立方体】</title>
    <url>/2019/06/12/%E9%A2%98%E8%A7%A3%20P5400%20%E3%80%90%5BCTS2019%5D%E9%9A%8F%E6%9C%BA%E7%AB%8B%E6%96%B9%E4%BD%93%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有一个$n\times m\times l$的立方体，立方体中每个格子上都有一个数，如果某个格子上的数比三维坐标至少有一维相同的其他格子上的数都要大的话，我们就称它是极大的。</p>
<p>现在将$1\sim n\times m\times l$这$n\times m\times l$个数等概率随机填入$n\times m\times l$个格子（即任意数字出现在任意格子上的概率均相等），使得每个数恰出现一次，求恰有$k$个极大的数的概率。答案对$998244353$取模。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>考虑容斥</p>
<p>以下把$n\times m\times l$的立方体中$1\times 1\times 1$的单位立方体称为’块‘</p>
<p>设$N&#x3D;n\times m\times l$</p>
<p>设$f_{i}$表示至少有$i$个极大的数的方案数</p>
<p>$b_{i}<del>$表示选出$i</del>$个三维坐标都不相同的点的方案数。($i~$个极大的数)</p>
<p>$g_{i}<del>$表示和$i</del>$个极大的数中任意一个至少有一维坐标相同的点的个数。</p>
<p>$h_{i}<del>$表示将$g_{i}</del>$个数字分配给$g_{i}$的个点的合法分配的方案数。(合法指的是$i~$个极大的数可以同时存在)</p>
<p>$f_{i}&#x3D;C_{N}^{g_{i}} \times b_{i} \times h_{i} \times(N-g_{i}) !$</p>
<p>我们先来考虑$b_{i}~:$</p>
<p>如果在$(a,b,c)$钦定了一个极大数，那么$x&#x3D;a,y&#x3D;b,z&#x3D;c$三个平面都不能填极大数了，即原问题变成了一个$(n-1)\times(m-1)\times(l-1)$</p>
<p>所以$:$</p>
<p>$b_{i}&#x3D;\dfrac{1}{i!}~\prod\limits_{j&#x3D;0}^{i-1}(n-j) \times(m-j) \times(l-j)$</p>
<p>考虑$g_{i}:$</p>
<p>显然$:g_{i}&#x3D;N-(n-i) \times(m-i) \times(l-i)($所有块减去所有三维坐标与$i$个极大的数完全不相同的块的个数$)$</p>
<p>考虑$h_{i}$怎么算：</p>
<p>可以发现，这个东西一下子求不来，可以考虑一下递推的方法。</p>
<p>我们先把$g_{i}$个数中最大的数值(这个最大的数值一定是极大数)拿出来，填到对应位置，然后剩下的$g_{i}-g_{i-1}-1$个位置(即这个数值会影响到的所有的块，$g_{i-1}$即不会影响到的块,$-1$即减去自身)，每个位置可以随便选择一个数，方案数为$(g_{i}-g_{i-1}-1)!&#x3D;\frac{(g_{i}-1)!}{g_{i-1}!}$，然后我们可以发现，剩下的数的填充就是子问题$h_{i-1}$</p>
<p>$h_{i}&#x3D;\frac{\left(g_{i}-1\right) !}{g_{i-1} !} \times h_{i-1}$ </p>
<p>$\quad,&#x3D;\prod_{j&#x3D;0}^{i-1} \frac{\left(g_{j+1}-1\right) !}{g_{j} !} $</p>
<p>注意$:$这个式子是不考虑大小顺序的，所以最后所有的$h_{i}$都要乘上$i!$(注意$:$不能在算的时候乘，会影响后面$h_{i}~$的计算的)</p>
<p>将所有的东西带回去</p>
<p>$f_{i}~&#x3D;C_{N}^{g_{i}} \times b_{i} \times h_{i} \times(N-g_{i})!$</p>
<p>$\quad,,&#x3D;\frac{N!}{(N-g_{i}) ! g_{i} !} \times b_{i} \times i!\times \prod_{j&#x3D;1}^{i} \frac{(g_{j}-1)!}{g_{j-1} !} \times(N-g_{i}) !$</p>
<p>我们发现最后算概率的时候要乘上$\frac{1}{N!}$</p>
<p>$f_{i}~&#x3D;\frac{i!}{g_{i}!} \times b_{i} \times \prod_{j&#x3D;1}^{i} \frac{(g_{j}-1) !}{g_{j-1}!}$</p>
<p>$\quad,,&#x3D;i! \times b_{i}\times \prod_{j&#x3D;1}^{i} \frac{(g_{j}-1) !}{g_{j}!}$</p>
<p>$\quad,,&#x3D;i! \times b_{i} \prod_{j&#x3D;1}^{i} \frac{1}{g_{j}}$</p>
<p>由于</p>
<p>$f_{i}&#x3D;\sum\limits_{j&#x3D;i}^{min (n, m, l)} ans_{j}C_{j}^{i}$</p>
<p>最后二项式反演一下有：</p>
<p>$ans_{i}&#x3D;\sum\limits_{i&#x3D;k}^{\min (n, m, l)}\times (-1)^{i-k}\times C_{i}^{k}\times f_{i}$<br>但这样只能得到$80$分 ，我们预处理出来$g_{i}$的前缀积，求最后一项的逆元后可以逆推每一个前缀积的逆元，如当前$1\sim i$的前缀积的逆元为$inv$,那么想得到$1\sim (i-1)$的前缀积，只需将$inv\times i$即可</p>
<hr>
<p>以下内容为二项式反演证明$:$</p>
<p>$g_{i}&#x3D;\sum\limits_{j&#x3D;1}^{i}C_i^j f_{j}$</p>
<p>$f_{i}&#x3D;\sum\limits_{j&#x3D;1}^{i}(-1)^{i-j}~ C_{i}^{j}~g_{j}$</p>
<p>证明等式成立相当于证明对于等式右边而言，所有$f_{k}$的系数为$[i&#x3D;&#x3D;k]$</p>
<p>则$f_{k}$的系数为$\sum\limits_{j&#x3D;k}^{i}(-1)^{i-j}<del>C_{i}^{j}</del>C_{j}^{k}$</p>
<p>化简:</p>
<p>$\sum\limits_{j&#x3D;k}^{i}(-1)^{i-j} \frac{i !}{j !(i-j) !} \frac{j !}{k !(j-k) !}$</p>
<p>消去$j!$,提出$\frac{i !}{k !}$</p>
<p>$\left(\sum\limits_{j&#x3D;k}^{i}(-1)^{i-j} \frac{1}{(i-j) !(j-k) !}\right) \frac{i !}{k !}$</p>
<p>乘$(i-k)!$，除$(i-k)!$</p>
<p>$\left(\sum\limits_{j&#x3D;k}^{i}(-1)^{i-j} \frac{(i-k) !}{(i-j) !(j-k) !}\right) \frac{i !}{k !(i-k) !}$</p>
<p>$\left(\sum_{j&#x3D;k}^{i}(-1)^{i-j}~C_{i-k}^{j-k}\right)C_{i}^{k}.$</p>
<p>$\sum\limits_{j&#x3D;k}^{i}(-1)^{i-j}~C_{i-k}^{j-k}&#x3D;[i&#x3D;&#x3D;k]$</p>
<p>如果成立,则$:$当$i&#x3D;&#x3D;k$时，$C_{i}^{k}&#x3D;&#x3D;1$,所以系数为$1$,当$i!&#x3D;k$时，前一个式子为$0$，所以系数为$0$</p>
<p>证明$:$当$i!&#x3D;k$时，前一个式子为$0$</p>
<p>当$i-k$为奇数时，相当于有$i−k+1$个数相加(分别对应取$0$个，取$1$个…取$i - k$个)，一共偶数个，其中第一项与最后一项异号，第二项与倒数第二项异号。。。根据组合数的对称性，和为$0$。</p>
<p>当$i-k$为偶数时，相当于证$:$</p>
<p>$C_{i}^{0}-C_{i}^{1}+C_{i}^{2}-\cdots -C_{i}^{i-1}+C_{i}^{i}&#x3D;0$</p>
<p>用杨辉三角证明(好像二项式定理也可以证)</p>
<p>原式$&#x3D;C_{i-1}^{0}-(C_{i-1}^{0}+C_{i-1}^{1})+(C_{i-1}^{1}+C_{i-1}^{2})-\cdots-(C_{i-1}^{i-2}+C_{i-1}^{i-1})+C_{i-1}^{i-1}$</p>
<p>发现最后全抵消掉了，所有原式$&#x3D;0$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5000070</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p&amp;<span class="number">1</span>)res=res*x%mod;</span><br><span class="line">        x=x*x%mod;p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> jc[N],invc[N],inv[N],g[N],f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jc[m]*invc[n]%mod*invc[m-n]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-70</span>;++i)jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    invc[N<span class="number">-70</span>]=<span class="built_in">ksm</span>(jc[N<span class="number">-70</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=N<span class="number">-71</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        invc[i]=invc[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),l=<span class="built_in">read</span>(),k=<span class="built_in">read</span>(),ans=<span class="number">0</span>,v=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> t=<span class="built_in">min</span>(n,<span class="built_in">min</span>(m,l));</span><br><span class="line">        <span class="keyword">if</span> (k&gt;t)&#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;++i)&#123;</span><br><span class="line">            g[i]=(n*m%mod*l%mod-(n-i)*(m-i)%mod*(l-i)%mod+mod)%mod;</span><br><span class="line">            v=v*g[i]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        inv[t]=<span class="built_in">ksm</span>(v,mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=t<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            inv[i]=inv[i+<span class="number">1</span>]*g[i+<span class="number">1</span>]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        v=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;++i)&#123;</span><br><span class="line">            v=v*(n-i)%mod*(m-i)%mod*(l-i)%mod;</span><br><span class="line">            f[i+<span class="number">1</span>]=v*inv[i+<span class="number">1</span>]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=k;i&lt;=t;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((i-k)&amp;<span class="number">1</span>)</span><br><span class="line">                ans=(ans-<span class="built_in">C</span>(i,k)*f[i]%mod+mod)%mod;</span><br><span class="line">            <span class="keyword">else</span> ans=(ans+<span class="built_in">C</span>(i,k)*f[i]%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>容斥</tag>
        <tag>组合数</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 UVA12125 【March of the Penguins】</title>
    <url>/2019/06/02/%E9%A2%98%E8%A7%A3%20UVA12125%20%E3%80%90March%20of%20the%20Penguins%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给定一些冰块，每个冰块上有一些企鹅，每个冰块有一个可以从当前冰块跳出的次数限制，每个冰块位于一个坐标，现在每个企鹅跳跃力为$d$，问所有企鹅能否跳到一点上，如果可以输出所有落脚冰块，如果没有方案就打印$-1$</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>对于每个点$i$进行拆点,分成$i_1<del>$和$i_2</del>$，中间连一条容量为能跳出次数的边，从源点$s$连向$i_1<del>$，流量为每个点的企鹅数，然后$n^2$枚举点，如果两个点$i,j$距离$\leqslant d$，那么分别从$i_1</del>$连向$j_2<del>,j_1</del>$连向$i_2~$,容量为$inf$，接着枚举汇点$t$(因为每个点都可能成为企鹅的集合点)，将$t_1$作为汇点,接着跑最大流，看看是否满流，如果满流了就记录答案，最后判断一下是否有答案，没有答案输出$-1$即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 40000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,dis,w,next;</span><br><span class="line">&#125;e[<span class="number">1007000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,head[N],dep[N],n,inque[N],vis[N],x[N],y[N],a[N],b[N],cur[N],cost,w[N],s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;!dep[v])&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (dep[v]==dep[u]+<span class="number">1</span>&amp;&amp;e[i].dis)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                <span class="keyword">if</span> (used==mn)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>*n;++i)cur[i]=head[i];</span><br><span class="line">        res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> res=<span class="built_in">sqrt</span>(<span class="number">1.0</span>*((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])));</span><br><span class="line">    <span class="keyword">if</span> (res-d&lt;<span class="number">1e-6</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">add</span>(s,i,a[i]),<span class="built_in">add</span>(i,i+n,b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            <span class="keyword">if</span> (i!=j&amp;&amp;<span class="built_in">check</span>(i,j))</span><br><span class="line">                <span class="built_in">add</span>(j+n,i,inf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">1</span>;<span class="type">int</span> tot=<span class="number">0</span>,mx=<span class="number">0</span>;</span><br><span class="line">        n=<span class="built_in">read</span>();<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;d);</span><br><span class="line">        s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            x[i]=<span class="built_in">read</span>(),y[i]=<span class="built_in">read</span>(),a[i]=<span class="built_in">read</span>(),b[i]=<span class="built_in">read</span>(),mx+=a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            t=i;</span><br><span class="line">            <span class="built_in">link</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Dinic</span>()==mx)&#123;</span><br><span class="line">                ++tot;</span><br><span class="line">                <span class="keyword">if</span> (tot==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,i<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tot)<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>拆点</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 SP4318 【MFISH - Catch Fish】</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20SP4318%20%E3%80%90MFISH%20-%20Catch%20Fish%E3%80%91/</url>
    <content><![CDATA[<p>题目大意:一条河分为$n$个段，每个段都有一个给定的鱼的数量$A_i$，现有$m$条船，每条船都有两个值$B_i$与$D_i$,$B_i$表示船必须在$B_i$处落锚，这意味着船必须占据$B_i$这个位置。且船的长度为$D_i$.数据保证$m$条船一定都可以放在河上。(也就是说我们选择时一定每条船都选，因为每条船都放显然是最优的)。求最大捕鱼数。</p>
<span id="more"></span>

<p>这道题给人一种贪心的错觉，实际上它是一个$DP$，首先对于每条船求出它左端点能放的最左边和最右边，这个结合代码应该很好理解</p>
<p>接下来就是$DP$了，$f_{j}$表示之前放的所有点的最右端为$j$的最大收益。显然我们可以发现每个$j$<strong>唯一</strong>对应着一条船，所以我们可以枚举每条船。</p>
<p>$f_{j+d_{i}-1}&#x3D;max(f_{j+d_{i}-2},f_{j-1}+(sum_{a_{j+d_{i}-1}}-sum_{a_{j}}));$</p>
<p>在代码实现上还有一些细节需要处理，具体详见代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,l,r;</span><br><span class="line">&#125;b[<span class="number">393939</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ggg[<span class="number">10001</span>];<span class="type">int</span> s=<span class="number">0</span>;<span class="type">int</span> tmp=x;</span><br><span class="line">    <span class="keyword">if</span>(tmp==<span class="number">0</span>)&#123;<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);<span class="keyword">return</span>;&#125;<span class="keyword">if</span>(tmp&lt;<span class="number">0</span>)&#123;tmp=-tmp;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);&#125;</span><br><span class="line">    <span class="keyword">while</span>(tmp&gt;<span class="number">0</span>)&#123;ggg[s++]=tmp%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>;tmp/=<span class="number">10</span>;&#125;<span class="keyword">while</span>(s&gt;<span class="number">0</span>)&#123;<span class="built_in">putchar</span>(ggg[--s]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">393939</span>],f[<span class="number">393939</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+<span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        b[i].x=<span class="built_in">read</span>(),b[i].y=<span class="built_in">read</span>(); </span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+m,cmp);</span><br><span class="line">    b[<span class="number">0</span>].l=<span class="number">1</span>;b[m+<span class="number">1</span>].x=inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)b[i].l=<span class="built_in">max</span>(b[i].x-b[i].y+<span class="number">1</span>,b[i<span class="number">-1</span>].l+b[i<span class="number">-1</span>].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)b[i].r=<span class="built_in">min</span>(b[i+<span class="number">1</span>].x-b[i].y,b[i].x);</span><br><span class="line">    b[m+<span class="number">1</span>].r=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=b[i].l;j&lt;=b[i].r;++j)</span><br><span class="line">            f[j+b[i].y<span class="number">-1</span>]=<span class="built_in">max</span>(f[j+b[i].y<span class="number">-1</span>],f[j<span class="number">-1</span>]+a[j+b[i].y<span class="number">-1</span>]-a[j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=b[i].l+b[i].y<span class="number">-1</span>;j&lt;b[i+<span class="number">1</span>].r;++j)f[j]=<span class="built_in">max</span>(f[j],f[j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P5022 旅行</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20P5022%20%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5022">P5022 [NOIP2018 提高组] 旅行</a></p>
<span id="more"></span>

<p>题意：前$60$分图是一棵树，直接暴力$dfs$枚举边，暴力判断,$O(n)$。后$40$分是一颗基环树，暴力删边,再按照前$60$分的方法暴力$dfs$，$O(n^2)$。</p>
<p>但是这样会$T$飞，所以我们要优化</p>
<p>优化$1:$我们发现我们每条边都删一遍完全没必要，只需对那个环上的所有边进行删除操作，用并查集判环即可</p>
<p>优化$2:$我们发现要求字典序最小，所以我们$dfs$时可以进行最优性剪枝，如果前面的编号与当前答案都相同(注意，这个前提很重要)，当前这条边的编号大于答案那么就可以$return$了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wln</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> qqq,ttt,n,m,vis[<span class="number">300000</span>],ans[<span class="number">300000</span>],tot,mp[<span class="number">300000</span>][<span class="number">2</span>],tx,ty,p[<span class="number">300000</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;q[<span class="number">30000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;ans[++tot]=u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;q[u].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="type">int</span> v=q[u][i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfss</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (ttt)<span class="keyword">return</span>;</span><br><span class="line">    vis[u]=<span class="number">1</span>;p[++tot]=u;</span><br><span class="line">    <span class="keyword">if</span> (p[tot]&gt;ans[tot]&amp;&amp;!qqq)&#123;ttt=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (p[tot]&lt;ans[tot])qqq=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;q[u].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="type">int</span> v=q[u][i];<span class="keyword">if</span> (ttt)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]||((u==tx&amp;&amp;v==ty)||(u==ty&amp;&amp;v==tx)))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfss</span>(v); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cmp_and_change</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tot!=n)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i]&lt;p[i])<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans[i]&gt;p[i])<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)ans[i]=p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">        q[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        q[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        mp[i][<span class="number">0</span>]=x;mp[i][<span class="number">1</span>]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">sort</span>(q[i].<span class="built_in">begin</span>(),q[i].<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (m==n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;++i)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));ttt=<span class="number">0</span>;qqq=<span class="number">0</span>;</span><br><span class="line">            tx=mp[i][<span class="number">0</span>],ty=mp[i][<span class="number">1</span>];tot=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfss</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">cmp_and_change</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">write</span>(ans[i]),<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>剪枝优化</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 UVA1486 【Transportation】</title>
    <url>/2019/06/02/%E9%A2%98%E8%A7%A3%20UVA1486%20%E3%80%90Transportation%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>某国有$n(n\leqslant 100)$座城市，由$m(m\leqslant 5000)$条单向道路相连。你希望从城市$1$运送$k(k\leqslant 100)$单位货物到城市$n$，这些道路并不安全，有很多强盗，所以你需要雇佣保镖来做护卫。每条道路都有一个危险系$a_i(a_i\leqslant 100),$如果你带着$x$个单位的货物通过，需要给保镖$a_i\times x^{2}$的佣金，保镖才会保证你的安全。每条道路都有一个限制，最多能运送$c_i(c_i\leqslant 5)$的货物。现在问，在能完成运送$x$个单位的货物到$n$号城市的情况下最小的花费，如果送不到，则输出$-1$。</p>
<span id="more"></span>


<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>很容易看出是费用流的做法，但是我们发现对于不同的流的大小,费用并不相同。由于题目给出$c_i\leqslant 5$,我们考虑拆边。</p>
<p>我们将每条边拆成$c_i$条边，分别标成$e_{i,1\sim c_{i,j}}$.</p>
<p>对于一条边$i$。</p>
<p>我们把$e_{i,1}$的费用设成$a_i\times 1&#x3D;a_i\times (1^2-0^2)$</p>
<p>把$e_{i,2}$的费用设成$a_i\times 3&#x3D;a_i\times (2^2-1^2)$</p>
<p>把$e_{i,3}$的费用设成$a_i\times 5&#x3D;a_i\times (3^2-2^2)$</p>
<p>把$e_{i,4}$的费用设成$a_i\times 7&#x3D;a_i\times (4^2-3^2)$</p>
<p>把$e_{i,5}$的费用设成$a_i\times 9&#x3D;a_i\times (5^2-4^2)$</p>
<p>我们开始模拟边$i$的每种流量对应的费用,设$w_i~$为边$i$的费用。</p>
<p>假设流量为$0$,费用显然$&#x3D;0$,符合题意</p>
<p>假设流量为$1$,费用显然$&#x3D;w_{e_{i,1}}$</p>
<p>$\qquad\qquad\qquad\qquad, &#x3D;a_{i}\times 1$</p>
<p>$\qquad\qquad\qquad\qquad, &#x3D;a_{i}\times 1^2$</p>
<p>假设流量为$2$,费用显然$&#x3D;w_{e_{i,1}}$$+w_{e_{i,2}}$</p>
<p>$\qquad\qquad\qquad\qquad, &#x3D;a_{i}\times 1+a_i\times 3$</p>
<p>$\qquad\qquad\qquad\qquad, &#x3D;a_{i}\times 2^2$</p>
<p>假设流量为$3$,费用显然$&#x3D;w_{e_{i,1}}+w_{e_{i,2}}+w_{e_{i,3}}$</p>
<p>$\qquad\qquad\qquad\qquad, &#x3D;a_{i}\times 1+a_i\times 3+a_i\times 5$</p>
<p>$\qquad\qquad\qquad\qquad, &#x3D;a_{i}\times 3^2$</p>
<p>假设流量为$4$,费用显然$&#x3D;w_{e_{i,1}}+w_{e_{i,2}}+w_{e_{i,3}}+w_{e_{i,4}}$</p>
<p>$\qquad\qquad\qquad\qquad, &#x3D;a_{i}\times 1+a_i\times 3+a_i\times 5+a_i\times 7$</p>
<p>$\qquad\qquad\qquad\qquad, &#x3D;a_{i}\times 4^2$</p>
<p>假设流量为$5$,费用显然$&#x3D;w_{e_{i,1}}+w_{e_{i,2}}+w_{e_{i,3}}+w_{e_{i,4}}+w_{e_{i,5}}$</p>
<p>$\qquad\qquad\qquad\qquad, &#x3D;a_{i}\times 1+a_i\times 3+a_i\times 5+a_i\times 7+a_i\times 9$</p>
<p>$\qquad\qquad\qquad\qquad, &#x3D;a_{i}\times 5^2$</p>
<p>这样拆边显然是对的。然后源点$s$连点$1$,容量为$k$,费用为$0$,点$n$连汇点$t$,容量为$k$,费用为$0$,其他边进行拆边，最后跑最小费用最大流即可。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 400000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,dis,w,next;</span><br><span class="line">&#125;e[<span class="number">1070000</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,head[N],flow[N],pre[N],pri[N],inque[N],dis[N],cost,n,m,k,s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].w=-w;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(flow,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(flow));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;dis[v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].w;</span><br><span class="line">                pre[v]=u;pri[v]=i;flow[v]=<span class="built_in">min</span>(flow[u],e[i].dis);</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])</span><br><span class="line">                    q.<span class="built_in">push</span>(v),inque[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]&lt;inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mcmf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        res+=flow[t];</span><br><span class="line">        cost+=flow[t]*dis[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> now=t;now!=s;now=pre[now])&#123;</span><br><span class="line">            e[pri[now]].dis-=flow[t];</span><br><span class="line">            e[pri[now]^<span class="number">1</span>].dis+=flow[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k)!=EOF)&#123;</span><br><span class="line">        s=<span class="number">0</span>,t=n+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">1</span>;cost=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            <span class="type">int</span> u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),a=<span class="built_in">read</span>(),c=<span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;++i)</span><br><span class="line">                <span class="built_in">add</span>(u,v,<span class="number">1</span>,a*d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(s,<span class="number">1</span>,k,<span class="number">0</span>);<span class="built_in">add</span>(n,t,k,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">mcmf</span>()==k?cost:<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>奇技淫巧</tag>
        <tag>费用流</tag>
        <tag>拆边</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 模拟赛</title>
    <url>/2019/09/22/%E9%A2%98%E8%A7%A3%20%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="T1"><a href="#T1" class="headerlink" title="$T1$"></a>$T1$</h2><p>对于$20%$的数据，状压暴力</p>
<p>对于$50%$的数据，网络流<del>,但是出题人没写过</del></p>
<p>对于$100%$的数据</p>
<p>转换成图论问题，对物质和变换规则建点，对于一种变换规则，需要$L$种物质，缺一不可，类似于拓扑排序的感觉，而在一种变换规则成立后，它又会带来$R$种物质，类似于$bfs$的感觉，所以不能只用$bfs$或拓扑排序，所以，只需要两个一起用就行了<del>极其无脑</del></p>
<h2 id="T2"><a href="#T2" class="headerlink" title="$T2$"></a>$T2$</h2><p>看到二叉搜索树，应该很容易想到对树进行中序遍历。这样问题就变成了对一个序列$A_i,$修改数量最少的元素，使得这个数列严格递增</p>
<p>对于$30%$的数据$,2^n$枚举那些点改变，然后贪心</p>
<p>对于$50%$的数据,给求最长不下降子序列只会$O(n^2)$的选手准备的，即正解中的求最长不下降子序列$O(nlogn)$改成$O(n^2)$.</p>
<p>对于$100%$的数据</p>
<p>一个比较$naive$的想法就是对这个序列求最长上升子序列$x,$然后$n-x$即是答案。</p>
<p>这显然是错误的</p>
<p>然后我们考虑一个奇技淫巧,将每个$A_i-$$&#x3D;i,$然后求最长<strong>不下降</strong>子序列</p>
<p>举个栗子$:2;; 9;;3;;9;;4;;8;;5,$按照上面的做法得出的最长上升子序列为$2<del>3</del>4<del>5$或$2</del>3<del>4</del>8$,得出的修改次数为$3,$但是显然答案为$5.$</p>
<p>而我们修改后的序列为$1;;7;;0;;5;;-1;;2;;-2$</p>
<p>这样修改后可以做到第$i$个位置最少要比第$i+1$个位置少$，1，$而$i$最少要比$i+2$的位置少$2$.</p>
<h2 id="T3"><a href="#T3" class="headerlink" title="$T3$"></a>$T3$</h2><p>对于$Subtask~1:$</p>
<p>$1.$枚举两个点，路径中一个个节点统计</p>
<p>$2.n^2$枚举两个点，然后用树剖判断判断是否可行</p>
<p>复杂度$O(n^2log^2n)$</p>
<p>对于$Subtask~2:$</p>
<p>将正解的扫描线改成暴力修改</p>
<p>复杂度$O(n^2)$</p>
<p>对于$Subtask~3:$</p>
<p>尺取法</p>
<p>复杂度$O(n)$</p>
<p>对于$Subtask~4:$</p>
<p>由于每种颜色最多只有$20$个节点。我们枚举一对颜色相同的节点，分别设为$x,y$.</p>
<p>对于$x,y$的情况分成两类$($下面默认$dep_x&lt;dep_y):$</p>
<p>$1.x$不是$y$的祖先</p>
<p>那么所有两端分别位于$x$的子树与$y$的子树中的路径都是不合法的。</p>
<p>$2.x$是$y$的祖先</p>
<p>那么不合法路径的一段位于$y$的子树,另一端位于$y$所在$x$的儿子的子树中。</p>
<p>如果用一个矩阵表示的话，枚举一对颜色相同的节点就相当于对一个矩形染色。</p>
<p>最后没有染色的就是合法路径，再根据题目限制去重一下即是最终答案。</p>
<p>矩阵求并用扫描线即可</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>出题人估计难度 $\color{limegreen}{绿}$,$\color{limegreen}{绿}$,$\color{blueViolet}{紫}$.</p>
<p>本次比赛难度类似$NOIPday1$,而且暴力分很足</p>
<p>但是由于没有送分题，所以平均分不会很高</p>
<p>对于$T1,$估计有$6 \sim 10$个人$A$掉，平均分大概在$35 \sim 60$之间,因为$20%$的数据很容易，网络流估计有$6$个左右的人写出来</p>
<p>对于$T2$，估计有$5 \sim 10$个人$A$掉，平均分大概在$30\sim 50 $之间,因为出题人觉得转成中序遍历应该有少部分人想不到，但是想到的话$30$分应该稳拿，即使想不到也还有链的情况可以写。</p>
<p>对于$T3$,估计有$2\sim 5$个人$A$掉,平均分大概在$30\sim 50$之间，因为$25%$的暴力很无脑，$15%$的链的情况也不难想，<del>并且原题挺有名的</del></p>
<p>$1.$赠送分$20+30+25&#x3D;75$</p>
<p>$2.$普通暴力神仙$50+30+25&#x3D;105$</p>
<p>$3.$高级暴力神仙$100+50+40&#x3D;190$</p>
<p>$4.$平均分$70+40+40-10($平均写萎分$)&#x3D;140.$</p>
<p>$5.AK$神仙$100+100+100&#x3D;300$</p>
<p>原题$:$</p>
<p>$T1:$<a href="https://www.luogu.org/problem/P4957">https://www.luogu.org/problem/P4957</a></p>
<p>$T2:$</p>
<p>现在给定一棵二叉树，可以任意修改结点的数值。修改一<br>个结点的数值算作一次修改，且这个结点不能再被修改。若要将其变成一棵二叉搜索树，且<br>任意时刻结点的数值必须是整数(可以是负整数或$0$)，所要的最少修改次数。</p>
<p>二叉搜索树首先是一棵二叉树。设$key[p]$表示结点$p$上的数值。<br>对于其中的每个结点$p$，若其存在左孩子$lch$，则$key[p]&gt;key[lch]$；若其存在右孩子$rch$，则$key[p]&lt;key[rch]$；注意，本题中的二叉搜索树应满足对于所有结点，其左子树中的$key$小于当前结点的$key$，其右子树中的$key$大于当前结点的$key$。</p>
<p>$T3:$<a href="https://loj.ac/problem/6276">https://loj.ac/problem/6276</a></p>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>拓扑排序</tag>
        <tag>$bfs$</tag>
        <tag>图论</tag>
        <tag>二叉搜索树</tag>
        <tag>最长上升子序列</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 UVA1345 【Jamie&#39;s Contact Groups】</title>
    <url>/2019/06/02/%E9%A2%98%E8%A7%A3%20UVA1345%20%E3%80%90Jamie&#39;s%20Contact%20Groups%E3%80%91/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>有$N$个人,$M$个分组，初始时每个人可能属于若干组，从每组中删除一些人，使每个人属于一组，且人数最多的组的人数最少</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>容易想到二分答案.设二分答案为$mid$,从源点$s$向$N$个人连边，容量为$1$，表示此人只能选择一组。对每个人，向他们可以属于的组连边，容量为$1$，由于流进来的流量为$1$，所以最后也只能从一条容量为$1$的边出去，即选择一个组,对每个组，向汇点$t$连边，容量为$mid$，这表示该组人数不能超过$mid$，因此，从该点流向汇点的流量即为该组人数。最后，判断最大流是否等于$N$，即判断是否每个人都有分组</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 400000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,dis,next;</span><br><span class="line">&#125;e[<span class="number">1070000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d[<span class="number">2000</span>][<span class="number">2000</span>],c[N],cur[N],cnt=<span class="number">1</span>,head[N],inque[N],dep[N],n,m,s,t;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].dis=d;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">    e[++cnt].to=u;</span><br><span class="line">    e[cnt].dis=<span class="number">0</span>;</span><br><span class="line">    e[cnt].next=head[v];</span><br><span class="line">    head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    dep[s]=<span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();inque[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].dis&amp;&amp;!dep[v])&#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inque[v])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);inque[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u==t)<span class="keyword">return</span> mn;</span><br><span class="line">    <span class="type">int</span> used=<span class="number">0</span>,mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i=cur[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (e[i].dis&amp;&amp;dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (mi=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(e[i].dis,mn-used)))&#123;</span><br><span class="line">                e[i].dis-=mi;</span><br><span class="line">                e[i^<span class="number">1</span>].dis+=mi;</span><br><span class="line">                used+=mi;</span><br><span class="line">                <span class="keyword">if</span> (used==mn)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=s;i&lt;=t;++i)cur[i]=head[i];</span><br><span class="line">        res+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">add</span>(s,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c[i];++j)</span><br><span class="line">            <span class="built_in">add</span>(i,<span class="number">1</span>+d[i][j]+n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)<span class="built_in">add</span>(j+n,t,mid);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Dinic</span>()==n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ss[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();s=<span class="number">0</span>,t=n+m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!n&amp;&amp;!m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">getchar</span>()!=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i][++c[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1200</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(mid))r=mid<span class="number">-1</span>,ans=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 loj2349「JOI 2018 Final」团子制作</title>
    <url>/2019/08/29/%E9%A2%98%E8%A7%A3%20loj2349%E3%80%8CJOI%202018%20Final%E3%80%8D%E5%9B%A2%E5%AD%90%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>你是一个制作团子的师傅，现在，你正想用竹签把团子串成一串。</p>
<p>团子被放置在长为$N$行，宽为$M$列的隔开的格子里，每个格子里都放着一个团子。每个团子的颜色是红、绿与白中的一种。</p>
<p>你可以选择三个<strong>从左到右</strong>，或者<strong>从上到下</strong>的连续的格子，把格子中的团子串成一串，按照这个顺序，一串团子串上正好会有三个团子。</p>
<p>现在，你希望尽可能多做些颜色按照红绿白顺序的团子串，并且团子在串上的顺序必须与从格子中取出的顺序相同。需要注意的是，同一个团子只能被串在一串团子串上。</p>
<p>你最多能制作多少串团子串呢？</p>
<p>给出放置在每个格子上的团子的颜色，你需要计算最多能制作的团子串的数量。团子串的颜色必须按照红、绿、白的顺序。</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution$"></a>$Solution$</h2><p>很有意思的$DP,$考虑团子串中间的$G$不在同一对角线的团子串不会互相影响，所以在对角线上进行$DP.$对于一条对角线，我们从左下向右上$DP,f_{i,0&#x2F;1}$表示当前对角线从左下到右上第$i$个团子可以与左右或上下的团子构成团子串$,0&#x2F;1$表示跟左右&#x2F;上下构成团子串。</p>
<p>$f_{i,j}$只能由$f_{k,t}(0\leqslant k&lt; i,t&#x3D;0&#x2F;1)$或$f_{i-1,j}$转移过来。</p>
<p>转移很好想，但是难想在考虑到不在同一对角线的团子串不会互相影响。</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3012</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N][N];</span><br><span class="line"><span class="type">int</span> n,m,f[N][<span class="number">2</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s[x<span class="number">-1</span>][y]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[x][y]==<span class="string">&#x27;G&#x27;</span>&amp;&amp;s[x+<span class="number">1</span>][y]==<span class="string">&#x27;W&#x27;</span>)&lt;&lt;<span class="number">1</span>|(s[x][y<span class="number">-1</span>]==<span class="string">&#x27;R&#x27;</span>&amp;&amp;s[x][y]==<span class="string">&#x27;G&#x27;</span>&amp;&amp;s[x][y+<span class="number">1</span>]==<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=n+m<span class="number">-1</span>;++i,j=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x=<span class="built_in">min</span>(i,n),y=<span class="built_in">max</span>(<span class="number">1</span>,i-n+<span class="number">1</span>);x&amp;&amp;y&lt;=m;--x,++y)&#123;</span><br><span class="line">            <span class="type">int</span> opt=<span class="built_in">calc</span>(x,y);++j;f[j][<span class="number">0</span>]=f[j][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            mx=<span class="built_in">max</span>(mx,<span class="built_in">max</span>(f[j<span class="number">-2</span>][<span class="number">0</span>],f[j<span class="number">-2</span>][<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span> (opt&amp;<span class="number">1</span>)f[j][<span class="number">0</span>]=<span class="built_in">max</span>(f[j<span class="number">-1</span>][<span class="number">0</span>],mx)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (opt&amp;<span class="number">2</span>)f[j][<span class="number">1</span>]=<span class="built_in">max</span>(f[j<span class="number">-1</span>][<span class="number">1</span>],mx)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=<span class="built_in">max</span>(mx,<span class="built_in">max</span>(<span class="built_in">max</span>(f[j<span class="number">-1</span>][<span class="number">0</span>],f[j][<span class="number">0</span>]),<span class="built_in">max</span>(f[j<span class="number">-1</span>][<span class="number">1</span>],f[j][<span class="number">1</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>$DP$</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 bzoj4668冷战</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20bzoj4668%E5%86%B7%E6%88%98/</url>
    <content><![CDATA[<p>有 $n$个点$,m $个操作，每次连接两个点，或者询问某两个点最早是在什么时刻开始连通的</p>
<span id="more"></span>

<p>并查集按秩合并$+LCA$找最大。</p>
<p>并查集按秩合并：复杂度为$O(nlogn)$，稍劣于路径压缩，但优点在于保留了树形结构，对于每个并查集记录一个值$rank$，初始值为$1$，表示<strong>树高</strong>，每次将$rank$小的并查集根节点合并到$rank$大的并查集根节点上(即把$f[find(x)]$赋值成$find(y))$，并将$v[x]$赋为$cnt$(即当前是第几次合并)这时$rank$不变，若两个并查集$rank$相同，则将一个合并到另一个,将$v[x]$赋值$,rank[find(y)]++;$</p>
<p>在$find$函数中，每次在<strong>回溯</strong>过程中更新每个点的一个值$deep$，表示它的深度$(deep[k]&#x3D;deep[f[k]]+1;)$</p>
<p>若$opt&#x3D;0$，每次用并查集按秩合并两个点.</p>
<p>若$opt&#x3D;1$，则用暴力求$LCA$的方法从一个点不停的走向它的父亲，直到它的$deep\geqslant$另一个点的$deep$，此时若$deep[x]&#x3D;&#x3D;deep[y]$,则退出，否则交换$x$与$y$，继续进行上述过程，直到$x&#x3D;&#x3D;y$，在过程中不断更新$v[x]$的最大值，记录在变量$ans$中，并返回$ans$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dd c=getchar()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;<span class="type">char</span> c;<span class="keyword">while</span> (dd,c&gt;<span class="string">&#x27;9&#x27;</span> || c&lt;<span class="string">&#x27;0&#x27;</span>) <span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) w=<span class="number">-1</span>;<span class="keyword">while</span> (c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>,dd;<span class="keyword">return</span> s*w;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> dd</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;<span class="keyword">if</span> (x&gt;=<span class="number">10</span>) <span class="built_in">write</span>(x/<span class="number">10</span>);<span class="built_in">putchar</span>(x%<span class="number">10</span>|<span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wln</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">write</span>(x);<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);&#125;</span><br><span class="line"><span class="type">int</span> lastans,f[<span class="number">600000</span>],cnt,dep[<span class="number">600000</span>],v[<span class="number">600000</span>],rank[<span class="number">600000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k)<span class="keyword">return</span> k;</span><br><span class="line">    <span class="type">int</span> o=<span class="built_in">find</span>(f[k]);</span><br><span class="line">    dep[k]=dep[f[k]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x==y)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rank[x]&gt;rank[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span> (rank[x]==rank[y])rank[y]++;</span><br><span class="line">    f[x]=y;v[x]=z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x!=y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[x]&lt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,v[x]);</span><br><span class="line">        x=f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;build.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;build.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)f[i]=i,rank[i]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> opt=<span class="built_in">read</span>(),x=<span class="built_in">read</span>()^lastans,y=<span class="built_in">read</span>()^lastans;</span><br><span class="line">        <span class="keyword">if</span> (opt)&#123;</span><br><span class="line">            lastans=<span class="built_in">lca</span>(x,y);</span><br><span class="line">            <span class="built_in">wln</span>(lastans);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">merge</span>(x,y,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>按秩合并</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 牛客练习赛6 手铐</title>
    <url>/2019/04/30/%E9%A2%98%E8%A7%A3%20%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B6%20%E6%89%8B%E9%93%90/</url>
    <content><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/14394">牛客练习赛6手铐</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="$Description$"></a>$Description$</h2><p>给你一个连通无向图，保证每个点最多属于一个简单环，每个点度数最多为$3$，求这个图有多少“手铐图形个数”</p>
<p>其中“手铐图形个数”，定义为三元组$(x,y,S)$，其中$x$和$y$表示图上的两个点，$S$表示一条$x$到$y$的简单路径，而且必须满足：</p>
<p>$1.x$和$y$分别在两个不同的简单环上</p>
<p>$2.x$所在的简单环与路径$S$的所有交点仅有$x,y$所在的简单环与路径$S$的所有交点仅有$y$。</p>
<p>$(x,y,S)$与$(y,x,S)$算同一个手铐</p>
<span id="more"></span>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="$Solution:$"></a>$Solution:$</h2><p>我们考虑把环给缩掉，缩了之后的点叫做方点，然后本来树上的点叫做圆点</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20181226/999991355_1545821389087_404C0DC19BEE420D0B6AB34AD1255851"></p>
<p>缩完后变成</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20181226/999991355_1545821411488_AF56B277606B41329B3AB06A8AE24536"></p>
<p>首先手铐两端都必须是一个方点，然后可以发现如果一条两端都是方点的路径上总共有$x$个方点(不包括两端的方点)，则这两个端点可以构成$2^{x}$个手铐（每次可以走两端）</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20181226/999991355_1545821461432_C8EBD679D5113A4202A7FCCD450A0E8B"></p>
<p>如图这构成了4个手铐</p>
<p>由于无向图缩点后一定形成一棵树，我们考虑对于生成的这个树进行树形$DP$用$f[u]$表示以$u$为根的子树，到$u$构成的“一半的手铐”的数量<br>也就是说这样的：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20181226/999991355_1545821532906_3D6D5DA50070C8F66AC1D55ED432DE8F"></p>
<p>半手铐维护的方法就是</p>
<p>如果u是圆点，则$f[u]&#x3D;\sum f[v]$;</p>
<p>如果u是方点，则$f[u]&#x3D;(\sum f[v])\times 2 + 1$;</p>
<p>因为下面上来的每个半手铐都可以走两个方向，然后这个点也可以作为一个半手铐的端点</p>
<p>在跑树形$DP$时顺便统计答案。</p>
<p>对于每个节点$u$,我们强制它的贡献就是手铐的两端在它的两颗子树中，或是一个在子树中，一个是它自己。</p>
<p>对于手铐的两端在它的两颗子树中，只要算出$\frac{\sum f[v]\times(sum-f[v])}{2}$即可</p>
<p>当节点$u$是方点时，贡献还要$\times 2$再加上所有子树中的半手铐个数(即$u$节点与子树中半手铐匹配)</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="$Code$"></a>$Code$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2003000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 19260817</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next;</span><br><span class="line">&#125;e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,w=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))w|=ch==<span class="string">&#x27;-&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> w?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,u[N],v[N],cnt=<span class="number">1</span>,head[N],dfn[N],low[N],ans,f[N],st[N],top,num,col,w[N],color[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">inv2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (mod-mod/<span class="number">2</span>)%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=v;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> E)</span></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++num;</span><br><span class="line">    st[++top]=u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i==(E^<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v])&#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(v,i);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!color[v])</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[u]==dfn[u])&#123;</span><br><span class="line">        ++col;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ++w[col];color[st[top--]]=col;</span><br><span class="line">        &#125;<span class="keyword">while</span> (st[top+<span class="number">1</span>]!=u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        f[u]=(f[u]+f[v]*w[u]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[u]+=w[u]==<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,sum=(w[u]==<span class="number">2</span>?(f[u]<span class="number">-1</span>)*<span class="built_in">inv2</span>()%mod:f[u]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        res=(res+w[u]*f[v]%mod*((sum-f[v]+mod)%mod))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=(ans+res*<span class="built_in">inv2</span>()%mod)%mod;</span><br><span class="line">    <span class="keyword">if</span> (w[u]==<span class="number">2</span>)ans=(ans+sum)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        u[i]=<span class="built_in">read</span>(),v[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u[i],v[i]);<span class="built_in">add</span>(v[i],u[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            <span class="built_in">Tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=col;++i)w[i]=(w[i]&gt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="keyword">if</span> (color[u[i]]!=color[v[i]])&#123;</span><br><span class="line">            <span class="built_in">add</span>(color[u[i]],color[v[i]]);</span><br><span class="line">            <span class="built_in">add</span>(color[v[i]],color[u[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>$Tarjan$</tag>
        <tag>树形$DP$</tag>
      </tags>
  </entry>
</search>
